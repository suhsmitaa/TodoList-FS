import { SearchQuery } from "../../DataStructures/SearchQuery";
import { Connection } from "../../app";
export declare function SearchLinkMultipleAll(searchQuery: SearchQuery[], token?: string, caller?: any, format?: number): Promise<any>;
/**
 * ######### This layer builds the data. Format is dataid ##########
 * @param linkers list of ids that help us
 * @param conceptIds this is all the concept ids that need  to be composited
 * @param connections these are the internal connections of the compositions that help in creating individual compositions
 * @param reverse this is the list of connection ids that need to show reverse connections(to->from)
 * @param mainCompositionId this is the main centre point of this data.
 * @returns
 */
export declare function DataIdBuildLayer(linkers: number[], conceptIds: number[], connections: number[], reverse: number[], mainCompositionId: number, format?: number): Promise<any>;
/**
 * ## Format is DATAID ##
 * This  is altered format and is different from others because it passes all the connections prebuilt/prefetched
 * This will not let the connections to be again fetched from the memory.
 * @param connections the type connections that need (external connections) to be passed
 * @param compositionData this is a dictionary type of format that has all the build compositions {id: { actual data}}
 * @param mainComposition this is the id of the main composition that builds the tree
 * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)
 * @returns
 */
export declare function FormatFromConnectionsAltered(connections: Connection[], compositionData: any[], mainComposition: number, reverse?: number[]): Promise<any>;
/**
 * ######### Format is normal ######### used for listing.
 * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list
 * The list format is helpful because you do not have to go over each individual query.
 * @param connections the type connections that need (external connections) to be passed
 * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}
 * @param mainComposition this is list of  ids of the main composition that builds the tree
 * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)
 * @returns
 */
export declare function FormatConceptsAndConnections(connections: Connection[], compositionData: any[], mainComposition: number[], reverse?: number[]): Promise<any[]>;
/**
 * ############ Format is data-id and is used for list. ############
 * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list
 * The list format is helpful because you do not have to go over each individual query.
 * @param connections the type connections that need (external connections) to be passed
 * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}
 * @param mainComposition this is list of  ids of the main composition that builds the tree
 * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)
 * @returns
 */
export declare function FormatFromConnectionsAlteredArray(connections: Connection[], compositionData: any[], conceptIds: number[], mainComposition: number[], reverse?: number[]): Promise<any[]>;
/**
 * ########## Format works with JUSTDATA / NORMAL ########### used for single origin concept
 * @param linkers this is the list of linkers that
 * @param compositionData
 * @param mainComposition
 * @param reverse list of connection ids that need to show reverse conneciton.
 * @returns
 */
export declare function FormatFromConnections(linkers: number[], compositionData: any[], mainComposition: number, reverse?: number[]): Promise<any>;
