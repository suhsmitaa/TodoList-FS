import { Concept } from "../DataStructures/Concept";
import { Connection } from "../DataStructures/Connection";
export declare function GetCompositionById(id: number): Promise<{
    connectionList: Connection[];
    compositionList: number[];
}>;
/**
 * ## format JUSTDATA ##
 * this function builds the composition with the main id as the point of building.
 * @param id id of the main composition that you want to build
 * @param connectionList  list of connections
 * @param compositionList list of of_the_concept_ids for all the connections.
 * @returns
 */
export declare function RecursiveFetchBuildLayer(id: number, connectionList: Connection[], compositionList: number[]): Promise<any>;
/**
 * ## format DATAID ##
 * this function builds the composition with the main id as the point of building.
 * @param id id of the main composition that you want to build
 * @param connectionList  list of connections
 * @param compositionList list of of_the_concept_ids for all the connections.
 * @returns
 */
export declare function RecursiveFetchBuildLayerDataId(id: number, connectionList: Connection[], compositionList: number[]): Promise<any>;
/**
 * ## format Normal ##
 * this function builds the composition with the main id as the point of building.
 * @param id id of the main composition that you want to build
 * @param connectionList  list of connections
 * @param compositionList list of of_the_concept_ids for all the connections.
 * @returns
 */
export declare function RecursiveFetchBuildLayerNormal(id: number, connectionList: Connection[], compositionList: number[]): Promise<any>;
/**
 * ## format JUSTDATA ##
 * this function builds the composition with the main id as the point of building.
 * This just requires the id
 * @param id id of the main composition that you want to build
 * @param connectionList  list of connections
 * @param compositionList list of of_the_concept_ids for all the connections.
 * @returns
 */
export declare function GetComposition(id: number): Promise<any>;
export declare function GetCompositionWithAllIds(id: number): Promise<any>;
/**
 * ### Format JUSTDATA ###
 * This function just builds data from the memory.
 * This is a function that takes on all the concepts and connections of the concept (as a composition ) and builds
 * it into a json data.
 * @param id this id is just used to get all the composition data from the concepts and connections in memory
 * @returns
 */
export declare function GetCompositionFromMemory(id: number): Promise<any>;
/**
 * ### Format Normal ###
 * This function just builds data from the memory.
 * This is a function that takes on all the concepts and connections of the concept (as a composition ) and builds
 * it into a json data.
 * @param id this id is just used to get all the composition data from the concepts and connections in memory
 * @returns
 */
export declare function GetCompositionFromMemoryNormal(id: number): Promise<any>;
/**
 * ### Format DATAIDDATE ####
 * Gets data just from memory
 * @param id
 * @returns
 */
export declare function GetCompositionWithIdFromMemory(id: number): Promise<any>;
/**
 * ### Format DATAIDDATE ####
 * ### experimental ####
 * This is the new format that needs to work with a single or max two loops
 * @param id the id whose composition needs to be created
 * @returns
 */
export declare function GetCompositionWithIdFromMemoryNew(id: number): Promise<any>;
/**
 * ### Format DATAIDDATE #####
 * ### This just returns composition from memory and not from anywhere else.
 * @param id
 * @returns
 */
export declare function GetCompositionWithIdAndDateFromMemory(id: number): Promise<any>;
export declare function GetCompositionWithIdFromMemoryFromConnections(id: number, connectionList?: Connection[]): Promise<any>;
/**
 * #### Format DATAID ####
 * ## This will return the composition even if it is not in the local memory ##
 * @param id
 * @returns
 */
export declare function GetCompositionWithId(id: number): Promise<any>;
/**
 * ## Format justdata ###
 * ## This contains a concept in the parameter so that you dont have to again find the concept ##
 * This function takes concepts and connections and then builds a json.
 * @param concept The concept that needs to get other concepts that are inside of it.
 * @param connectionList List of connections that are available in the composition. We have to loop over it.
 * @param compositionList Composition list is the list of concepts that have connections inside of them.
 * @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.
 * @returns
 */
export declare function recursiveFetchConcept(concept: Concept, connectionList: Connection[], compositionList: number[], visitedConcepts?: number[]): Promise<any>;
/**
* ## Format Normal ###
* ## This contains a concept in the parameter so that you dont have to again find the concept ##
* This function takes concepts and connections and then builds a json.
* @param concept The concept that needs to get other concepts that are inside of it.
* @param connectionList List of connections that are available in the composition. We have to loop over it.
* @param compositionList Composition list is the list of concepts that have connections inside of them.
* @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.
* @returns
*/
export declare function recursiveFetchConceptNormal(concept: Concept, connectionList: Connection[], compositionList: number[], visitedConcepts?: number[]): Promise<any>;
/**
 * ## experimental ##
* This function takes concepts and connections and then builds a json.
* @param concept The concept that needs to get other concepts that are inside of it.
* @param connectionList List of connections that are available in the composition. We have to loop over it.
* @param compositionList Composition list is the list of concepts that have connections inside of them.
* @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.
* @returns
*/
export declare function recursiveFetchConceptSingleLoop(concept: Concept, connectionList: Connection[], compositionList: number[], visitedConcepts?: number[]): Promise<any>;
/**
 * ## Format justdata ##
 * @param id
 * @param connectionList
 * @param compositionList
 * @param visitedConcepts
 * @returns
 */
export declare function recursiveFetch(id: number, connectionList: Connection[], compositionList: number[], visitedConcepts?: number[]): Promise<any>;
export declare function recursiveFetchWithSubCompositions(id: number, connectionList: Connection[], compositionList: number[], visitedConcepts?: number[]): Promise<any>;
