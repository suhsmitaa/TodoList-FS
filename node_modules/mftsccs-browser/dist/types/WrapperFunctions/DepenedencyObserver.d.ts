/**
 * This is the class that helps us observe anything that the function is doing
 * This wrapper will allow all the concepts and connections to be tracked inside of the called function
 * This function helps us manage state using the concept connection system.
 */
export declare class DependencyObserver {
    subscribers: any[];
    mainConcept: number;
    compositionIds: number[];
    conceptIds: number[];
    internalConnections: number[];
    reverse: number[];
    linkers: number[];
    dependency: number[];
    isDataLoaded: boolean;
    isUpdating: boolean;
    data: any;
    fetched: boolean;
    format: number;
    /**
     * This function will be called when there is a need to listen to a certain type of concept that will update
     *  the ui.
     * @param id this is the type id which needs to be tracked
     */
    listenToEventType(id: number): void;
    /**
     * This is the of the concept id that needs to be listened . If this is called. All the connections that are
     * created with of the concepts id with this passed id then the event is fired.
     *
     * @param id Of the concept id that needs to be listened.
     */
    listenToEvent(id: number): void;
    /**
     * This function will bind the actual data to the widget or the function.
     */
    bind(): Promise<void>;
    /**
     *
     * @param callback the function that needs to be called with the data.
     * @returns returns the callback with this data as the state.
     */
    subscribe(callback: any): Promise<any>;
    /**
     *
     * @param callback function that you need to remove from the subscribers list.
     * @returns
     */
    unsubscribe(callback: any): number;
    /**
     * This function will call all the subscribers that are registered in this wrapper.
     */
    notify(): void;
}
