{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+E;AACtB;AACQ;AACV;AACqB;AACP;AAC9D;AACP;AACA;AACA;AACA,4BAA4B,oFAAmB;AAC/C;AACA,6BAA6B,qFAAgB;AAC7C,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oBAAoB,8EAAe;AACnC,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA,0CAA0C,sEAAY;AACtD;AACA,gBAAgB,oFAAmB;AACnC;AACA;AACA;AACA,wCAAwC,8DAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACrDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACqB;AAC3B;AACyC;AACnF;AACP;AACA,qBAAqB,0DAAoB;AACzC;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6D;AACN;AACqB;AACP;AAC9D;AACP;AACA,yBAAyB,kEAAU;AACnC;AACA,yBAAyB,qFAAgB;AACzC;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC3CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmB;AACL;AAC9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+EAAY;AACnE;AACA,wCAAwC,4DAAO;AAC/C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACpDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACqB;AACP;AAC9D;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmC;AACZ;AAC5D;AACf;AACA;AACA;AACA;AACA,yBAAyB,uFAAkB;AAC3C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,qDAAqD,gBAAgB;AACrE;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmC;AACZ;AAC5D;AACf;AACA;AACA;AACA;AACA,yBAAyB,uFAAkB;AAC3C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACnF;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACS;AAC0B;AACf;AACkB;AACnF;AACP;AACA;AACA;AACA,yBAAyB,sGAAiC;AAC1D,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,qEAAY;AAC5B;AACA,YAAY,oFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AACc;AAChF;AACP;AACA;AACA;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,qEAAY;AAChC;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACd;AACgC;AACX;AACc;AAChF;AACP;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gGAA0B;AACtC;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb,kEAAkE,4DAAO;AACzE;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,0EAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACnEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACd;AACkC;AAC2B;AAC7B;AACX;AACc;AAChF;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6HAAyC;AAC/E;AACA;AACA,QAAQ,gGAA0B;AAClC,cAAc,kGAA2B;AACzC;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,0EAAc;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AChEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACd;AACxC;AAC1B;AACP;AACA;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,yCAAO,sDAAsD,UAAU;AAChH;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,yCAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACd;AACxC;AAC1B;AACP;AACA;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,yCAAO,sDAAsD,UAAU;AAChH;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,yCAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACd;AACmC;AAChF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,0EAAc;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AChDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AAC3B;AACyC;AACvF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,0DAAoB;AAC7C,mCAAmC,qEAAY;AAC/C,wBAAwB,qEAAY;AACpC;AACA;AACA;AACA;AACA,6BAA6B,qFAAgB;AAC7C,+CAA+C,4DAAO;AACtD;AACA;AACA,6CAA6C,4DAAO;AACpD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,qEAAY;AACpC;AACA;AACA,wBAAwB,qEAAY;AACpC;AACA;AACA;AACA;AACA,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC/DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AACc;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD,2CAA2C,qEAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qFAAgB;AACjD,iDAAiD,4DAAO;AACxD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA,gCAAgC,qEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA;AACA;AACA;AACA;AACA,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kFAAmB,QAAQ,4DAAO;AAClD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACjIA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AACc;AAChF;AACP;AACA,4BAA4B,qEAAY;AACxC;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA,6BAA6B,qFAAgB;AAC7C,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,qEAAY;AAChC;AACA;AACA,0DAA0D,gBAAgB;AAC1E,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACpDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACN;AACyC;AAChF;AACP;AACA,qBAAqB,0DAAoB;AACzC;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,qEAAY;AAChC;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACc;AACO;AACc;AAChF;AACP;AACA,2BAA2B,0EAAc;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAgB;AAC7C;AACA;AACA,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,0EAAc;AAClC;AACA;AACA,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AClDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoE;AAChB;AACkC;AACb;AACc;AACvF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,2CAA2C,0EAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qFAAgB;AACjD,iDAAiD,4DAAO;AACxD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA,gCAAgC,0EAAc;AAC9C;AACA;AACA;AACA;AACA,wBAAwB,8EAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,cAAc,kGAA2B;AACzC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AChFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACqB;AACc;AAChF;AACP;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD,mDAAmD,eAAe;AAClE,2CAA2C,OAAO;AAClD,2CAA2C,OAAO;AAClD,yCAAyC,KAAK;AAC9C,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC/CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsE;AAClB;AACqB;AACc;AAChF;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,8EAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACxCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACR;AACqB;AACc;AAChF;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,oEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACxCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkF;AAC3B;AACqB;AAC1B;AACmB;AAC9D;AACP;AACA,qBAAqB,2DAAqB;AAC1C;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,yCAAyC,eAAe;AACxD,aAAa;AACb;AACA;AACA;AACA,oBAAoB,qFAAiB;AACrC;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmB;AACgB;AAChF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,+EAAY;AAC5B,iDAAiD,+EAAY;AAC7D;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACjDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmC;AACd;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC1CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACqB;AACD;AACuC;AACxB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,oFAAoB;AAC1C;AACA;AACA,4BAA4B,2HAAgC;AAC5D;AACA,6BAA6B,qFAAgB;AAC7C,6CAA6C,4DAAO;AACpD;AACA;AACA,kCAAkC,KAAK;AACvC,iBAAiB;AACjB;AACA,oBAAoB,8EAAe;AACnC,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACtDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACQ;AAC6B;AAChB;AACc;AAChF;AACP;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iCAAiC,qGAAuC;AACxE;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;AACO;AACP;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACjLA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACX;AACqB;AAC3B;AACyC;AACnF;AACP;AACA,sBAAsB,0DAAoB;AAC1C;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,yCAAyC,eAAe,eAAe,YAAY;AACnF,aAAa;AACb;AACA;AACA;AACA,gBAAgB,qEAAY;AAC5B;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6F;AACtC;AACmC;AACnF;AACP;AACA,qBAAqB,sGAAiC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAO;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoC;AACsD;AACG;AACtF;AACP;AACA,qBAAqB,sGAAiC;AACtD,uBAAuB,yCAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;AACO;AACP;AACA,qBAAqB,sGAAiC;AACtD,uBAAuB,yCAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACG;AACtF;AACP;AACA,qBAAqB,sGAAiC;AACtD,yBAAyB,4DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACG;AACtF;AACP;AACA,qBAAqB,sGAAiC;AACtD,yBAAyB,4DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoC;AACsD;AACG;AACtF;AACP;AACA,uBAAuB,yCAAO;AAC9B,qBAAqB,sGAAiC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4E;AACrB;AACmC;AACnF;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,KAAK,4DAAO;AAC3C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACpCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACd;AACrE;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,KAAK,4DAAO;AAC3C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACtD;AAClB;AACf;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACrDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACtD;AAClB;AACf;AACA,8CAA8C,yCAAO;AACrD;AACA,KAAK;AACL;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC3DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACG;AAC9B;AACxD;AACP;AACA,qBAAqB,0DAAoB;AACzC;AACA,yBAAyB,sGAAiC;AAC1D,yCAAyC,4DAAO;AAChD;AACA;AACA,4BAA4B,UAAU;AACtC,aAAa;AACb;AACA;AACA;AACA,oBAAoB,8CAAY;AAChC;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACc;AACO;AACjC;AACpC;AACP;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA,oBAAoB,oDAAc;AAClC;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACpDO;AACA;AACA;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3JA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACtB;AACvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AAC9B;AACsB;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uCAAI;AAC3B,gCAAgC,uCAAI;AACpC,QAAQ,qEAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuC;AACiC;AACpB;AACd;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,IAAI,sBAAsB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS,KAAK,uBAAuB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD,wCAAwC,mDAAa;AACrD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1M8C;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAY;AAC3C,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACL;AACP;AAC7D;AACP;AACA;AACA;AACA,2BAA2B,oFAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA,gCAAgC,yFAAiB;AACjD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDgE;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjLiC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6E;AACnC;AACkB;AACV;AACsB;AACjE;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAgB;AAC5B;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAU;AACtB,YAAY,2DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAU;AACtB,YAAY,2DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA,QAAQ,uEAAkB;AAC1B;AACA;AACA;AACA,4BAA4B,oFAAoB;AAChD,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C;AACA,4BAA4B,2DAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,6BAA6B,qEAAmB;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAc;AAC9C;AACA,SAAS;AACT;AACA;AACA,eAAe,qEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrLwE;AACpC;AAC7B;AACP;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC,oBAAoB,oFAAoB;AACxC,yBAAyB,oFAAoB;AAC7C,yBAAyB,oFAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACH;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACxEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5YgD;AACzC,+BAA+B,yDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsD;AACtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AC7FA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACH;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;AClGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6E;AACnC;AACyC;AACF;AACF;AACxE;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAoB;AAC5B,QAAQ,wFAAkB;AAC1B,QAAQ,0FAAmB;AAC3B;AACA;AACA;AACA,YAAY,4FAAoB;AAChC,YAAY,wFAAkB;AAC9B,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAkB;AAC9B,YAAY,4FAAoB;AAChC,YAAY,wFAAkB;AAC9B,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA,QAAQ,0FAAmB;AAC3B;AACA;AACA,0BAA0B,0FAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4FAAoB;AACnC;AACA;AACA,eAAe,wFAAkB;AACjC;AACA;AACA;AACA,kBAAkB,4FAAoB;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAU;AAC7C,6BAA6B,4FAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,wFAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD,iCAAiC,4FAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnKO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVqC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BiD;AACZ;AAC9B;AACP;AACA;AACA,6BAA6B,6CAAO;AACpC,oBAAoB,0DAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxhBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACd;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,+CAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5FA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACZ;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAK;AAC5B,gCAAgC,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AClFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACvB;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,yCAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjGA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmF;AAC/B;AACkB;AACV;AACuB;AACrC;AACQ;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAgB;AAC5B,YAAY,6DAAe;AAC3B,YAAY,+EAAwB;AACpC,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAe;AAC3B,YAAY,+EAAwB;AACpC,YAAY,qEAAmB;AAC/B,YAAY,+DAAgB;AAC5B,6BAA6B,0EAAkB;AAC/C,YAAY,sDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAe;AACnC,oBAAoB,+EAAwB;AAC5C,oBAAoB,qEAAmB;AACvC,0BAA0B,0EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,6DAAe;AAC3B,YAAY,+EAAwB;AACpC,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,4FAAqB;AACjD,6BAA6B,6DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,6DAAe;AAC3B,SAAS;AACT;AACA;AACA;AACA,4BAA4B,4FAAqB;AACjD,6BAA6B,+DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,4FAAqB;AAC/C,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA,uBAAuB,+EAAwB;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,4FAAqB;AAC/C;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA,6BAA6B,+EAAwB;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,4FAAqB;AAC/C,6BAA6B,+EAAwB;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA,gCAAgC,qEAAmB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClKA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACE;AAC4C;AAC1D;AACE;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAkB;AAC9B,YAAY,2DAAc,eAAe,sHAAkC;AAC3E;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrIA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACZ;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACnEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0I;AACnI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+GAAgC;AAC9D;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,kDAAkD,8BAA8B;AAChF,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+GAAgC;AAC1D;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,6CAA6C,8BAA8B;AAC3E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iHAAkC;AAChE;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iHAAkC;AAC5D;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,gDAAgD,8BAA8B;AAC9E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqF;AACtB;AACR;AACL;AACU;AACrD;AACP;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA,0BAA0B,gEAAiB;AAC3C;AACA;AACA;AACA,mCAAmC,8FAAwB;AAC3D;AACA;AACA,gCAAgC,qBAAqB;AACrD,oBAAoB,gEAAiB;AACrC;AACA,gCAAgC,wBAAwB;AACxD,oBAAoB,qEAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gEAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gEAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAqB;AACjD,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE,oBAAoB,wEAAgB;AACpC;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE,oBAAoB,wEAAgB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/iBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACTA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC2E;AACpB;AAChD;AACP;AACA;AACA;AACA,gCAAgC,mEAAc;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0CAA0C,uFAAwB;AAClE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9CqC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;;;;;;;;;;;;;;;ACFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACc;AACM;AACjC;AACK;AAC3C;AACP;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D,gBAAgB,sDAAY;AAC5B;AACA,4BAA4B,qCAAqC;AACjE,gBAAgB,2DAAc;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,oFAAmB;AACnC;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA,sBAAsB,0FAAsB;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE,oBAAoB,oEAAe;AACnC;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE,oBAAoB,oEAAe;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;AChHO;AACP;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzKA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsC;AACiB;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1JA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACtB;AAC/B;AACP,WAAW,+CAAO;AAClB;AACO;AACP;AACO;AACP,2BAA2B,oEAAW;AACtC;AACA;AACO;AACP;AACO;AACP;AACA,KAAK;AACL;AACO;AACP;AACA,KAAK;AACL;AACO;AACP;AACO;AACP;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACnCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAO,iCAAiC,yCAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,oEAAoE,eAAe,GAAG;AACtF;AACA;AACA;AACA,+DAA+D;AAC/D,uEAAuE,eAAe,GAAG;AACzF;AACA;AACA;AACA,uDAAuD;AACvD,+DAA+D,eAAe,GAAG;AACjF;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE,4CAA4C,wBAAwB;AACpE,4CAA4C,kBAAkB,yCAAO,kBAAkB;AACvF;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,+CAA+C,wBAAwB;AACvE,KAAK;AACL;AACO;AACP;AACA,+CAA+C,yBAAyB;AACxE;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;AClSA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACR;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAO,4BAA4B,4DAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,oEAAoE,eAAe,GAAG;AACtF;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,uEAAuE,eAAe,GAAG;AACzF;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAW;AAClD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACxT0D;AACc;AACjE;AACP,uBAAuB,oFAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B,kEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B,kEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3HO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACpBe;AACf;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLO;AACP,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACZkF;AAC3E;AACP;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgE;AACW;AACH;AACxE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mEAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mEAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA;AACA;AACA,gEAAgE,mEAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,oFAAoB;AACtC,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AClIA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgE;AAC0B;AAC1B;AACd;AACK;AACJ;AACwB;AACoB;AAC/B;AAChE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oGAAqB;AAC7C;AACA,4BAA4B,qEAAY;AACxC;AACA,wCAAwC,2DAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mGAA8B;AAC3E;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oGAAqB;AAC7C;AACA,4BAA4B,qEAAY;AACxC;AACA,wCAAwC,2DAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mGAA8B;AAC3E;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qCAAqC,yEAAiB;AACtD;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC,gFAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAiB;AAC9C;AACA,QAAQ,oGAAqB;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,iFAAiF;AACzG,qCAAqC,qEAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAoB;AACpD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC7LA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACY;AACZ;AACU;AACzE;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA,8BAA8B,gFAAW;AACzC;AACA;AACA;AACA,4CAA4C,mEAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kFAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mEAAsB;AAClE;AACA;AACA,+CAA+C,kFAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACzEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkF;AACyC;AAC9C;AACtE;AACP;AACA,sBAAsB,0DAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,8CAAY;AACxC;AACA,4BAA4B,2FAA0B;AACtD;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,8CAAY;AACxC;AACA,4BAA4B,oIAAyC;AACrE;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACrD6D;AACE;AACQ;AAChE;AACP;AACA,qBAAqB,mFAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,2EAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,kEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgD;AACc;AACD;AACO;AACpE;AACA;AACA;AACe;AACf;AACA;AACA,oCAAoC,0EAAqB;AACzD;AACA,gCAAgC,wBAAwB;AACxD;AACA,oBAAoB,qEAAY;AAChC;AACA;AACA,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B;AACA;AACA,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6E;AACnB;AACJ;AACQ;AACY;AAChB;AACd;AACkB;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAsB;AACvE,oCAAoC,kEAAU;AAC9C,YAAY,8DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAsB;AAC5D,gCAAgC,kEAAU;AAC1C,QAAQ,8DAAQ;AAChB;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAsB;AACpE,sCAAsC,yFAAyB;AAC/D;AACA;AACA,2BAA2B,2EAAoB;AAC/C,wBAAwB,wBAAwB;AAChD,kCAAkC,0DAAa;AAC/C;AACA;AACA;AACA,iCAAiC,mEAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAsB;AACvD,4BAA4B,wBAAwB;AACpD,gBAAgB,uEAAoB;AACpC;AACA;AACA,gCAAgC,kEAAU;AAC1C,cAAc,8DAAQ;AACtB,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAsB;AACvE,oCAAoC,kEAAU;AAC9C,YAAY,8DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAsB;AAC5D,kCAAkC,uFAA0B;AAC5D;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC/GoD;AAC7C;AACP;AACA;AACA,sBAAsB,4DAAO;AAC7B;AACA;;;;;;;;;;;;;;;;;;ACNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC8D;AACF;AACE;AAC/C;AACf;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA;AACA;AACA,8CAA8C,mEAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAsB;AACpE;AACA;AACA,0BAA0B,yEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mEAAsB;AAChE;AACA,sBAAsB,yEAAmB;AACzC;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACpDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACwE;AACpB;AACQ;AACN;AAChB;AACvB;AACf;AACA,uBAAuB,oEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAO;AACjC;AACA,QAAQ,8DAAQ;AAChB;AACA,KAAK;AACL;AACO;AACP;AACA,uBAAuB,oEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAO;AACjC;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,uBAAuB,oEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAO;AACjC,QAAQ,8CAAY;AACpB,QAAQ,oFAAmB;AAC3B;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvD0D;AACJ;AACM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB,kEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAQ;AAChB;AACA;AACA,QAAQ,yEAAmB;AAC3B;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACY;AACS;AACzB;AAC/C;AACP;AACA;AACA;AACA,2BAA2B,8EAAqB;AAChD,iCAAiC,kEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAQ;AACpB;AACA;AACA;AACA,sBAAsB,uFAAkB;AACxC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AClCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACqB;AAClB;AACQ;AAC+B;AACrD;AACrC;AACP;AACA,4BAA4B,0DAAa;AACzC;AACA;AACA,cAAc,0EAAc;AAC5B,cAAc,oFAAmB;AACjC;AACA,cAAc,iEAAgB;AAC9B,cAAc,kEAAU;AACxB,cAAc,yGAAmB;AACjC,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC3BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6D;AACsC;AACJ;AAC1C;AAC9C;AACP;AACA,+BAA+B,kEAAiB;AAChD,cAAc,oEAAmB;AACjC;AACA,QAAQ,2GAAoB;AAC5B,QAAQ,uGAAkB;AAC1B,KAAK;AACL;;;;;;;;;;;;;;;;ACrBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mEAAc;AAChC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC7BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AAC3D;AACP;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA,uCAAuC,0EAAc;AACrD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+C;AACwC;AAC1B;AACK;AAC3B;AAChC;AACP;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA,8CAA8C,qEAAY;AAC1D;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA,8DAA8D,2DAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA,8CAA8C,qEAAY;AAC1D;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA,8DAA8D,2DAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD,oCAAoC,mDAAa;AACjD,sCAAsC,mDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA,0CAA0C,qEAAY;AACtD;AACA;AACA,8CAA8C,2DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,8CAA8C,qEAAY;AAC1D;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA,8DAA8D,2DAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA,0CAA0C,qEAAY;AACtD;AACA;AACA,8CAA8C,2DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,0CAA0C,qEAAY;AACtD;AACA,kDAAkD,2DAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,sDAAsD,qEAAY;AAClE;AACA;AACA,0DAA0D,2DAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7wBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+F;AAClC;AACL;AACyB;AACsB;AACwD;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,2GAAkC;AAChD;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,yEAAwB;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,2GAAkC;AAChD;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mCAAmC,yEAAiB;AACpD,mCAAmC,oHAAyC;AAC5E,QAAQ,8FAAiC;AACzC;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mCAAmC,yEAAiB;AACpD;AACA,mCAAmC,oHAAyC;AAC5E,QAAQ,8FAAiC;AACzC;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mCAAmC,yEAAiB;AACpD;AACA,mCAAmC,oHAAyC;AAC5E,QAAQ,8FAAiC;AACzC;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,yEAAwB;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD,mCAAmC,gDAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yEAAiB;AACzD;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA,cAAc,oDAAc;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,kFAAiC;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,yEAAwB;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5OA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmE;AAC4B;AAClC;AACgB;AACD;AACgB;AACE;AAClB;AAC5E;AACA;AACO;AACP;AACA,4BAA4B,kEAAqB;AACjD;AACA;AACA,kBAAkB,+EAAoB;AACtC,oCAAoC,qEAAY;AAChD;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA,kBAAkB,2GAAkC;AACpD,oCAAoC,wBAAwB;AAC5D;AACA,gDAAgD,yEAAwB;AACxE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,mCAAmC,6DAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACO;AACP;AACA,iCAAiC,6EAA0B;AAC3D,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qFAAiB;AACtD;AACA;AACA,kBAAkB,+EAAoB;AACtC,sCAAsC,qEAAY;AAClD;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,kEAAqB;AACjD;AACA;AACA,kBAAkB,+EAAoB;AACtC,oCAAoC,qEAAY;AAChD;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA,kBAAkB,2GAAkC;AACpD,oCAAoC,wBAAwB;AAC5D;AACA,gDAAgD,+EAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,oFAA4B;AACxD;AACA;AACA,kBAAkB,+EAAoB;AACtC,oCAAoC,qEAAY;AAChD;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA,kBAAkB,2GAAkC;AACpD,oCAAoC,wBAAwB;AAC5D;AACA,gDAAgD,+EAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAA6C;AAC7E;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD,wCAAwC,+DAAyB;AACjE;AACA;AACA,cAAc,2GAAkC;AAChD,gCAAgC,6CAA6C;AAC7E;AACA,4CAA4C,+EAA8B;AAC1E;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AClMA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+E;AAClB;AAC9C;AACf;AACA,4BAA4B,qEAAY;AACxC,kCAAkC,eAAe;AACjD;AACA,kBAAkB,2FAA0B;AAC5C,4BAA4B,qEAAY;AACxC;AACA,gCAAgC,qEAAY;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,qEAAY;AACxC,kCAAkC,eAAe;AACjD;AACA,kBAAkB,2FAA0B;AAC5C,4BAA4B,qEAAY;AACxC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACnCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACiH;AAC5C;AACP;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0BAA0B,0DAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAsB;AACtD;AACA;AACA,gCAAgC,2DAAqB;AACrD;AACA,gCAAgC,6HAA2C;AAC3E;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC/CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACa;AAC3D;AACP;AACA,+BAA+B,0EAAc;AAC7C;AACA,yCAAyC,iEAAa;AACtD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACpBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACgB;AACZ;AACR;AACvD;AACP;AACA;AACA,uCAAuC,0EAAqB;AAC5D;AACA,gCAAgC,2BAA2B;AAC3D,oBAAoB,0EAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,uCAAuC,kFAA0B;AACjE;AACA,gCAAgC,2BAA2B;AAC3D,oBAAoB,0FAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACtDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmF;AACN;AACJ;AAC7B;AACmD;AACxF;AACP;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC;AACA,yCAAyC,+FAA4B;AACrE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,kBAAkB,2GAAkC;AACpD,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD,2CAA2C,sFAAqC;AAChF;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC;AACA,yCAAyC,+FAA4B;AACrE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC/DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqG;AACJ;AACrD;AACrC;AACP;AACA,gCAAgC,iHAAqC;AACrE,wBAAwB,wBAAwB;AAChD;AACA;AACA,gCAAgC,0DAAa;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,gCAAgC,6GAAmC;AACnE,wBAAwB,wBAAwB;AAChD;AACA;AACA,gCAAgC,0DAAa;AAC7C;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACnCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6E;AACJ;AAC7B;AACmD;AACM;AAC9F;AACP;AACA;AACA,4BAA4B,0DAAa;AACzC,yCAAyC,kHAAgC;AACzE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,kBAAkB,2GAAkC;AACpD,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD,2CAA2C,sFAAqC;AAChF;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,4BAA4B,0DAAa;AACzC,yCAAyC,kHAAgC;AACzE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC3DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+C;AACuB;AACT;AACC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA,qCAAqC,oDAAc;AACnD,0BAA0B,kEAA4B;AACtD;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA,4CAA4C,qEAAY;AACxD;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AClDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6C;AACe;AACN;AAC0C;AACzB;AACxD;AACf;AACA;AACA,kBAAkB,iEAAY;AAC9B,kBAAkB,oEAAW;AAC7B;AACA,sCAAsC,gFAA2B;AACjE;AACA;AACA;AACA;AACA,sBAAsB,yDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,QAAQ,8DAAQ;AAChB,8BAA8B,oEAAW,CAAC,8DAAQ;AAClD,QAAQ,iEAAY;AACpB,KAAK;AACL;;;;;;;;;;;;;;;;AC/C6D;AACtD;AACP,yBAAyB,kEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkF;AAC3E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iEAA2B;AAChF,mCAAmC,8DAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iEAA2B;AACrE,sCAAsC,8DAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACvCuD;AAChD;AACP;AACA;AACA,sBAAsB,4DAAO;AAC7B;AACA;;;;;;;;;;;;;;;;;;;;;;ACNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuE;AACS;AACnB;AAC8B;AAC/B;AAC5D;AACA;AACA;AACe;AACf;AACA;AACA;AACA,oCAAoC,kFAA0B;AAC9D;AACA,gCAAgC,wBAAwB;AACxD;AACA,oBAAoB,qFAAiB;AACrC;AACA;AACA,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B;AACA;AACA,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,kFAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAO;AACnC;AACA;AACA,kCAAkC,wEAAgB,cAAc,4CAA4C;AAC5G;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8CAA8C;AAC9C,4BAA4B,kEAAO;AACnC,kCAAkC,wEAAgB;AAClD;AACA;AACA;AACA,wBAAwB,yCAAO;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC,kFAA0B;AAC7D;AACA;AACA;AACA;AACA,4BAA4B,kEAAO;AACnC,kCAAkC,wEAAgB,cAAc,0CAA0C;AAC1G;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8CAA8C;AAC9C,4BAA4B,kEAAO;AACnC,kCAAkC,wEAAgB;AAClD;AACA;AACA;AACA,wBAAwB,yCAAO;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvJA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuE;AACD;AACM;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0BAA0B,mFAAqB;AAC/C;AACA;AACA;AACA;AACA,8CAA8C,yFAA2B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yFAA2B;AACzE;AACA,0BAA0B,mFAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yFAA2B;AACrE;AACA,sBAAsB,mFAAwB;AAC9C;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACyB;AACnB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,2BAA2B,kEAAO;AAClC;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAO;AACzC;AACA;AACA,8BAA8B,4DAAO;AACrC;AACA;AACA,YAAY,qFAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACxDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6D;AACwB;AACxB;AACnB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iCAAiC,kEAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAU;AAC3C;AACA,iCAAiC,kEAAU;AAC3C;AACA;AACA,sBAAsB,+CAAa;AACnC,gBAAgB,0FAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACrDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACtB;AACnD;AACP;AACA,4BAA4B,uEAAkB;AAC9C,QAAQ,qFAAiB;AACzB,KAAK;AACL;;;;;;;;;;;;;;;;;;;AChBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACO;AACjB;AACtE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,uEAA0B;AAC1D;AACA;AACA,wCAAwC,qFAAiB;AACzD,gCAAgC,wBAAwB;AACxD,gDAAgD,yEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,uEAA0B;AAC1D;AACA;AACA,wCAAwC,qFAAiB;AACzD,gCAAgC,wBAAwB;AACxD,gDAAgD,+EAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC7DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACK;AACL;AAC7B;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,0FAAmB;AACtD;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,gCAAgC,qFAAiB;AACjD;AACA,wCAAwC,yFAAoB;AAC5D;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0FAAmB;AACtD;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,gCAAgC,qFAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAiB;AAC7C;AACA;AACA;AACA,0CAA0C,qFAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,0CAA0C,qFAAiB;AAC3D;AACA;AACA;AACA,sDAAsD,qFAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC/HA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkG;AAClB;AAChB;AACjD;AACf;AACA,4BAA4B,qFAAiB;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB,2DAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,sBAAsB,qFAAiB;AACvC;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,gCAAgC,qFAAiB;AACjD,sCAAsC,eAAe;AACrD;AACA,sBAAsB,2GAA+B;AACrD,gCAAgC,qFAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACrEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqF;AAC9E;AACP;AACA;AACA,oCAAoC,0FAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACpBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACL;AAC3E;AACP;AACA;AACA,oCAAoC,2EAAqC;AACzE;AACA;AACA,yCAAyC,+FAA8B;AACvE;AACA;AACA,4BAA4B,6BAA6B;AACzD,iCAAiC,yDAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC9BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACD;AACd;AACY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2BAA2B,2DAAqB;AAChD;AACA,iCAAiC,qFAAiB;AAClD;AACA,0CAA0C,oFAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAa;AACjD,2BAA2B,yFAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC/CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACpB;AAC7C;AACf;AACA,kCAAkC,qFAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACzBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACC;AACmB;AACtC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0EAAuB;AACrE;AACA,0CAA0C,kEAAqB;AAC/D;AACA;AACA;AACA,8CAA8C,0EAAuB;AACrE;AACA,0CAA0C,kEAAqB;AAC/D;AACA;AACA;AACA,8CAA8C,0EAAuB;AACrE;AACA,oDAAoD,qFAAiB;AACrE;AACA;AACA;AACA,8CAA8C,kEAAqB;AACnE;AACA;AACA;AACA;AACA,YAAY,+CAAa;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC9EA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACyB;AACtC;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,kGAAqC;AACzE;AACA;AACA,0CAA0C,2DAAY;AACtD;AACA,wCAAwC,gEAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACnDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACqE;AACvC;AAC3C;AACc;AACW;AACI;AACe;AACsB;AACjH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAqB;AAC/C,4BAA4B,2DAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mGAA8B;AACzE;AACA,wBAAwB,mCAAmC;AAC3D,gCAAgC,+FAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD,wCAAwC,0DAAa;AACrD;AACA;AACA,8BAA8B,yFAA4B;AAC1D;AACA;AACA,gCAAgC,yFAA4B;AAC5D;AACA,6BAA6B,yFAA4B;AACzD;AACA;AACA;AACA;AACA,mCAAmC,2DAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yFAA2B;AACpE,sBAAsB,qFAAyB;AAC/C;AACA;AACA;AACA,yCAAyC,yFAA2B;AACpE;AACA;AACA,qCAAqC,yFAAiC;AACtE;AACA,4BAA4B,6BAA6B;AACzD;AACA,gDAAgD,sGAA8C;AAC9F;AACA;AACA;AACA;AACA;AACA,2CAA2C,8DAAwB;AACnE;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA,kBAAkB,uEAAoB;AACtC;AACA,cAAc,+CAAa;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;;AC1GA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACZ;AAC/B;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iEAAoB;AAChE,sBAAsB,2DAAc;AACpC;AACA;AACA,4CAA4C,iEAAoB;AAChE;AACA;AACA,0CAA0C,2DAAc;AACxD;AACA;AACA;AACA,0CAA0C,2DAAc;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC1CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsE;AACR;AAC/C;AACf;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAAY;AAC3C,2BAA2B,kFAAkB;AAC7C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACtBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmF;AACjC;AACnC;AACf;AACA,kCAAkC,+FAA4B;AAC9D;AACA;AACA,kCAAkC,6DAAgB;AAClD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACrBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACiE;AACkB;AAChB;AACb;AACP;AACe;AACmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAqB;AAC/D;AACA,sCAAsC,6DAAgB;AACtD;AACA;AACA;AACA,0CAA0C,2DAAqB;AAC/D;AACA,sCAAsC,6DAAgB;AACtD;AACA,mCAAmC,8DAAQ;AAC3C,YAAY,6EAAc;AAC1B;AACA;AACA,0CAA0C,2DAAqB;AAC/D;AACA,gDAAgD,+FAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4EAAyB;AACnE;AACA,gBAAgB,+EAAoB,gBAAgB,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/FA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+C;AACe;AAChB;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAqB;AAC3D;AACA,kCAAkC,2DAAc;AAChD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACjCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACH;AACV;AACJ;AACvC;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAqB;AACzD;AACA;AACA,0CAA0C,2DAAY;AACtD;AACA;AACA,kDAAkD,6DAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4EAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC1CuD;AAChD;AACP,QAAQ,4DAAO;AACf,QAAQ,4DAAO;AACf;AACA;;;;;;;;;;;;;;;;;;ACLA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuE;AAC1B;AACtC;AACP;AACA;AACA,4CAA4C,gFAAiB;AAC7D,4BAA4B,sDAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,4CAA4C,gFAAiB;AAC7D,4BAA4B,sDAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;AClCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+E;AACJ;AACE;AAC8K;AACpP;AACP,0GAA0G,8DAAM;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wFAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gIAAgI,8DAAM;AACtI;AACA,wCAAwC,8EAAyB;AACjE;AACA;AACA,sBAAsB,gEAAQ;AAC9B,6BAA6B,0FAAqC;AAClE;AACA;AACA,2BAA2B,8DAAM;AACjC,6BAA6B,gGAA2C;AACxE;AACA;AACA;AACA,6BAA6B,uGAAkD;AAC/E;AACA;AACA;AACA,6BAA6B,oGAA+C;AAC5E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,MAAM;AACzG;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,MAAM;AAC1G;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,MAAM;AAC1G;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,uDAAiB;AACjD;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,cAAc,oDAAc;AAC5B;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACzbA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmG;AACnD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,gEAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,wCAAwC,8EAAyB;AACjE,6BAA6B,oGAA+C;AAC5E,2BAA2B,sFAAiC;AAC5D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,gEAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,wCAAwC,8EAAyB;AACjE,6BAA6B,0FAAqC;AAClE,2BAA2B,iFAA4B;AACvD;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACrD0E;AACnE;AACP;AACA;AACA,qCAAqC,+EAAY;AACjD;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,+EAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,+EAAY;AAC5B;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyD;AACmE;AAC9B;AAChC;AACyB;AAC3C;AACkB;AACF;AACF;AACJ;AACsC;AACpB;AACa;AACrF;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C,4BAA4B,2EAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mGAA8B;AACzE;AACA;AACA,qCAAqC,iFAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD,wCAAwC,0DAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2EAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAAsB;AAC/D;AACA;AACA,yCAAyC,wFAAgC;AACzE;AACA,gCAAgC,6BAA6B;AAC7D;AACA,oDAAoD,qGAA6C;AACjG;AACA;AACA;AACA;AACA,sBAAsB,mGAA6B;AACnD;AACA;AACA;AACA,yCAAyC,mEAAsB;AAC/D;AACA,yCAAyC,wFAAgC;AACzE;AACA,gCAAgC,6BAA6B;AAC7D;AACA,oDAAoD,qGAA6C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAmB;AACxD;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,YAAY,kFAAwB;AACpC;AACA,YAAY,uEAAoB;AAChC;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,YAAY,+EAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qGAAqB;AAC7B,QAAQ,8DAAQ;AAChB;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACrJA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqF;AACT;AACrE;AACP;AACA,6BAA6B,+EAAc;AAC3C;AACA,0BAA0B,4FAAqB;AAC/C;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,QAAQ,+EAAc;AACtB,KAAK;AACL;;;;;;;;;;;;;;;;;AC/BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyE;AACf;AACnD;AACP;AACA;AACA;AACA,oCAAoC,kFAAmB;AACvD;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA,oCAAoC,oDAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mDAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACnDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACwC;AACc;AACtD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iCAAiC;AACjC;AACA,sBAAsB,8DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gDAAc;AAChE,wCAAwC,0BAA0B;AAClE,kCAAkC,gDAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;ACjJA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmE;AACwD;AACW;AAC3E;AAC3D;AACA;AACA;AACO,2CAA2C,oEAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAqB;AACzD;AACA,0BAA0B,+EAAoB;AAC9C;AACA,4CAA4C,8CAAY;AACxD;AACA;AACA,4CAA4C,6BAA6B;AACzE;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAkC;AACxD;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAAQ;AACvC,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,kFAAwB;AAC5E;AACA;AACA;AACA;AACA,oCAAoC,wCAAM;AAC1C,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,wFAA8B;AAClF;AACA;AACA;AACA;AACA,oCAAoC,wCAAM;AAC1C,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,wFAA8B;AAClF;AACA;AACA;AACA;AACA;AACA,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,kFAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO,oFAAoF,0CAAQ;AACnG;AACA;;;;;;;;;;;;;;;;;;;ACpGA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACwF;AAC/F;AACpD,uCAAuC,oEAAkB;AAChE,6BAA6B,0CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4EAAkB;AACjE;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D,gDAAgD,gDAAc;AAC9D;AACA,+BAA+B,0CAAQ;AACvC;AACA,kCAAkC,kFAAwB;AAC1D;AACA,oCAAoC,wCAAM;AAC1C,kCAAkC,wFAA8B;AAChE;AACA,oCAAoC,wCAAM;AAC1C,kCAAkC,wFAA8B;AAChE;AACA;AACA,kCAAkC,kFAAwB;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6CAA6C,0CAAQ;AAC5D;AACA;;;;;;;;;;;;;;;;;;;;ACjEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC2K;AAC/F;AAC0B;AAC3C;AAC3D;AACA;AACA;AACO,gCAAgC,oEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAa;AACjD;AACA,iDAAiD,kEAA4B;AAC7E;AACA;AACA,kDAAkD,+DAAyB;AAC3E;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA,0BAA0B,wEAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA,sCAAsC,mDAAa;AACnD;AACA,mCAAmC,8DAAM;AACzC,+CAA+C,wFAA8B;AAC7E;AACA;AACA,wCAAwC,gEAAQ;AAChD,+CAA+C,kFAAwB;AACvE;AACA;AACA,wCAAwC,kEAAU;AAClD,+CAA+C,2EAAqC;AACpF;AACA;AACA;AACA,+CAA+C,2EAAqC;AACpF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4DAA4D,8DAAM;AACzE;AACA;;;;;;;;;;;;;;;;;ACjGA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoK;AACjH;AACnD,wCAAwC,oDAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAqB;AAC1D;AACA;AACA;AACA,kDAAkD,uDAAiB;AACnE,yCAAyC,uDAAiB;AAC1D;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA,sBAAsB,wEAAkC;AACxD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,2DAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6EAAuC;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;ACpFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+C;AACO;AACK;AACpD,8CAA8C,oEAAkB;AACvE,6CAA6C,8DAAM;AACnD;AACA;AACA,sBAAsB,8DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAqB;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mEAAmE,8DAAM;AAChF;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmC;AACkD;AAClB;AACQ;AACpB;AACsC;AACqB;AAC5B;AACqC;AACrB;AACvB;AACQ;AACuD;AAC1E;AACkB;AACK;AACY;AACX;AACR;AAC3B;AACc;AACK;AACT;AACC;AACuD;AAC9D;AACM;AACG;AACR;AACC;AACwF;AACb;AACpF;AACM;AACkC;AACjD;AAC+B;AAC3B;AACA;AAC2B;AACpB;AACS;AACkF;AACvF;AACU;AACD;AACO;AACkB;AACf;AACI;AACE;AAC+C;AAClD;AACkB;AAC3B;AACQ;AACqG;AACjH;AAC+B;AAChC;AACC;AAC8C;AACzC;AACyC;AAC1C;AACgC;AAChC;AACS;AACA;AACR;AACU;AACI;AACnB;AACa;AACN;AACqD;AAC5C;AACQ;AACT;AACb;AACgB;AAClC;AACF;AACQ;AACM;AACR;AACG;AACK;AACR;AACE;AACU;AACF;AACI;AACoB;AACZ;AACV;AACC;AACT;AACa;AACE;AAC8B;AACZ;AACnC;AACR;AACmB;AACnB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gFAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAO;AACnB,YAAY,6DAAO;AACnB,YAAY,6DAAO;AACnB,YAAY,6DAAO;AACnB,YAAY,gFAAY;AACxB;AACA,YAAY,6DAAO;AACnB;AACA,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B;AACA;AACA,gDAAgD,6DAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8EAAkC;AACpD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0FAAgC;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAkB,6FAA8B;AAChD,gBAAgB,4EAAe;AAC/B,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,kBAAkB,wFAAyB;AAC3C,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;UCnPA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://mftsccs-browser/./src/Api/Create/CreateTheCharacter.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheConceptApi.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheConnectionApi.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheGhostConceptApi.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheTextData.ts","webpack://mftsccs-browser/./src/Api/DeleteTheConcept.ts","webpack://mftsccs-browser/./src/Api/DeleteTheConnection.ts","webpack://mftsccs-browser/./src/Api/Delete/DeleteConceptInBackend.ts","webpack://mftsccs-browser/./src/Api/GetAiData.ts","webpack://mftsccs-browser/./src/Api/GetAllConceptsByType.ts","webpack://mftsccs-browser/./src/Api/GetAllConnectionsOfComposition.ts","webpack://mftsccs-browser/./src/Api/GetAllConnectionsOfCompositionBulk.ts","webpack://mftsccs-browser/./src/Api/GetAllLinkerConnectionsFromTheConcept.ts","webpack://mftsccs-browser/./src/Api/GetAllLinkerConnectionsToTheConcept.ts","webpack://mftsccs-browser/./src/Api/GetCompositionConnectionsBetweenTwoConcepts.ts","webpack://mftsccs-browser/./src/Api/GetConcept.ts","webpack://mftsccs-browser/./src/Api/GetConceptBulk.ts","webpack://mftsccs-browser/./src/Api/GetConceptByCharacterAndType.ts","webpack://mftsccs-browser/./src/Api/GetConceptByCharacterValue.ts","webpack://mftsccs-browser/./src/Api/GetConnection.ts","webpack://mftsccs-browser/./src/Api/GetConnectionBulk.ts","webpack://mftsccs-browser/./src/Api/GetConnectionOfTheConcept.ts","webpack://mftsccs-browser/./src/Api/GetReservedConnectionIds.ts","webpack://mftsccs-browser/./src/Api/GetReservedIds.ts","webpack://mftsccs-browser/./src/Api/Local/GetLocalConceptByCharacterValue.ts","webpack://mftsccs-browser/./src/Api/Login.ts","webpack://mftsccs-browser/./src/Api/MakeTheNameInBackend.ts","webpack://mftsccs-browser/./src/Api/MakeTheTypeConceptApi.ts","webpack://mftsccs-browser/./src/Api/RecursiveSearch.ts","webpack://mftsccs-browser/./src/Api/SearchConcept/GetConceptByCharacterAndCategoryDirect.ts","webpack://mftsccs-browser/./src/Api/Search/Search.ts","webpack://mftsccs-browser/./src/Api/Search/SearchInternalApi.ts","webpack://mftsccs-browser/./src/Api/Search/SearchLinkMultipleApi.ts","webpack://mftsccs-browser/./src/Api/Search/SearchWithLinker.ts","webpack://mftsccs-browser/./src/Api/Search/SearchWithTypeAndLinker.ts","webpack://mftsccs-browser/./src/Api/Session/CreateSession.ts","webpack://mftsccs-browser/./src/Api/Session/CreateSessionVisit.ts","webpack://mftsccs-browser/./src/Api/Signin.ts","webpack://mftsccs-browser/./src/Api/Signup.ts","webpack://mftsccs-browser/./src/Api/Translate/TranslateLocalToReal.ts","webpack://mftsccs-browser/./src/Api/View/ViewInternalDataApi.ts","webpack://mftsccs-browser/./src/Constants/AccessConstants.ts","webpack://mftsccs-browser/./src/Constants/FormatConstants.ts","webpack://mftsccs-browser/./src/DataStructures/BaseUrl.ts","webpack://mftsccs-browser/./src/DataStructures/BinaryCharacterTree.ts","webpack://mftsccs-browser/./src/DataStructures/BinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/BinaryTypeTree.ts","webpack://mftsccs-browser/./src/DataStructures/CharacterRepository.ts","webpack://mftsccs-browser/./src/DataStructures/Composition/Composition.ts","webpack://mftsccs-browser/./src/DataStructures/Composition/CompositionBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/Composition/CompositionNode.ts","webpack://mftsccs-browser/./src/DataStructures/Concept.ts","webpack://mftsccs-browser/./src/DataStructures/ConceptData.ts","webpack://mftsccs-browser/./src/DataStructures/Connection.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionNode.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionOfNode.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionOfTheTree.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionTypeTree.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/NodePrimitive.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionData.ts","webpack://mftsccs-browser/./src/DataStructures/FilterSearch.ts","webpack://mftsccs-browser/./src/DataStructures/IdentifierFlags.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LConcept.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LConnection.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LNode.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalBinaryCharacterTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalBinaryTypeTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalConceptData.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalConnectionData.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalGhostIdTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalId.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalSyncData.ts","webpack://mftsccs-browser/./src/DataStructures/Node.ts","webpack://mftsccs-browser/./src/DataStructures/PatcherStructure.ts","webpack://mftsccs-browser/./src/DataStructures/ReservedIds.ts","webpack://mftsccs-browser/./src/DataStructures/Responses/ErrorResponse.ts","webpack://mftsccs-browser/./src/DataStructures/Returner.ts","webpack://mftsccs-browser/./src/DataStructures/SearchQuery.ts","webpack://mftsccs-browser/./src/DataStructures/Search/SearchStructure.ts","webpack://mftsccs-browser/./src/DataStructures/Security/TokenStorage.ts","webpack://mftsccs-browser/./src/DataStructures/Session/SessionData.ts","webpack://mftsccs-browser/./src/DataStructures/SettingData.ts","webpack://mftsccs-browser/./src/DataStructures/Settings.ts","webpack://mftsccs-browser/./src/DataStructures/SyncData.ts","webpack://mftsccs-browser/./src/DataStructures/TheCharacter.ts","webpack://mftsccs-browser/./src/DataStructures/TheTexts.ts","webpack://mftsccs-browser/./src/DataStructures/TypeNode.ts","webpack://mftsccs-browser/./src/DataStructures/User/UserBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/User/UserNode.ts","webpack://mftsccs-browser/./src/Database/NoIndexDb.ts","webpack://mftsccs-browser/./src/Database/indexdblocal.ts","webpack://mftsccs-browser/./src/Database/indexeddb.ts","webpack://mftsccs-browser/./src/Helpers/CheckIfExists.ts","webpack://mftsccs-browser/./src/Helpers/RemoveFromArray.ts","webpack://mftsccs-browser/./src/Helpers/UniqueInsert.ts","webpack://mftsccs-browser/./src/Services/CheckForConnectionDeletion.ts","webpack://mftsccs-browser/./src/Services/Common/DelayFunction.ts","webpack://mftsccs-browser/./src/Services/Common/ErrorPosting.ts","webpack://mftsccs-browser/./src/Services/Composition/BuildComposition.ts","webpack://mftsccs-browser/./src/Services/Composition/CompositionCache.ts","webpack://mftsccs-browser/./src/Services/Composition/CreateCompositionCache.ts","webpack://mftsccs-browser/./src/Services/ConceptFinding/GetConceptByCharacterAndCategory.ts","webpack://mftsccs-browser/./src/Services/Conversion/ConvertConcepts.ts","webpack://mftsccs-browser/./src/Services/CreateBinaryTreeFromData.ts","webpack://mftsccs-browser/./src/Services/CreateConnectionBetweenTwoConcepts.ts","webpack://mftsccs-browser/./src/Services/CreateDefaultConcept.ts","webpack://mftsccs-browser/./src/Services/CreateTheComposition.ts","webpack://mftsccs-browser/./src/Services/CreateTheConcept.ts","webpack://mftsccs-browser/./src/Services/CreateTheConnection.ts","webpack://mftsccs-browser/./src/Services/CreateTheConnectionGeneral.ts","webpack://mftsccs-browser/./src/Services/DeleteConcept.ts","webpack://mftsccs-browser/./src/Services/DeleteConnection.ts","webpack://mftsccs-browser/./src/Services/FindConeceptsFromConnection.ts","webpack://mftsccs-browser/./src/Services/FindConnectionsOfCompositionBulkInMemory.ts","webpack://mftsccs-browser/./src/Services/GetComposition.ts","webpack://mftsccs-browser/./src/Services/GetCompositionBulk.ts","webpack://mftsccs-browser/./src/Services/GetCompositionList.ts","webpack://mftsccs-browser/./src/Services/GetConceptByCharacter.ts","webpack://mftsccs-browser/./src/Services/GetConnectionBetweenTwoConceptsLinker.ts","webpack://mftsccs-browser/./src/Services/GetConnections.ts","webpack://mftsccs-browser/./src/Services/GetDataFromIndexDb.ts","webpack://mftsccs-browser/./src/Services/GetLink.ts","webpack://mftsccs-browser/./src/Services/GetLinkerConnectionFromConcept.ts","webpack://mftsccs-browser/./src/Services/GetRelation.ts","webpack://mftsccs-browser/./src/Services/GetTheConcept.ts","webpack://mftsccs-browser/./src/Services/InitializeSystem.ts","webpack://mftsccs-browser/./src/Services/Local/ConvertFromLConnectionToConnection.ts","webpack://mftsccs-browser/./src/Services/Local/CreateConnectionBetweenTwoConceptsLocal.ts","webpack://mftsccs-browser/./src/Services/Local/CreateDefaultLConcept.ts","webpack://mftsccs-browser/./src/Services/Local/CreateLocalBinaryTreeFromData.ts","webpack://mftsccs-browser/./src/Services/Local/CreateTheCompositionLocal.ts","webpack://mftsccs-browser/./src/Services/Local/CreateTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/CreateTheConnectionLocal.ts","webpack://mftsccs-browser/./src/Services/Local/DeleteConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetCompositionListLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetCompositionLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetConceptByCharacterLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetConnectionOfTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetRelationLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/MakeTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/MakeTheInstanceConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/MakeTheTypeLocal.ts","webpack://mftsccs-browser/./src/Services/Local/UpdateCompositionLocal.ts","webpack://mftsccs-browser/./src/Services/MakeTheCharacter.ts","webpack://mftsccs-browser/./src/Services/MakeTheCharacterData.ts","webpack://mftsccs-browser/./src/Services/MakeTheConcept.ts","webpack://mftsccs-browser/./src/Services/MakeTheInstanceConcept.ts","webpack://mftsccs-browser/./src/Services/MakeTheTimestamp.ts","webpack://mftsccs-browser/./src/Services/MakeTheTypeConcept.ts","webpack://mftsccs-browser/./src/Services/Mqtt/publishMessage.ts","webpack://mftsccs-browser/./src/Services/Search/SearchLinkInternal.ts","webpack://mftsccs-browser/./src/Services/Search/SearchLinkMultiple.ts","webpack://mftsccs-browser/./src/Services/Search/SearchWithTypeAndLinker.ts","webpack://mftsccs-browser/./src/Services/Security/GetRequestHeader.ts","webpack://mftsccs-browser/./src/Services/SplitStrings.ts","webpack://mftsccs-browser/./src/Services/UpdateComposition.ts","webpack://mftsccs-browser/./src/Services/User/UserTranslation.ts","webpack://mftsccs-browser/./src/Services/View/ViewInternalData.ts","webpack://mftsccs-browser/./src/WrapperFunctions/DepenedencyObserver.ts","webpack://mftsccs-browser/./src/WrapperFunctions/GetCompositionListObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/GetCompositionObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/GetLinkObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/RecursiveSearchObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/SearchLinkMultipleAllObservable.ts","webpack://mftsccs-browser/./src/app.ts","webpack://mftsccs-browser/webpack/bootstrap","webpack://mftsccs-browser/webpack/runtime/define property getters","webpack://mftsccs-browser/webpack/runtime/hasOwnProperty shorthand","webpack://mftsccs-browser/webpack/runtime/make namespace object","webpack://mftsccs-browser/webpack/before-startup","webpack://mftsccs-browser/webpack/startup","webpack://mftsccs-browser/webpack/after-startup"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CharacterRepository } from \"../../DataStructures/CharacterRepository\";\nimport { Returner } from \"../../DataStructures/Returner\";\nimport { TheCharacter } from \"../../DataStructures/TheCharacter\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheCharacter(characterData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var characterData;\n        try {\n            characterData = CharacterRepository.GetCharacter(characterData.data);\n            if (characterData.id == 0) {\n                var header = GetRequestHeader();\n                const response = yield fetch(BaseUrl.CreateTheCharacterDataUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: JSON.stringify(characterData),\n                });\n                if (!response.ok) {\n                    HandleHttpError(response);\n                    throw new Error(`Error! status: ${response.status}`);\n                }\n                const resultString = yield response.json();\n                const result = resultString;\n                var savingCharacter = new TheCharacter(result.userId, characterData.data, 0, 0, 4, 4, 999, 999, \"\", false);\n                savingCharacter.id = result.id;\n                CharacterRepository.AddCharacter(savingCharacter);\n                return result;\n            }\n            else {\n                var returningData = new Returner(characterData.id, characterData.userId, 0, false);\n                return returningData;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('create the character error message: ', error.message);\n            }\n            else {\n                console.log('create the character unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheConceptApi(conceptData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultConcept();\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.CreateTheConceptUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(conceptData),\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const resultString = yield response.json();\n            result = resultString;\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Create the concept api error message: ', error.message);\n            }\n            else {\n                console.log('Create the concept api unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.CreateTheConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Connection } from \"../../DataStructures/Connection\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheConnectionApi(connectionData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = new Connection(0, 0, 0, 0, 0, 0, 0);\n        try {\n            var header = GetRequestHeader();\n            var jsonData = JSON.stringify(connectionData);\n            const response = yield fetch(BaseUrl.CreateTheConnectionUrl(), {\n                method: 'POST',\n                headers: header,\n                body: jsonData\n            });\n            if (response.ok) {\n                const result = yield response.json();\n            }\n            else {\n                console.log('Create the connection error message: ', response.status);\n                HandleHttpError(response);\n            }\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Create the connection error message: ', error.message);\n            }\n            else {\n                console.log(' Create the connection unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { TokenStorage } from \"../../DataStructures/Security/TokenStorage\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheGhostConceptApi(conceptData, connectionData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = {\n            \"concepts\": [],\n            \"connections\": []\n        };\n        try {\n            const myHeaders = new Headers();\n            let myBody = {\n                \"concepts\": conceptData,\n                \"connections\": connectionData\n            };\n            myHeaders.set(\"Content-Type\", \"application/json\");\n            myHeaders.set('Authorization', \"Bearer \" + TokenStorage.BearerAccessToken);\n            myHeaders.set('Accept', 'application/json');\n            myHeaders.set('Randomizer', BaseUrl.BASE_RANDOMIZER.toString());\n            const response = yield fetch(BaseUrl.CreateGhostConceptApiUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: JSON.stringify(myBody),\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const resultString = yield response.json();\n            result.concepts = resultString.concepts;\n            result.connections = resultString.connections;\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Create the concept api error message: ', error.message);\n            }\n            else {\n                console.log('Create the concept api unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTextData(textData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.CreateTheTextDataUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(textData),\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const resultString = yield response.json();\n            const result = resultString;\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Create the text error message: ', error.message);\n            }\n            else {\n                console.log('Create the text unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetOnlyTokenHeader } from \"../Services/Security/GetRequestHeader\";\nexport default function DeleteTheConcept(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const formdata = new FormData();\n            formdata.append(\"id\", id.toString());\n            let header = GetOnlyTokenHeader();\n            const response = yield fetch(BaseUrl.DeleteConceptUrl(), {\n                method: 'POST',\n                headers: header,\n                body: formdata\n            });\n            if (!response.ok) {\n                // throw new Error(`Error! status: ${response.status}`);\n                console.log(\"Delete concept error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Delete concept error message: ', error.message);\n            }\n            else {\n                console.log('Delete concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.DeleteConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetOnlyTokenHeader } from \"../Services/Security/GetRequestHeader\";\nexport default function DeleteTheConnection(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const formdata = new FormData();\n            formdata.append(\"id\", id.toString());\n            let header = GetOnlyTokenHeader();\n            const response = yield fetch(BaseUrl.DeleteTheConnectionUrl(), {\n                method: 'POST',\n                headers: header,\n                body: formdata,\n                redirect: \"follow\"\n            });\n            if (!response.ok) {\n                console.log('Delete connection error status: ', response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Delete connection error message: ', error.message);\n            }\n            else {\n                console.log('Delete connection unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.DeleteTheConnectionUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function TrashTheConcept(id, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const myHeaders = new Headers();\n            myHeaders.append('Authorization', 'Bearer ' + token);\n            const formdata = new FormData();\n            formdata.append('id', id.toString());\n            const response = yield fetch(BaseUrl.DeleteConceptUrl(), {\n                method: 'POST',\n                body: formdata,\n                headers: myHeaders,\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Delete composition Error! status: ${response.status}`);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Delete composition error message: ', error.message);\n            }\n            else {\n                console.log('Delete composition unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.DeleteConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from '../DataStructures/BaseUrl';\nimport { ConceptsData } from '../DataStructures/ConceptData';\nimport { HandleHttpError, HandleInternalError } from '../Services/Common/ErrorPosting';\nimport { PurgatoryDatabaseUpdated } from '../Services/InitializeSystem';\nimport { GetRequestHeaderWithAuthorization } from '../Services/Security/GetRequestHeader';\nexport function GetAiData() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const start = new Date().getTime();\n            var header = GetRequestHeaderWithAuthorization('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllAiData(), {\n                method: 'GET',\n                headers: header,\n            });\n            if (!response.ok) {\n                console.log('Ai Error Message: ', \"Cannot get response\");\n                HandleHttpError(response);\n            }\n            const result = yield response.json();\n            for (var i = 0; i < result.length; i++) {\n                ConceptsData.AddConcept(result[i]);\n            }\n            PurgatoryDatabaseUpdated();\n            let elapsed = new Date().getTime() - start;\n            console.log(\"The time taken is \", elapsed);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Ai Error Message: ', error.message);\n            }\n            else {\n                console.log('Ai Error Message: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllAiData());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetAllConceptsByType(type, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var urlencoded = new URLSearchParams();\n            urlencoded.append(\"type\", type);\n            urlencoded.append(\"user_id\", userId.toString());\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllConceptsByTypeUrl(), {\n                method: 'POST',\n                headers: header,\n                body: urlencoded\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    ConceptsData.AddConcept(result[i]);\n                }\n            }\n            else {\n                console.log(\"GetAllConceptsByType error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('GetAllConceptsByType error message: ', error.message);\n            }\n            else {\n                console.log('GetAllConceptsByType unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConceptsByTypeUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from '../DataStructures/ConnectionData';\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { CheckForConnectionDeletion } from '../Services/CheckForConnectionDeletion';\nimport { GetRequestHeader } from '../Services/Security/GetRequestHeader';\nimport { HandleHttpError, HandleInternalError } from '../Services/Common/ErrorPosting';\nexport function GetAllConnectionsOfComposition(composition_id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connectionList = [];\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(composition_id);\n        connectionList = yield ConnectionData.GetConnectionsOfConcept(composition_id);\n        if (connectionList.length == 0) {\n            var connectionListString = yield GetAllConnectionsOfCompositionOnline(composition_id);\n            connectionList = connectionListString;\n        }\n        else {\n            var newConnectionsString = yield GetAllConnectionsOfCompositionOnline(composition_id);\n            var newConnections = newConnectionsString;\n            CheckForConnectionDeletion(newConnections, connectionList);\n            connectionList = newConnections;\n        }\n        return connectionList;\n    });\n}\nexport function GetAllConnectionsOfCompositionOnline(composition_id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connectionList = [];\n        try {\n            var header = GetRequestHeader('application/json');\n            const myHeaders = new Headers();\n            const formdata = new FormData();\n            formdata.append(\"composition_id\", composition_id.toString());\n            const response = yield fetch(BaseUrl.GetAllConnectionsOfCompositionUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: formdata\n            });\n            console.log(\"this is getting connection from online\", BaseUrl.GetAllConnectionsOfCompositionUrl(), composition_id);\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const result = yield response.json();\n            for (var i = 0; i < result.length; i++) {\n                ConnectionData.AddConnection(result[i]);\n                connectionList.push(result[i]);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all connection of composition error : ', error.message);\n            }\n            else {\n                console.log('Get all connection of composition error : ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConnectionsOfCompositionUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from '../DataStructures/ConnectionData';\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { FindConceptsFromConnections } from '../Services/FindConeceptsFromConnection';\nimport { FindConnectionsOfCompositionsBulkInMemory } from '../Services/FindConnectionsOfCompositionBulkInMemory';\nimport { CheckForConnectionDeletion } from '../Services/CheckForConnectionDeletion';\nimport { GetRequestHeader } from '../Services/Security/GetRequestHeader';\nimport { HandleHttpError, HandleInternalError } from '../Services/Common/ErrorPosting';\nexport function GetAllConnectionsOfCompositionBulk() {\n    return __awaiter(this, arguments, void 0, function* (composition_ids = []) {\n        var connectionList = [];\n        var conceptList = [];\n        if (composition_ids.length <= 0) {\n            return connectionList;\n        }\n        var oldConnectionList = yield FindConnectionsOfCompositionsBulkInMemory(composition_ids);\n        var connectionListString = yield GetAllConnectionsOfCompositionOnline(composition_ids);\n        connectionList = connectionListString;\n        CheckForConnectionDeletion(connectionList, oldConnectionList);\n        yield FindConceptsFromConnections(connectionList);\n        return connectionList;\n    });\n}\nexport function GetAllConnectionsOfCompositionOnline() {\n    return __awaiter(this, arguments, void 0, function* (composition_ids = []) {\n        var connectionList = [];\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.GetAllConnectionsOfCompositionBulkUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(composition_ids)\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    ConnectionData.AddConnection(result[i]);\n                    connectionList.push(result[i]);\n                }\n            }\n            else {\n                console.log('Get all connections of composition bulk error message: ', \"Cannot get response\");\n                HandleHttpError(response);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all connections of composition bulk error message: ', error.message);\n            }\n            else {\n                console.log('Get all connections of composition bulk unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConnectionsOfCompositionBulkUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../app\";\nexport function GetAllLinkerConnectionsFromTheConcept(conceptId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connections = [];\n        try {\n            const start = new Date().getTime();\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllLinkerConnectionOfConceptUrl() + `?conceptId=${conceptId}`, {\n                method: 'GET',\n                headers: header,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    var connection = result[i];\n                    connections.push(connection);\n                }\n            }\n            else {\n                console.log(\"Get all linker connection from the concepts error\", \"cannot get respone\");\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all linker connection from the concepts error: ', error.message);\n            }\n            else {\n                console.log('Get all linker connection from the concepts error(Unexpected): ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllLinkerConnectionOfConceptUrl());\n        }\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../app\";\nexport function GetAllLinkerConnectionsToTheConcept(conceptId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connections = [];\n        try {\n            const start = new Date().getTime();\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllLinkerConnectionToConceptUrl() + `?conceptId=${conceptId}`, {\n                method: 'GET',\n                headers: header,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    var connection = result[i];\n                    connections.push(connection);\n                }\n            }\n            else {\n                console.log(\"Get all linker connection To the concepts error\", \"cannot get respone\");\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all linker connection To the concepts error: ', error.message);\n            }\n            else {\n                console.log('Get all linker connection To the concepts error(Unexpected): ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllLinkerConnectionToConceptUrl());\n        }\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetCompositionConnectionsBetweenTwoConcepts(ofConceptId, toConcept, mainKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connectionList = [];\n        try {\n            var formdata = new FormData();\n            formdata.append(\"ofConceptId\", ofConceptId.toString());\n            formdata.append(\"mainKey\", mainKey.toString());\n            formdata.append(\"toConceptId\", toConcept.toString());\n            const response = yield fetch(BaseUrl.GetCompositionConnectionBetweenTwoConceptsUrl(), {\n                method: 'POST',\n                body: formdata,\n                redirect: \"follow\"\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    ConnectionData.AddConnection(result[i]);\n                    connectionList.push(result[i]);\n                }\n            }\n            else {\n                console.log(\"Get composition connection between two concepts\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get composition connection between two concepts error message: ', error.message);\n            }\n            else {\n                console.log('Get composition connection between two concepts unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetCompositionConnectionBetweenTwoConceptsUrl());\n        }\n        return connectionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept } from \"../app\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\n/**\n * This function helps you get concept from the id. This can only be positive.\n * @param id The id that you want to get the concept of\n * @returns\n */\nexport function GetConcept(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = CreateDefaultConcept();\n            var conceptUse = yield ConceptsData.GetConcept(id);\n            let isNpc = ConceptsData.GetNpc(id);\n            if (conceptUse.id != 0 || isNpc) {\n                return conceptUse;\n            }\n            else {\n                var header = GetRequestHeader();\n                console.log(\"this is the url\", BaseUrl.GetConceptUrl());\n                const formdata = new FormData();\n                formdata.append(\"id\", id.toString());\n                const response = yield fetch(BaseUrl.GetConceptUrl(), {\n                    method: 'POST',\n                    body: formdata\n                });\n                if (response.ok) {\n                    result = (yield response.json());\n                    if (result.id > 0) {\n                        ConceptsData.AddConcept(result);\n                    }\n                    else {\n                        ConceptsData.AddNpc(id);\n                    }\n                }\n                else {\n                    console.log(\"Get the concept error\", response.status);\n                    HandleHttpError(response);\n                }\n                return result;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get the concept error message: ', error.message);\n            }\n            else {\n                console.log('Get the concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\n/**\n * This function takes in a list of ids and returns a list of concepts . This uses local memory to find concepts\n * namely in the concept binary tree. If it could not find the concepts in local memory then it fetches those from\n * the api. The fetched concepts from api are then stored in the memory for further use in future.\n * @param conceptIds list of concept ids that need to be fetched\n * @returns list of concepts\n */\nexport function GetConceptBulk(passedConcepts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = [];\n        let setTime = new Date().getTime();\n        // let conceptIds = passedConcepts.filter((value, index, self) => {\n        //   return self.indexOf(value) === index;\n        // });\n        let conceptIds = Array.from(new Set(passedConcepts));\n        try {\n            if (conceptIds.length > 0) {\n                let bulkConceptFetch = [];\n                for (let i = 0; i < conceptIds.length; i++) {\n                    let conceptUse = yield ConceptsData.GetConcept(conceptIds[i]);\n                    if (conceptUse.id == 0) {\n                        bulkConceptFetch.push(conceptIds[i]);\n                    }\n                }\n                // let newAlgoTime = new Date().getTime();\n                //let remainingIds:any = {};\n                // for(let i=0; i< conceptIds.length; i++){\n                //     remainingIds[conceptIds[i]] = false;\n                // }\n                //await ConceptsData.GetConceptBulkData(conceptIds, result, remainingIds );\n                // for(let key in remainingIds){\n                //     if(remainingIds[key] == false){\n                //       bulkConceptFetch.push(Number(key));\n                //     }\n                // }\n                //bulkConceptFetch = conceptIds;\n                if (bulkConceptFetch.length == 0) {\n                    return result;\n                }\n                else {\n                    let header = GetRequestHeader();\n                    const response = yield fetch(BaseUrl.GetConceptBulkUrl(), {\n                        method: 'POST',\n                        headers: header,\n                        body: JSON.stringify(bulkConceptFetch)\n                    });\n                    if (response.ok) {\n                        result = yield response.json();\n                        console.log(\"got all the concepts\", result);\n                        if (result.length > 0) {\n                            for (let i = 0; i < result.length; i++) {\n                                let concept = result[i];\n                                ConceptsData.AddConcept(concept);\n                            }\n                        }\n                        console.log(\"added the concepts\");\n                    }\n                    else {\n                        console.log(\"Get Concept Bulk error\", response.status);\n                        HandleHttpError(response);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get Concept Bulk  error message: ', error.message);\n            }\n            else {\n                console.log('Get Concept Bulk  unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptBulkUrl());\n        }\n        return result;\n    });\n}\nexport function BulkConceptGetterApi(bulkConceptFetch) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const conceptList = [];\n        if (bulkConceptFetch.length > 0) {\n            const myHeaders = {\n                'Content-Type': 'application/json',\n            };\n            try {\n                const response = yield fetch(BaseUrl.GetConceptBulkUrl(), {\n                    method: 'POST',\n                    headers: myHeaders,\n                    body: JSON.stringify(bulkConceptFetch),\n                });\n                if (response.ok) {\n                    const result = yield response.json();\n                    if (result.length > 0) {\n                        for (let i = 0; i < result.length; i++) {\n                            const concept = result[i];\n                            conceptList.push(concept);\n                            ConceptsData.AddConcept(concept);\n                        }\n                    }\n                }\n                else {\n                    console.log('bulk concept getter api error: ', response.status);\n                    HandleHttpError(response);\n                }\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    console.log('bulk concept getter api error: ', error.message);\n                }\n                else {\n                    console.log('bulk concept getter api error: ', error);\n                }\n                HandleInternalError(error, BaseUrl.GetConceptBulkUrl());\n            }\n        }\n        return conceptList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetConceptByCharacterAndType(characterValue, typeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield ConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, typeId);\n        try {\n            if (concept == null || concept.id == 0) {\n                var json = {\n                    'character_value': `${characterValue}`,\n                    'type_id': typeId\n                };\n                var toSendJson = JSON.stringify(json);\n                var header = GetRequestHeader();\n                const response = yield fetch(BaseUrl.GetConceptByCharacterAndTypeUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: toSendJson,\n                });\n                if (response.ok) {\n                    let conceptString = yield response.json();\n                    concept = conceptString;\n                    ConceptsData.AddConcept(concept);\n                }\n                else {\n                    //  throw new Error(`Error! status: ${response.status}`);\n                    HandleHttpError(response);\n                    console.log(\"This is the concept by type and character error\", response.status);\n                }\n            }\n            return concept;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(' This is the concept by type and character error message: ', error.message);\n            }\n            else {\n                console.log(' This is the concept by type and character unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptByCharacterAndTypeUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { CreateDefaultConcept } from \"../app\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetConceptByCharacterValue(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultConcept();\n        try {\n            const formdata = new FormData();\n            formdata.append(\"character_value\", characterValue);\n            const response = yield fetch(BaseUrl.GetConceptByCharacterValueUrl(), {\n                method: 'POST',\n                body: formdata\n            });\n            if (response.ok) {\n                result = (yield response.json());\n                if (result.id > 0) {\n                    ConceptsData.AddConcept(result);\n                }\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"Error in Getting concept by character value Error\", response.status);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Error in Getting concept by character value error message: ', error);\n            }\n            else {\n                console.log('Error in Getting concept by character value unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptByCharacterValueUrl());\n        }\n        return result;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetConnection(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = yield ConnectionData.GetConnection(id);\n        try {\n            if (result.id != 0) {\n                return result;\n            }\n            else {\n                let header = GetRequestHeader('application/x-www-form-urlencoded');\n                const formdata = new FormData();\n                formdata.append(\"id\", id.toString());\n                const response = yield fetch(BaseUrl.GetConnectionUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: formdata\n                });\n                if (response.ok) {\n                    result = (yield response.json());\n                    ConnectionData.AddConnection(result);\n                }\n                else {\n                    HandleHttpError(response);\n                    console.log(\"Get Connection Error\", response.status);\n                }\n                return result;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get Connection error message: ', error.message);\n            }\n            else {\n                console.log('Get Connection unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConnectionUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"./../DataStructures/ConnectionData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { FindConceptsFromConnections } from \"../Services/FindConeceptsFromConnection\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\n/**\n * After fetching these connections it is saved in the local static ConnectionBinaryTree so it can be reused without being fetched\n * @param connectionIds array of connection ids that need to fetched by the local system\n * @returns the list of  connections that have been fetched\n */\nexport function GetConnectionBulk() {\n    return __awaiter(this, arguments, void 0, function* (connectionIds = []) {\n        let connectionList = [];\n        try {\n            if (connectionIds.length > 0) {\n                let bulkConnectionFetch = [];\n                // if the connections are already present in the local memory then take it from there \n                //else put it in a list called bulkConnectionFetch which will be used to call and api.\n                for (let i = 0; i < connectionIds.length; i++) {\n                    let conceptUse = yield ConnectionData.GetConnection(connectionIds[i]);\n                    if (conceptUse.id == 0) {\n                        bulkConnectionFetch.push(connectionIds[i]);\n                    }\n                    else {\n                        connectionList.push(conceptUse);\n                    }\n                }\n                // let remainingIds:any = {};\n                // await ConnectionData.GetConnectionBulkData(connectionIds, connectionList, remainingIds );\n                //bulkConnectionFetch = connectionIds;\n                // if the case that bulkConnectionFetch does not have any elements then we just return everything we have\n                if (bulkConnectionFetch.length == 0) {\n                    return connectionList;\n                }\n                else {\n                    // if the connection could not be found in the local memory then fetch from the api.\n                    let header = GetRequestHeader();\n                    const response = yield fetch(BaseUrl.GetConnectionBulkUrl(), {\n                        method: 'POST',\n                        headers: header,\n                        body: JSON.stringify(bulkConnectionFetch)\n                    });\n                    if (response.ok) {\n                        const result = yield response.json();\n                        if (result.length > 0) {\n                            for (let i = 0; i < result.length; i++) {\n                                let connection = result[i];\n                                connectionList.push(connection);\n                                ConnectionData.AddConnection(connection);\n                            }\n                        }\n                    }\n                    else {\n                        HandleHttpError(response);\n                        console.log(\"Get Connection Bulk error\", response.status);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get Connection Bulk error message: ', error);\n            }\n            else {\n                console.log('Get Connection Bulk unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConnectionBulkUrl());\n        }\n        yield FindConceptsFromConnections(connectionList);\n        return connectionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetConnectionOfTheConcept(typeId_1, ofTheConceptId_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (typeId, ofTheConceptId, userId, inpage = 10, page = 1) {\n        let connectionList = [];\n        try {\n            let urlencoded = new URLSearchParams();\n            urlencoded.append(\"typeId\", `${typeId}`);\n            urlencoded.append(\"ofTheConceptId\", `${ofTheConceptId}`);\n            urlencoded.append(\"userId\", `${userId}`);\n            urlencoded.append(\"inpage\", `${inpage}`);\n            urlencoded.append(\"page\", `${page}`);\n            let header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllConnectionsOfConceptUrl(), {\n                method: 'POST',\n                headers: header,\n                body: urlencoded\n            });\n            if (response.ok) {\n                connectionList = (yield response.json());\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"Get connection of concept error\", response.status);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get connection of concept  error message: ', error.message);\n            }\n            else {\n                console.log('Get connection of concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConnectionsOfConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ReservedConnectionIds } from \"../DataStructures/ReservedIds\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetReservedConnectionIds() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetReservedConnectionIdUrl(), {\n                method: 'GET',\n                headers: header,\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const result = yield response.json();\n            for (let i = 0; i < result.length; i++) {\n                ReservedConnectionIds.AddId(result[i]);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('get reserved connection ids error message: ', error.message);\n            }\n            else {\n                console.log('get reserved connection ids  unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetReservedConnectionIdUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ReservedIds } from \"../DataStructures/ReservedIds\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetReservedIds() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetReservedIdUrl(), {\n                method: 'GET',\n                headers: header,\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const result = yield response.json();\n            for (let i = 0; i < result.length; i++) {\n                ReservedIds.AddId(result[i]);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('get reserved ids error message: ', error.message);\n            }\n            else {\n                console.log('get reserved ids  unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetReservedIdUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"./../../DataStructures/Local/LocalConceptData\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { CreateDefaultLConcept } from \"../../app\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function GetLocalConceptByCharacterValue(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultLConcept();\n        try {\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetConceptByCharacterValueUrl(), {\n                method: 'POST',\n                headers: header,\n                body: `character_value=${characterValue}`\n            });\n            if (response.ok) {\n                result = (yield response.json());\n                if (result.id > 0) {\n                    LocalConceptsData.AddConcept(result);\n                }\n            }\n            else {\n                console.log(\"Error in Getting Local concept by character value Error\", response.status);\n                HandleHttpError(response);\n            }\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Error in Getting Local concept by character value error message: ', error);\n            }\n            else {\n                console.log('Error in Getting Local concept by character value unexpected error: ', error);\n            }\n            throw result;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { TokenStorage } from '../DataStructures/Security/TokenStorage';\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function LoginToBackend(email, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let object = {\n                'email': email,\n                'password': password\n            };\n            let myHeaders = new Headers();\n            myHeaders.append(\"Content-Type\", \"application/json\");\n            let requestObject = JSON.stringify(object);\n            const response = yield fetch(BaseUrl.LoginUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: requestObject\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                console.log(result.data);\n                TokenStorage.BearerAccessToken = result.data.token;\n                console.log(\"this is the token\", TokenStorage.BearerAccessToken);\n                return result;\n            }\n            else {\n                console.log('Login tsccs error message: ', response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Login tsccs error message: ', error.message);\n            }\n            else {\n                console.log(' Login tsccs  unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.LoginUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nexport function MakeTheNameInBackend(newConceptId, referent, typeId, typeUserId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let object = {\n                'newConceptId': newConceptId,\n                'referent': referent,\n                'typeId': typeId,\n                'typeUserId': typeUserId\n            };\n            let myHeaders = GetRequestHeader();\n            let requestObject = JSON.stringify(object);\n            const response = yield fetch(BaseUrl.MakeTheNameInBackendUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: requestObject\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('make the name in backend error message: ', error.message);\n            }\n            else {\n                console.log('make the name in backend unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.MakeTheNameInBackendUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nimport { GetConceptByCharacterAndCategory } from \"../Services/ConceptFinding/GetConceptByCharacterAndCategory\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\n/**\n *  This function is used to check the type concpet of a passed string\n *  if the text is \"the_person\" then the function finds the related concept\n * @param type This is the type of the concept that needs to be created.\n * @param userId This is the userId of the creator.\n * @returns the concept created.\n */\nexport function MakeTheTypeConceptApi(type, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // create  a default concept with all defaulting to zero\n        let concept = CreateDefaultConcept();\n        try {\n            // get the concept by character and category from the api\n            concept = yield GetConceptByCharacterAndCategory(type);\n            if (concept.id == 0 || concept.typeId == 4) {\n                let header = GetRequestHeader('application/x-www-form-urlencoded');\n                const response = yield fetch(BaseUrl.MakeTheTypeConceptUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: `type=${type}`\n                });\n                if (!response.ok) {\n                    HandleHttpError(response);\n                    throw new Error(`Error! status: ${response.status}`);\n                }\n                let result = yield response.json();\n                concept = result;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Make The Type Concept Api error : ', error.message);\n            }\n            else {\n                console.log('Make The Type Concept Api error : ', error);\n            }\n            HandleInternalError(error, BaseUrl.MakeTheTypeConceptUrl());\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { SearchQuery } from \"../DataStructures/SearchQuery\";\nimport { GetCompositionFromConnectionsWithDataId } from \"../Services/GetCompositionBulk\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function RecursiveSearchApi() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, listLinkers = [], textSearch = \"\") {\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.listLinkers = listLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: raw\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                concepts = yield GetCompositionFromConnectionsWithDataId(conceptIds, connections);\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('recursive search error message: ', error.message);\n            }\n            else {\n                console.log('recursive search unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n        return concepts;\n    });\n}\nexport function RecursiveSearchApiRaw() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, listLinkers = [], textSearch = \"\") {\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.listLinkers = listLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: raw\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                return result;\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n            return [];\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('recursive search error message: ', error.message);\n            }\n            else {\n                console.log('recursive search unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n    });\n}\nexport function RecursiveSearchApiRawFullLinker() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, fullLinkers = [], textSearch = \"\") {\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.fullLinkers = fullLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: raw\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                return result;\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n            return [];\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('recursive search error message: ', error.message);\n            }\n            else {\n                console.log('recursive search unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n    });\n}\nexport function RecursiveSearchApiNewRawFullLinker() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, fullLinkers = [], textSearch = \"\") {\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.fullLinkers = fullLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: raw\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                return result;\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n            return [];\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('recursive search error message: ', error.message);\n            }\n            else {\n                console.log('recursive search unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n    });\n}\nexport function RecursiveSearchLocal(composition_1) {\n    return __awaiter(this, arguments, void 0, function* (composition, listLinkers = [], textSearch = \"\") {\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function GetConceptByCharacterAndCategoryDirectApi(characterValue, category_id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = CreateDefaultConcept();\n        try {\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetConceptByCharacterAndCategoryDirectUrl(), {\n                method: 'POST',\n                headers: header,\n                body: `character_value=${characterValue}&category_id=${category_id}`,\n            });\n            if (response.ok) {\n                let conceptString = yield response.json();\n                concept = conceptString;\n                ConceptsData.AddConcept(concept);\n            }\n            else {\n                //  throw new Error(`Error! status: ${response.status}`);\n                console.log(\"This is the concept by category and character error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(' This is the concept by category and character error message: ', error.message);\n            }\n            else {\n                console.log(' This is the concept by category and character unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptByCharacterAndCategoryDirectUrl());\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function SearchAllConcepts(type_1, search_1, composition_1, token_1) {\n    return __awaiter(this, arguments, void 0, function* (type, search, composition, token, inpage = 10, page = 1) {\n        var header = GetRequestHeaderWithAuthorization('application/x-www-form-urlencoded', token);\n        var urlencoded = new URLSearchParams();\n        urlencoded.append(\"type\", type);\n        urlencoded.append(\"search\", search);\n        urlencoded.append(\"composition\", composition);\n        urlencoded.append(\"inpage\", inpage.toString());\n        urlencoded.append(\"page\", page.toString());\n        const queryUrl = BaseUrl.SearchCompositionsUrl() + \"?\" + urlencoded.toString();\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'GET',\n                headers: header\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchInternalApi(search_1) {\n    return __awaiter(this, arguments, void 0, function* (search, token = \"\") {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        let queryUrl = BaseUrl.SearchInternalWithAuthenticatedCcsUrl();\n        queryUrl = queryUrl + '?composition=' + search.composition + '&search=' + search.search + '&internalComposition=' + search.internalComposition + '&type=' + search.type + '&inpage=' + search.inpage + '&page=' + search.page;\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'GET',\n                headers: header\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                console.log(\"This is the searching internal error\", response.status);\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching internal error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\nexport function SearchInternalAllApi(search_1) {\n    return __awaiter(this, arguments, void 0, function* (search, token = \"\") {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        let queryUrl = BaseUrl.SearchInternalWithAuthenticatedCcsUrl();\n        queryUrl = queryUrl + '?composition=' + search.composition + '&search=' + search.search + '&internalComposition=' + search.internalComposition + '&type=' + search.type + '&inpage=' + search.inpage + '&page=' + search.page;\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'GET',\n                headers: header\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                console.log(\"This is the searching internal error\", response.status);\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching internal error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchLinkMultipleApi(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        const queryUrl = BaseUrl.SearchLinkMultipleAllApiUrl();\n        const body = JSON.stringify(searchQuery);\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"This is the searching multiple error\", response.status);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching multiple error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchWithLinker(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        const queryUrl = BaseUrl.SearchLinkMultipleAll();\n        const body = JSON.stringify(searchQuery);\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                console.log(\"This is the searching error\", response.status);\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchWithTypeAndLinkerApi(searchStructure_1, searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchStructure, searchQuery, token = \"\") {\n        let queryUrl = BaseUrl.SearchAllTypeWithLinker();\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        queryUrl = queryUrl + '?search=' + searchStructure.search + '&type=' + searchStructure.type + '&inpage=' + searchStructure.inpage + '&page=' + searchStructure.page;\n        const body = JSON.stringify(searchQuery);\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"This is the searching multiple error\", response.status);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching SearchWithTypeAndLinker error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateSession(sessionData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var header = GetRequestHeader();\n            const body = JSON.stringify(sessionData);\n            const response = yield fetch(BaseUrl.CreateSessionId(), {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                return response.json();\n            }\n            else {\n                console.log(\"Creating session failed\", yield response.json());\n                HandleHttpError(response);\n                return null;\n            }\n        }\n        catch (ex) {\n            console.log(\"Creating session failed\", ex);\n            HandleInternalError(ex, BaseUrl.CreateSessionId());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nexport function CreateSessionVisit(sessionId, url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var header = GetRequestHeader(\"application/x-www-form-urlencoded\");\n            const urlencoded = new URLSearchParams();\n            urlencoded.append(\"sessionId\", sessionId.toString());\n            urlencoded.append(\"url\", url);\n            const response = yield fetch(BaseUrl.CreateSessionVisitUrl(), {\n                method: 'POST',\n                headers: header,\n                body: urlencoded\n            });\n            if (response.ok) {\n                return response.json();\n            }\n            else {\n                console.log(\"Creating session url failed\", yield response.json());\n                HandleHttpError(response);\n                return null;\n            }\n        }\n        catch (ex) {\n            console.log(\"Creating session url failed\", ex);\n            HandleInternalError(ex, BaseUrl.CreateSessionVisitUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { BaseUrl } from \"../app\";\nexport default function Signin(signinInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const raw = JSON.stringify({\n            email: signinInfo.email,\n            password: signinInfo.password,\n        });\n        let freeschemaRes = {\n            message: 'success',\n            status: false,\n            statusCode: 200,\n            data: '',\n        };\n        const myHeaders = new Headers();\n        myHeaders.append('Content-Type', 'application/json');\n        const url = BaseUrl.LoginUrl();\n        try {\n            const response = yield fetch(url, {\n                method: 'POST',\n                headers: myHeaders,\n                body: raw,\n                redirect: 'follow',\n            });\n            const output = yield response.json();\n            if (response.ok) {\n                const dataObject = output === null || output === void 0 ? void 0 : output.data;\n                freeschemaRes = {\n                    message: 'success',\n                    status: true,\n                    statusCode: 200,\n                    data: dataObject,\n                };\n            }\n            else {\n                HandleHttpError(response);\n            }\n            return freeschemaRes;\n        }\n        catch (error) {\n            console.log('Sign in api error', error);\n            HandleInternalError(error, url);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { BaseUrl } from \"../app\";\nexport default function Signup(signupModel) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const signupResponse = yield postData(BaseUrl.SignupUrl(), signupModel);\n        return signupResponse;\n    });\n}\nfunction postData() {\n    return __awaiter(this, arguments, void 0, function* (url = '', data = {}) {\n        let freeschemaRes = {\n            message: 'success',\n            status: false,\n            statusCode: 200,\n            data: '',\n        };\n        // Default options are marked with *\n        try {\n            const response = yield fetch(url, {\n                method: 'POST', // *GET, POST, PUT, DELETE, etc.\n                mode: 'cors', // no-cors, *cors, same-origin\n                cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached\n                credentials: 'same-origin', // include, *same-origin, omit\n                headers: {\n                    'Content-Type': 'application/json',\n                    // 'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                redirect: 'follow', // manual, *follow, error\n                referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n                body: JSON.stringify(data), // body data type must match \"Content-Type\" header\n            });\n            const output = yield response.json();\n            if (response.ok) {\n                freeschemaRes = {\n                    message: 'success',\n                    status: true,\n                    statusCode: 200,\n                    data: output,\n                };\n            }\n            else {\n                HandleHttpError(response);\n            }\n            return freeschemaRes;\n        }\n        catch (error) {\n            console.log('Signup Error: ', error);\n            HandleInternalError(error, url);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nimport { ConceptsData, CreateDefaultConcept } from \"../../app\";\nexport function TranslateLocalToReal(conceptId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultConcept();\n        try {\n            var header = GetRequestHeaderWithAuthorization('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetRealConceptById(), {\n                method: 'POST',\n                headers: header,\n                body: `id=${conceptId}`\n            });\n            if (response.ok) {\n                result = (yield response.json());\n                if (result.id > 0) {\n                    ConceptsData.AddConcept(result);\n                }\n                return result;\n            }\n            else {\n                console.log(\"Error in Getting Translating concept Error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Error in Getting Translating concept error message: ', error);\n            }\n            else {\n                console.log('Error in Getting Translating concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetRealConceptById());\n        }\n        return result;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { GetConceptBulk } from \"../../app\";\nexport function ViewInternalDataApi(ids) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connectionList = [];\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.ViewInternalDataUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(ids)\n            });\n            if (response.ok) {\n                let conceptString = yield response.json();\n                let connectionDictionary = {};\n                for (let i = 0; i < conceptString.length; i++) {\n                    let conceptList = conceptString[i].concepts;\n                    connectionList = conceptString[i].connections;\n                    let id = conceptString[i].id;\n                    GetConceptBulk(conceptList);\n                    connectionDictionary[id] = connectionList;\n                }\n                return connectionDictionary;\n            }\n            else {\n                //  throw new Error(`Error! status: ${response.status}`);\n                console.log(\"View Internal Data error\", response.status);\n                HandleHttpError(response);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(' This is the view internal data error message: ', error.message);\n            }\n            else {\n                console.log(' This is the view internal data unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","export const ADMIN = 3;\nexport const PRIVATE = 4;\nexport const PUBLIC = 5;\n","export const NORMAL = 1;\nexport const DATAID = 2;\nexport const JUSTDATA = 3;\nexport const DATAIDDATE = 4;\nexport const RAW = 5;\n","export class BaseUrl {\n    // static GetConceptUrl:string = this.BASE_URL + '/api/getConcept';\n    static GetConceptUrl() {\n        return this.BASE_URL + '/api/getConcept';\n    }\n    static GetConnectionUrl() {\n        return this.BASE_URL + '/api/get-connection-by-id';\n    }\n    static GetConceptBulkUrl() {\n        return this.BASE_URL + '/api/get_concept_bulk';\n    }\n    static GetConnectionBulkUrl() {\n        return this.BASE_URL + '/api/get_connection_bulk';\n    }\n    static GetAllConceptsOfUserUrl() {\n        return this.BASE_URL + '/api/get_all_concepts_of_user';\n    }\n    static GetAllConnectionsOfUserUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_user';\n    }\n    static GetAllConnectionsOfCompositionUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_composition';\n    }\n    static GetAllConnectionsOfCompositionBulkUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_composition_bulk';\n    }\n    static GetConceptByCharacterValueUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_value';\n    }\n    static GetConceptByCharacterAndTypeUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_and_type';\n    }\n    static GetConceptByCharacterAndCategoryUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_and_category';\n    }\n    static GetConceptByCharacterAndCategoryDirectUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_and_category_direct';\n    }\n    static GetCharacterByCharacterUrl() {\n        return this.BASE_URL + '/api/get_character_by_character';\n    }\n    static GetAllConceptsByTypeUrl() {\n        return this.BASE_URL + '/api/get_all_concepts_by_type';\n    }\n    static GetAllConnectionsOfConceptUrl() {\n        return this.BASE_URL + '/api/get-link-connections';\n    }\n    static GetAllAiData() {\n        return this.BASE_URL + '/api/get-preloaded-concepts';\n        // return this.AI_URL + '/api/get_ranked_type_id?inpage=300' || process.env.AI_URL ||  'https://ai.freeschema.com/api/get_ranked_type_id?inpage=300';\n    }\n    static GetAllPrefetchConnectionsUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_user?inpage=500';\n    }\n    static GetAllLinkerConnectionOfConceptUrl() {\n        return this.BASE_URL + '/api/get-all-linkers-from-concept';\n    }\n    static GetAllLinkerConnectionToConceptUrl() {\n        return this.BASE_URL + '/api/get-all-linkers-to-concept';\n    }\n    static DeleteConceptUrl() {\n        return this.BASE_URL + '/api/delete_concept';\n    }\n    static RecursiveSearchUrl() {\n        return this.BASE_URL + '/api/recursivesearch-concept-connection';\n    }\n    static SearchLinkMultipleAllApiUrl() {\n        return this.BASE_URL + '/api/Connection/search-link-multiple-all-ccs';\n    }\n    static MakeTheNameInBackendUrl() {\n        return this.BASE_URL + '/api/make-name-from-frontend';\n    }\n    static SearchAllTypeWithLinker() {\n        return this.BASE_URL + '/api/search-all-with-linker-ccs';\n    }\n    static LoginUrl() {\n        return this.BASE_URL + '/api/auth/login';\n    }\n    static SignupUrl() {\n        return this.BASE_URL + '/api/auth/signup';\n    }\n    static GetCompositionConnectionBetweenTwoConceptsUrl() {\n        return this.BASE_URL + '/api/get-composition-connection-between-two-concepts';\n    }\n    static SearchCompositionsUrl() {\n        return this.BASE_URL + '/api/search-compositions';\n    }\n    static SearchLinkMultipleAll() {\n        return this.BASE_URL + '/api/Connection/search-link-multiple-all';\n    }\n    static CreateSessionId() {\n        return this.BASE_URL + '/api/create-session-id-remote';\n    }\n    static CreateSessionVisitUrl() {\n        return this.BASE_URL + '/api/create-remote-session-visit';\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    /////////////////////Api for viewing internal data //////////////////////////\n    static ViewInternalDataUrl() {\n        return this.BASE_URL + '/api/view-api-internal-data-ccs-id-bulk';\n    }\n    static SearchInternalWithAuthenticatedCcsUrl() {\n        return this.BASE_URL + '/api/search-composition-internal-authenticated-ccs';\n    }\n    static SearchInternalWithCcsUrl() {\n        return this.BASE_URL + '/api/search-composition-internal-authenticated-ccs';\n    }\n    static CreateGhostConceptApiUrl() {\n        return BaseUrl.NODE_URL + '/api/v1/local-concepts';\n    }\n    static CreateGhostConnectionApiUrl() {\n        return BaseUrl.NODE_URL + '/api/v1/local-connections';\n    }\n    static GetRealConceptById() {\n        return BaseUrl.NODE_URL + '/api/v1/local-concepts-translate';\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    //////////////// API For Reserved Ids ///////////////////////////////////////\n    static GetReservedIdUrl() {\n        return this.BASE_URL + '/api/get_reserved_ids';\n    }\n    static GetReservedConnectionIdUrl() {\n        return this.BASE_URL + '/api/get_reserved_connection_ids';\n    }\n    /////////////////////////////////////////////////////////////////////////////\n    ////////////////API For Creating Data //////////////////////////////////////\n    static CreateTheTextDataUrl() {\n        return this.BASE_URL + '/api/create_text_data';\n    }\n    static CreateTheCharacterDataUrl() {\n        return this.BASE_URL + '/api/create_character_data';\n    }\n    static CreateTheConceptUrl() {\n        return this.BASE_URL + '/api/create_the_concept';\n    }\n    static CreateTheConnectionUrl() {\n        return this.BASE_URL + '/api/create_the_connection';\n    }\n    static CreateTheConnectionNewUrl() {\n        return this.BASE_URL + '/api/create_the_connection_new';\n    }\n    static MakeTheTypeConceptUrl() {\n        return this.BASE_URL + '/api/make_the_type_concept';\n    }\n    ////////////////////////////////////////////////////////////////////////\n    /////////////////////API FOR Deleting Connection //////////////////////\n    static DeleteTheConnectionUrl() {\n        return this.BASE_URL + '/api/delete_connection';\n    }\n}\nBaseUrl.BASE_URL = \"https://localhost:7053/\";\nBaseUrl.AI_URL = \"https://ai.freeschema.com\";\nBaseUrl.MQTT_URL = '192.168.1.249';\nBaseUrl.NODE_URL = \"http://localhost:5001\";\nBaseUrl.BASE_APPLICATION = \"\";\nBaseUrl.BASE_RANDOMIZER = 999;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"./IdentifierFlags\";\nimport { Node } from \"./Node\";\nexport class BinaryCharacterTree {\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isCharacterLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(BinaryCharacterTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addNodeToTree(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.characterRoot == null) {\n                this.characterRoot = node;\n                return this.characterRoot;\n            }\n            else {\n                this.characterRoot = this.characterRoot.addCharacterNode(node, this.characterRoot, this.characterRoot.height);\n            }\n            return this.characterRoot;\n        });\n    }\n    static removeNodeByCharacter(character, id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.characterRoot) {\n                this.characterRoot.removeNodeWithVariants(this.characterRoot, character, id);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.characterRoot) {\n            return this.characterRoot.countNodeBelow(this.characterRoot);\n        }\n        return 0;\n    }\n    static addConceptToTree(concept) {\n        if (concept.characterValue != \"\") {\n            var node = new Node(concept.characterValue, concept, null, null);\n            this.addNodeToTree(node);\n        }\n    }\n    static getNodeFromTree(value) {\n        if (this.characterRoot) {\n            var Node = this.characterRoot.getCharacterFromNode(value, this.characterRoot);\n            return Node;\n        }\n        return this.characterRoot;\n    }\n    static getNodeFromTreeUpdated(value) {\n        if (this.characterRoot) {\n            var Node = this.characterRoot.getCharacterFromNode(value, this.characterRoot);\n            return Node;\n        }\n        return this.characterRoot;\n    }\n    static getCharacterAndTypeFromTree(value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // try{\n            //     var data = await this.waitForDataToLoad();\n            // }\n            // catch(exception){\n            //     return null;\n            // }\n            if (this.characterRoot) {\n                var Node = this.characterRoot.getFromNodeWithCharacterAndType(value, typeId, this.characterRoot);\n                return Node;\n            }\n            return this.characterRoot;\n        });\n    }\n    static getCharacterAndCategoryFromTree(value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // try{\n            //     var data = await this.waitForDataToLoad();\n            // }\n            // catch(exception){\n            //     return null;\n            // }\n            if (this.characterRoot) {\n                var Node = this.characterRoot.getFromNodeWithCharacterAndCategory(value, categoryId, this.characterRoot);\n                return Node;\n            }\n            return this.characterRoot;\n        });\n    }\n    static removeConceptCharacter(id) {\n        if (this.characterRoot) {\n            this.characterRoot = this.characterRoot.removeNode(this.characterRoot, id);\n        }\n    }\n}\nBinaryCharacterTree.characterRoot = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BinaryCharacterTree } from \"./BinaryCharacterTree\";\nimport { Node } from \"./Node\";\nimport { IdentifierFlags } from \"./IdentifierFlags\";\nexport class BinaryTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(BinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addConceptToTree(concept) {\n        let node = new Node(concept.id, concept, null, null);\n        let characterNode = new Node(concept.characterValue, concept, null, null);\n        BinaryCharacterTree.addNodeToTree(characterNode);\n        this.addNodeToTree(node);\n    }\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                let Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                let event = new Event(`${id}`);\n                console.log(\"this is the fired event after delete\", event);\n                dispatchEvent(event);\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n    static getConceptListFromIds(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root.checkIfIdsInNode(this.root, ids, connectionArray, remainingIds);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.root) {\n            return this.root.countNodeBelow(this.root);\n        }\n        return 0;\n    }\n}\nBinaryTree.root = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetTheConcept } from \"../app\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nimport { IdentifierFlags } from \"./IdentifierFlags\";\nimport { TypeNode } from \"./TypeNode\";\nexport class BinaryTypeTree {\n    // old method having concept as the value.\n    // static async addNodeToTree(node:Node){\n    //     if(this.typeRoot == null){\n    //         this.typeRoot = node;\n    //         return this.typeRoot;\n    //     }\n    //     else{\n    //          let event = new CustomEvent(`${node.value.typeId}`, {detail: node.value.id});\n    //         // console.log(\"this is the fired event\", event);\n    //          dispatchEvent(event);\n    //         this.typeRoot = this.typeRoot.addTypeNode(node,this.typeRoot,this.typeRoot.height);\n    //     }\n    //     return this.typeRoot;\n    // }\n    // new method with just ids \n    static addType(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root == null) {\n                this.root = node;\n                return this.root;\n            }\n            else {\n                let event = new CustomEvent(`${node.key}`, { detail: node.value[0] });\n                // console.log(\"this is the fired event\", event);\n                dispatchEvent(event);\n                // console.log(\"this is the fired event\", event);\n                this.root = this.root.addType(this.root, node.key, node.value[0]);\n            }\n            return this.root;\n        });\n    }\n    static addConceptToTree(concept) {\n        if (concept.typeId != 0) {\n            /// old type \n            // var node: Node = new Node(concept.typeId, concept, null, null);\n            // this.addNodeToTree(node);\n            // new functionality\n            let typeNode = new TypeNode(concept.typeId, concept.id);\n            this.addType(typeNode);\n        }\n    }\n    static removeTypeConcept(typeId, id) {\n        // old mehtod\n        // if(this.typeRoot){\n        //     this.typeRoot = this.typeRoot.removeNodeWithVariants(this.typeRoot,typeId,id);\n        // }\n        // new method\n        if (this.root) {\n            this.root = this.root.removeNodeWithVariants(this.root, typeId, id);\n        }\n    }\n    // static getNodeFromTree(id:number){\n    //     // old method\n    //     if(this.typeRoot){\n    //         var Node = this.typeRoot.getFromNode(id, this.typeRoot);\n    //         return Node;\n    //     }\n    //     return this.typeRoot;\n    // }\n    static getNodeFromTreeNew(id) {\n        // new method\n        if (this.root) {\n            let node = this.root.getFromNode(id, this.root);\n            return node;\n        }\n        return this.root;\n    }\n    /// old method\n    // static getTypeVariantsFromTree(typeId:number){\n    //         let Node = this.getNodeFromTree(typeId);\n    //         var concepts : Concept[] = [];\n    //         if(Node){\n    //             concepts.push(Node?.value);\n    //             for(let i=0; i< Node.variants.length; i++){\n    //                 concepts.push(Node.variants[i].value);\n    //             }\n    //         return concepts;\n    //     }\n    // }\n    //new method\n    static getTypeVariantsFromTreeNew(typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let node = this.getNodeFromTreeNew(typeId);\n            let conceptIds = [];\n            let concepts = [];\n            if (node) {\n                conceptIds = node.value;\n                for (let i = 0; i < conceptIds.length; i++) {\n                    concepts.push(yield GetTheConcept(conceptIds[i]));\n                }\n            }\n            return concepts;\n        });\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isTypeLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(BinaryTypeTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    // static async getTypeVariantsFromTreeWithUserId(typeId:number, userId:number){\n    //     var concepts : Concept[] = [];\n    //         var Node = this.getNodeFromTree(typeId);\n    //         if(Node){\n    //             console.log(\"this is the tree to find\", Node.value);\n    //             if(Node.value.userId == userId ){\n    //                 concepts.push(Node?.value);\n    //             }\n    //             for(let i=0; i< Node.variants.length; i++){\n    //                 if(Node.variants[i].value.userId == userId ){\n    //                     var isPresent = false;\n    //                     for(let j=0; j<concepts.length;j++){\n    //                         if(concepts[j].id == Node.variants[i].value.id){\n    //                             isPresent = true;\n    //                         }\n    //                     }\n    //                     if(!isPresent){\n    //                         concepts.push(Node.variants[i].value);\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     return concepts;\n    // }\n    // new method\n    static getTypeVariantsFromTreeWithUserIdNew(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let concepts = [];\n            let allConcepts = yield this.getTypeVariantsFromTreeNew(typeId);\n            console.log(\"these are all the concepts\", allConcepts);\n            for (let i = 0; i < allConcepts.length; i++) {\n                if (allConcepts[i].userId == userId) {\n                    concepts.push(allConcepts[i]);\n                }\n            }\n            return concepts;\n        });\n    }\n    // static async getTypeVariantsWithCharacterValue( characterValue:string,typeId:number,){\n    //     let concept = CreateDefaultConcept();\n    //         var Node = this.getNodeFromTree(typeId);\n    //         if(Node){\n    //             if(Node.value.characterValue == characterValue ){\n    //                 concept = Node.value;\n    //             }\n    //             for(let i=0; i< Node.variants.length; i++){\n    //                 if(Node.variants[i].value.characterValue == characterValue ){\n    //                     concept = Node.variants[i].value;\n    //                 }\n    //             }\n    //         }\n    //     return concept;\n    // }\n    //new method\n    static getTypeVariantsWithCharacterValueNew(characterValue, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let allConcepts = yield this.getTypeVariantsFromTreeNew(typeId);\n            console.log(\"this is all the concepts for character\", allConcepts);\n            let concept = CreateDefaultConcept();\n            for (let i = 0; i < allConcepts.length; i++) {\n                if (allConcepts[i].characterValue == characterValue) {\n                    concept = allConcepts[i];\n                }\n            }\n            return concept;\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.typeRoot) {\n            return this.typeRoot.countNodeBelow(this.typeRoot);\n        }\n        return 0;\n    }\n}\nBinaryTypeTree.typeRoot = null;\nBinaryTypeTree.root = null;\n","import { TheCharacter } from \"./TheCharacter\";\nexport class CharacterRepository {\n    constructor() {\n        this.name = \"character Repository\";\n    }\n    static AddCharacter(character) {\n        this.characterData[character.id] = character;\n    }\n    static GetCharacter(value) {\n        var theCharacter = new TheCharacter(0, \"0\", 0, 0, 0, 0, 0, 0, \"0\", false);\n        for (var i = 0; i < this.characterData.length; i++) {\n            if (this.characterData[i].data == value) {\n                theCharacter = this.characterData[i];\n            }\n        }\n        return theCharacter;\n    }\n}\nCharacterRepository.characterData = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { recursiveFetchNew } from '../../Services/Composition/BuildComposition';\nimport { CreateDefaultConcept } from '../../Services/CreateDefaultConcept';\nimport { publishMessage } from '../../Services/Mqtt/publishMessage';\nexport class Composition {\n    constructor() {\n        // we can build a composition using this class\n        this.id = 0;\n        this.mainConcept = CreateDefaultConcept();\n        this.connections = [];\n        this.concepts = [];\n        this.subcompositions = [];\n        this.cached = {};\n    }\n    updateCache() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.mainConcept.id == 0)\n                for (let i = 0; i < this.concepts.length; i++) {\n                    if (this.concepts[i].id == this.id) {\n                        this.mainConcept = this.concepts[i];\n                    }\n                }\n            let visitedConcepts = [];\n            this.cached = yield recursiveFetchNew(this.id, this.connections, this.concepts, this.subcompositions, visitedConcepts);\n        });\n    }\n    UpdateAcrossDistributedSystem() {\n        var _a;\n        try {\n            if (this.id != 0) {\n                publishMessage('compositionUpdate', (_a = this.id) === null || _a === void 0 ? void 0 : _a.toString());\n            }\n        }\n        catch (ex) {\n            console.log('Error while publishing message', ex);\n        }\n    }\n    isUpdating() {\n        this.UpdateAcrossDistributedSystem();\n    }\n    GetDataCache() {\n        var _a, _b, _c;\n        const returnOutput = {};\n        const mainString = (_c = (_b = (_a = this.mainConcept) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.characterValue) !== null && _c !== void 0 ? _c : '';\n        returnOutput[mainString] = this.cached;\n        const FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = this.id;\n        return FinalReturn;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CompositionNode } from './CompositionNode';\nexport class CompositionBinaryTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static addCompositionToTree(composition) {\n        const node = new CompositionNode(composition.id, composition, null, null);\n        this.addNodeToTree(node);\n    }\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                const Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.root) {\n            return this.root.countNodeBelow(this.root);\n        }\n        return 0;\n    }\n}\n// this is a binary tree to hold compositions in it\nCompositionBinaryTree.root = null;\n","import { CompositionBinaryTree } from './CompositionBinaryTree';\nexport class CompositionNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.expiryTime = new Date(Date.now() + 10 * 60 * 1000);\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    isValid() {\n        const currentTime = new Date(Date.now());\n        if (this.expiryTime < currentTime) {\n            CompositionBinaryTree.removeNodeFromTree(this.key);\n            return false;\n        }\n        return true;\n    }\n    saveToCache(data) {\n        this.value.cached = data;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        const LeftNode = node.leftNode;\n        const RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            this.isValid();\n            node = passedNode;\n            return node;\n        }\n        node.height =\n            1 +\n                Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        const balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        this.isValid();\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            const x = y.leftNode;\n            if (x) {\n                const T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height =\n                    Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height =\n                    Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            const y = x.rightNode;\n            if (y) {\n                const T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode) + 1);\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode) + 1);\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key && node.isValid()) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        if (passedNode.leftNode == null) {\n            const temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            const temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            const immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return (1 +\n            this.countNodeBelow(root.leftNode) +\n            this.countNodeBelow(root.rightNode));\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","import { BaseUrl } from \"../app\";\nexport class Concept {\n    constructor(id, userId, typeId, categoryId, referentId, characterValue, accessId, isNew = false, entryTimeStamp, updatedTimeStamp, typeCharacter) {\n        this.count = 0;\n        this.typeCharacter = \"\";\n        this.isComposition = false;\n        this.isTemp = false;\n        this.isSynced = false;\n        this.applicationId = BaseUrl.BASE_RANDOMIZER;\n        this.x = 0;\n        this.y = 0;\n        this.id = id;\n        this.userId = userId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.categoryId = categoryId;\n        this.referentId = referentId;\n        this.characterValue = `${characterValue}`;\n        this.accessId = accessId;\n        this.typeCharacter = typeCharacter;\n        this.type = null;\n        this.isNew = isNew;\n        this.entryTimeStamp = entryTimeStamp;\n        this.updatedTimeStamp = updatedTimeStamp;\n        // ConceptsData.AddConcept(this);\n    }\n    getType() {\n        console.log(this.typeId);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { removeFromDatabase, UpdateToDatabase } from \"../Database/indexeddb\";\nimport { BinaryTree } from \"./BinaryTree\";\nimport { BinaryCharacterTree } from \"./BinaryCharacterTree\";\nimport { BinaryTypeTree } from \"./BinaryTypeTree\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nexport class ConceptsData {\n    constructor() {\n        this.name = \"conceptsArray\";\n    }\n    static CheckContains(concept) {\n        var contains = false;\n        for (var i = 0; i < this.conceptsArray.length; i++) {\n            if (this.conceptsArray[i].id == concept.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddNpc(id) {\n        if (!this.NPC.includes(id)) {\n            if (this.NPC.length > 10) {\n                this.NPC = [];\n            }\n            this.NPC.push(id);\n        }\n    }\n    static GetNpc(id) {\n        if (this.NPC.includes(id)) {\n            return true;\n        }\n        return false;\n    }\n    static AddConceptToStorage(concept) {\n        if (concept.id > 0) {\n            UpdateToDatabase(\"concept\", concept);\n        }\n    }\n    static GetConceptBulkData(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield BinaryTree.getConceptListFromIds(ids, connectionArray, remainingIds);\n        });\n    }\n    static AddConcept(concept) {\n        if (concept.id > 0) {\n            // console.log(\"added the concept to the tree\", concept);\n            //var contains = this.CheckContains(concept);\n            // this.conceptDictionary[concept.id] = concept;\n            //    if(contains){\n            //   this.RemoveConcept(concept);\n            //  }\n            //UpdateToDatabase(\"concept\",concept);\n            //IndexDbUpdate.UpdateConceptIndexDb(concept);\n            console.log(\"this is the added concept\", concept);\n            BinaryTree.addConceptToTree(concept);\n            BinaryTypeTree.addConceptToTree(concept);\n            //BinaryCharacterTree.addConceptToTree(concept);\n        }\n    }\n    static AddConceptToMemory(concept) {\n        if (concept.id > 0) {\n            //var contains = this.CheckContains(concept);\n            // this.conceptDictionary[concept.id] = concept;\n            //    if(contains){\n            //   this.RemoveConcept(concept);\n            //  }\n            BinaryTree.addConceptToTree(concept);\n            BinaryTypeTree.addConceptToTree(concept);\n            // BinaryCharacterTree.addConceptToTree(concept);\n        }\n    }\n    static AddConceptTemporary(concept) {\n        var contains = this.CheckContains(concept);\n        this.conceptDictionary[concept.id] = concept;\n        if (contains) {\n            this.RemoveConcept(concept);\n        }\n        this.conceptsArray.push(concept);\n    }\n    static RemoveConcept(concept) {\n        for (var i = 0; i < this.conceptsArray.length; i++) {\n            if (this.conceptsArray[i].id == concept.id) {\n                this.conceptsArray.splice(i, 1);\n            }\n        }\n        removeFromDatabase(\"concept\", concept.id);\n    }\n    static GetConcept(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var myConcept = CreateDefaultConcept();\n            var node = yield BinaryTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                var returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConcept = returnedConcept;\n                    // if(myConcept.count > IndexDbUpdate.MIN_USE_FOR_INDEX_DB){\n                    //     IndexDbUpdate.UpdateConceptIndexDb(myConcept);\n                    // }\n                }\n            }\n            return myConcept;\n        });\n    }\n    static GetConceptByCharacter(characterValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            var Node = BinaryCharacterTree.getNodeFromTree(characterValue);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterUpdated(characterValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            var Node = BinaryCharacterTree.getNodeFromTree(characterValue);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndTypeLocal(character_value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            //var Node = await BinaryCharacterTree.getCharacterAndTypeFromTree(character_value,typeId);\n            concept = yield BinaryTypeTree.getTypeVariantsWithCharacterValueNew(character_value, typeId);\n            // if(Node){\n            //     concept =  Node.value;\n            //     console.log(\"found the output\");\n            //     console.log(concept);\n            // }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndCategoryLocal(character_value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            var Node = yield BinaryCharacterTree.getCharacterAndCategoryFromTree(character_value, categoryId);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptsByTypeId(typeId) {\n        var myConcept;\n        let ConceptList = [];\n        myConcept = null;\n        for (var i = 0; i < this.conceptsArray.length; i++) {\n            if (this.conceptsArray[i].typeId == typeId) {\n                ConceptList.push(this.conceptsArray[i]);\n            }\n        }\n        return ConceptList;\n    }\n    static GetConceptsByTypeIdAndUser(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let ConceptList = [];\n            ConceptList = yield BinaryTypeTree.getTypeVariantsFromTreeWithUserIdNew(typeId, userId);\n            return ConceptList;\n        });\n    }\n    static GetBinaryCharacterTree() {\n        return BinaryCharacterTree.characterRoot;\n    }\n    getName() {\n        return this.name;\n    }\n}\nConceptsData.conceptsArray = [];\nConceptsData.NPC = [];\nConceptsData.conceptDictionary = [];\n","import { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nimport { BaseUrl } from \"./BaseUrl\";\nexport class Connection {\n    constructor(id = 0, ofTheConceptId, toTheConceptId, userId, typeId, orderId, accessId) {\n        this.count = 0;\n        this.isTemp = false;\n        this.toUpdate = false;\n        this.applicationId = BaseUrl.BASE_RANDOMIZER;\n        this.type = CreateDefaultConcept();\n        this.ofConcept = CreateDefaultConcept();\n        this.toConcept = CreateDefaultConcept();\n        this.id = id;\n        this.ofTheConceptId = ofTheConceptId;\n        this.toTheConceptId = toTheConceptId;\n        this.userId = userId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.orderId = orderId;\n        this.accessId = accessId;\n        this.entryTimeStamp = new Date();\n        this.terminationDateTime = new Date();\n        this.localSyncTime = new Date();\n        this.typeCharacter = \"\";\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { ConnectionNode } from \"./ConnectionNode\";\nexport class ConnectionBinaryTree {\n    static addNodeToTree(node) {\n        if (this.connectionroot == null) {\n            this.connectionroot = node;\n            return this.connectionroot;\n        }\n        else {\n            this.connectionroot = this.connectionroot.addNode(node, this.connectionroot, this.connectionroot.height);\n        }\n    }\n    static addConnectionToTree(connection) {\n        let node = new ConnectionNode(connection.id, connection, null, null);\n        this.addNodeToTree(node);\n    }\n    static traverse() {\n        var _a;\n        return (_a = this.connectionroot) === null || _a === void 0 ? void 0 : _a.traverse(this.connectionroot);\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isConnectionLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(ConnectionBinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionroot) {\n                this.connectionroot = this.connectionroot.removeNode(this.connectionroot, id);\n            }\n        });\n    }\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionroot) {\n                let Node = this.connectionroot.getFromNode(id, this.connectionroot);\n                return Node;\n            }\n            return this.connectionroot;\n        });\n    }\n    static getConnectionListFromIds(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionroot) {\n                this.connectionroot.checkIfIdsInNode(this.connectionroot, ids, connectionArray, remainingIds);\n            }\n        });\n    }\n}\nConnectionBinaryTree.connectionroot = null;\n","export class ConnectionNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.variants = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n        this.currentNode = null;\n    }\n    addCurrentNode(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        if (passedNode.value.typeId != node.value.typeId) {\n            node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        }\n        return node;\n    }\n    addCurrentNodeType(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let contains = false;\n        if (passedNode.value.id == node.value.id) {\n            contains = true;\n        }\n        for (let i = 0; i < node.variants.length; i++) {\n            if (node.variants[i].value.id == passedNode.value.id) {\n                contains = true;\n            }\n        }\n        if (!contains) {\n            node.variants.push(passedNode);\n        }\n        //node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        return node;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let LeftNode = node.leftNode;\n        let RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n    }\n    addTypeNode(passedNode, node, height) {\n        let debugFlag = false;\n        if (passedNode.value.typeId != 0) {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            let LeftNode = node.leftNode;\n            let RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addTypeNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addTypeNode(passedNode, RightNode, height);\n            }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != 0) {\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode) + 1);\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode) + 1);\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                if (node.value.count) {\n                    node.value.count++;\n                }\n                else {\n                    node.value.count = 1;\n                }\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getCharacterFromNode(value, node) {\n        if (node) {\n            if (value == node.key) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    checkIfIdsInNode(node, ids, connectionArray, remainingIds) {\n        if (node) {\n            if (ids.includes(node.key)) {\n                connectionArray.push(node.value);\n                //remainingIds[node.key] = true;\n                let index = ids.indexOf(node.key);\n                ids.splice(index, 1);\n            }\n            if (node.leftNode) {\n                this.checkIfIdsInNode(node.leftNode, ids, connectionArray, remainingIds);\n            }\n            if (node.rightNode) {\n                this.checkIfIdsInNode(node.rightNode, ids, connectionArray, remainingIds);\n            }\n        }\n    }\n    traverse(node) {\n        let count = 0;\n        if (node) {\n            count = count + 1;\n            if (node === null || node === void 0 ? void 0 : node.leftNode) {\n                count += this.traverse(node.leftNode);\n            }\n            if (node.rightNode) {\n                count += this.traverse(node.rightNode);\n            }\n        }\n        return count;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     let newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        /**\n         * This is dispatched incase the connection is deleted and others are listening\n         */\n        let event = new Event(`${passedNode.value.ofTheConceptId}`);\n        dispatchEvent(event);\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    removeNodeWithVariants(passedNode, typeIdentifier, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > typeIdentifier) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < typeIdentifier) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        if (passedNode.variants.length > 0) {\n            //condition if the main node is equal to the value\n            if (passedNode.value.id == conceptId) {\n                let newNode = passedNode.variants[0];\n                if (newNode) {\n                    passedNode.value = newNode.value;\n                    passedNode.key = newNode.key;\n                    passedNode.currentNode = newNode.currentNode;\n                    passedNode.variants.splice(0, 1);\n                    return passedNode;\n                }\n            }\n            else {\n                // in the condition that the main node is not equal to the checking value \n                for (let i = 0; i < passedNode.variants.length; i++) {\n                    if (conceptId == passedNode.variants[i].value.id) {\n                        passedNode.variants.splice(i, 1);\n                        return passedNode;\n                    }\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","import { NodePrimitive } from \"./NodePrimitive\";\nexport class ConnectionOfNode extends NodePrimitive {\n    constructor(key, value, leftNode, rightNode) {\n        super(key, value, leftNode, rightNode);\n        this.key = \"\";\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let LeftNode = node.leftNode;\n        let RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    let returner = this.rightRotate(node);\n                    return returner;\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    let returner = this.rightRotate(node);\n                    return returner;\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    let returner = this.leftRotate(node);\n                    return returner;\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    let returner = this.leftRotate(node);\n                    return returner;\n                }\n            }\n        }\n        return node;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionOfNode } from \"./ConnectionOfNode\";\n/**\n * This is a binary tree that is used to store the reference to the main connection of the concept.\n */\nexport class ConnectionOfTheTree {\n    static CreateCompositionKey(ofTheConceptId, typeId) {\n        return ofTheConceptId;\n    }\n    static GetConnectionByOfTheConceptAndTypeId(ofTheConceptId, typeId) {\n        let key = this.CreateCompositionKey(ofTheConceptId, typeId);\n        if (this.node) {\n            let existingNode = this.node.getFromNode(key, this.node);\n            if (existingNode) {\n                return existingNode.value;\n            }\n        }\n        return null;\n    }\n    /**\n     * This function lets you add a connection by composite key with of the concept id and type id.\n     * This function checks if the connection already exists and then updates in the case that it does not\n     * If the connection of the concept id and type id combination is encountered first time then a node is created.\n     * @param connection connection that needs to be added.\n     */\n    static addConnection(connection) {\n        if (connection.id > 0) {\n            let key = this.CreateCompositionKey(connection.ofTheConceptId, connection.typeId);\n            if (this.node) {\n                let event = new Event(`${key}`);\n                // console.log(\"dispatched the of the concecpt event\", event);\n                dispatchEvent(event);\n                let existingNode = this.node.getFromNode(key, this.node);\n                if (existingNode) {\n                    let connectionList = existingNode === null || existingNode === void 0 ? void 0 : existingNode.value;\n                    if (connectionList.length == 0) {\n                        existingNode.value = [];\n                    }\n                    if (!connectionList.includes(connection.id)) {\n                        connectionList.push(connection.id);\n                    }\n                }\n                else {\n                    let list = [];\n                    list.push(connection.id);\n                    let connectionNode = new ConnectionOfNode(key, list, null, null);\n                    this.addNodeToTree(connectionNode);\n                }\n            }\n            else {\n                let list = [];\n                list.push(connection.id);\n                let connectionNode = new ConnectionOfNode(key, list, null, null);\n                this.addNodeToTree(connectionNode);\n            }\n        }\n        else {\n            console.log(\"cannot insert key id with  n 0 to the connection tree\", connection);\n        }\n    }\n    /**\n     * This is a function to add the connectionNode to the existing tree\n     * @param connectionOfNode This is the node that needs to be added to the tree.\n     * @returns ConnectionOfNode\n     */\n    static addNodeToTree(connectionOfNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.node == null) {\n                this.node = connectionOfNode;\n                return this.node;\n            }\n            else {\n                this.node = this.node.addNode(connectionOfNode, this.node, this.node.height);\n            }\n            return this.node;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.node) {\n                this.node = this.node.removeNode(this.node, id);\n            }\n        });\n    }\n}\nConnectionOfTheTree.node = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { ConnectionNode } from \"./ConnectionNode\";\nexport class ConnectionTypeTree {\n    static addNodeToTree(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionTypeRoot == null) {\n                this.connectionTypeRoot = node;\n                return this.connectionTypeRoot;\n            }\n            else {\n                this.connectionTypeRoot = this.connectionTypeRoot.addTypeNode(node, this.connectionTypeRoot, this.connectionTypeRoot.height);\n            }\n            return this.connectionTypeRoot;\n        });\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isConnectionTypeLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(ConnectionTypeTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addConnectionToTree(connection) {\n        if (connection.typeId != 0) {\n            let node = new ConnectionNode(connection.typeId, connection, null, null);\n            this.addNodeToTree(node);\n        }\n    }\n    static removeTypeConcept(typeId, id) {\n        if (this.connectionTypeRoot) {\n            this.connectionTypeRoot = this.connectionTypeRoot.removeNodeWithVariants(this.connectionTypeRoot, typeId, id);\n        }\n    }\n    static getNodeFromTree(id) {\n        if (this.connectionTypeRoot) {\n            let Node = this.connectionTypeRoot.getFromNode(id, this.connectionTypeRoot);\n            return Node;\n        }\n        return this.connectionTypeRoot;\n    }\n    static getTypeVariantsFromTree(typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let connection = [];\n            // try{\n            //     let data = await this.waitForDataToLoad();\n            // }\n            // catch(exception){\n            //     return connection;\n            // }\n            let Node = this.getNodeFromTree(typeId);\n            if (Node) {\n                connection.push(Node === null || Node === void 0 ? void 0 : Node.value);\n                for (let i = 0; i < Node.variants.length; i++) {\n                    connection.push(Node.variants[i].value);\n                }\n                return connection;\n            }\n        });\n    }\n    static getTypeVariantsFromTreeWithUserId(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concepts = [];\n            var Node = this.getNodeFromTree(typeId);\n            if (Node) {\n                if (Node.value.userId == userId) {\n                    concepts.push(Node === null || Node === void 0 ? void 0 : Node.value);\n                }\n                for (let i = 0; i < Node.variants.length; i++) {\n                    if (Node.variants[i].value.userId == userId) {\n                        concepts.push(Node.variants[i].value);\n                    }\n                }\n            }\n            return concepts;\n        });\n    }\n}\nConnectionTypeTree.connectionTypeRoot = null;\n","export class NodePrimitive {\n    constructor(key, value, leftNode, rightNode) {\n        this.key = \"\";\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode) + 1);\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode) + 1);\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     var newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { removeFromDatabase, UpdateToDatabase } from \"../Database/indexeddb\";\nimport { Connection } from \"./Connection\";\nimport { ConnectionBinaryTree } from \"./ConnectionBinaryTree/ConnectionBinaryTree\";\nimport { ConnectionOfTheTree } from \"./ConnectionBinaryTree/ConnectionOfTheTree\";\nimport { ConnectionTypeTree } from \"./ConnectionBinaryTree/ConnectionTypeTree\";\nexport class ConnectionData {\n    constructor() {\n        this.name = \"Connection Array\";\n    }\n    static CheckContains(connection) {\n        let contains = false;\n        for (let i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConnectionToStorage(connection) {\n        UpdateToDatabase(\"connection\", connection);\n    }\n    static AddConnection(connection) {\n        //    var contains = this.CheckContains(connection);\n        //     if(contains){\n        //         this.RemoveConnection(connection);\n        //     }\n        //     if(connection.id != 0 || connection.isTemp){\n        //         storeToDatabase(\"connection\",connection);\n        //     }\n        //     this.connectionArray.push(connection);\n        // if(!connection.isTemp){\n        //UpdateToDatabase(\"connection\", connection);\n        ConnectionBinaryTree.addConnectionToTree(connection);\n        ConnectionTypeTree.addConnectionToTree(connection);\n        ConnectionOfTheTree.addConnection(connection);\n    }\n    static AddConnectionToMemory(connection) {\n        if (!connection.isTemp) {\n            ConnectionBinaryTree.addConnectionToTree(connection);\n            ConnectionTypeTree.addConnectionToTree(connection);\n            ConnectionOfTheTree.addConnection(connection);\n        }\n    }\n    static AddToDictionary(connection) {\n        this.connectionDictionary[connection.id] = connection;\n    }\n    static RemoveConnection(connection) {\n        //    for(var i=0; i<this.connectionArray.length; i++){\n        //     if(this.connectionArray[i].id == connection.id){\n        //         this.connectionArray.splice(i, 1);\n        //     }\n        //    }\n        if (connection.id != 0) {\n            removeFromDatabase(\"connection\", connection.id);\n            ConnectionBinaryTree.removeNodeFromTree(connection.id);\n            ConnectionTypeTree.removeTypeConcept(connection.typeId, connection.id);\n            ConnectionOfTheTree.removeNodeFromTree(connection.id);\n        }\n    }\n    static GetConnectionTypeOfTree() {\n        ConnectionOfTheTree.node;\n    }\n    static GetConnectionByOfTheConceptAndType(ofTheConceptId, typeId) {\n        let connections = ConnectionOfTheTree.GetConnectionByOfTheConceptAndTypeId(ofTheConceptId, typeId);\n        if (connections) {\n            return connections;\n        }\n        return [];\n    }\n    static GetConnectionTree() {\n        return ConnectionBinaryTree.connectionroot;\n    }\n    static GetConnectionTypeTree() {\n        return ConnectionTypeTree.connectionTypeRoot;\n    }\n    static GetConnectionBulkData(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ConnectionBinaryTree.getConnectionListFromIds(ids, connectionArray, remainingIds);\n        });\n    }\n    static GetConnection(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            //    var  myConcept: Connection|null;\n            //    myConcept = null;\n            //     for(var i=0; i<this.connectionArray.length; i++){\n            //         if(this.connectionArray[i].id == id){\n            //             myConcept = this.connectionArray[i];\n            //         }\n            //     }\n            //     return myConcept;\n            let myConnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n            let node = yield ConnectionBinaryTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                let returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConnection = returnedConcept;\n                    //if(myConnection.count > IndexDbUpdate.MIN_USE_FOR_INDEX_DB){\n                    // IndexDbUpdate.UpdateConnectionIndexDb(myConnection);\n                    //}\n                }\n            }\n            // if(myConcept.id == 0 || myConcept == null){\n            //     for(var i=0; i<this.conceptsArray.length; i++){\n            //         if(this.conceptsArray[i].id == id){\n            //             myConcept = this.conceptsArray[i];\n            //         }\n            //     }\n            // }\n            return myConnection;\n        });\n    }\n    static GetConnectionsOfCompositionLocal(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let connections = [];\n            let node = yield ConnectionTypeTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                let returnedConnection = node.value;\n                if (returnedConnection) {\n                    let myConnection = returnedConnection;\n                    connections.push(myConnection);\n                    for (let i = 0; i < node.variants.length; i++) {\n                        connections.push(node.variants[i].value);\n                    }\n                }\n            }\n            // if(myConcept.id == 0 || myConcept == null){\n            //     for(var i=0; i<this.conceptsArray.length; i++){\n            //         if(this.conceptsArray[i].id == id){\n            //             myConcept = this.conceptsArray[i];\n            //         }\n            //     }\n            // }\n            return connections;\n        });\n    }\n    static GetConnectionsOfConcept(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let connectionIds = [];\n            let connections = [];\n            connectionIds = ConnectionData.GetConnectionByOfTheConceptAndType(id, id);\n            for (let i = 0; i < connectionIds.length; i++) {\n                let conn = yield ConnectionBinaryTree.getNodeFromTree(connectionIds[i]);\n                if (conn) {\n                    connections.push(conn.value);\n                }\n            }\n            return connections;\n        });\n    }\n    getName() {\n        return this.name;\n    }\n}\nConnectionData.connectionArray = [];\nConnectionData.connectionDictionary = [];\n","export class FilterSearch {\n    constructor() {\n        this.type = \"\";\n        this.search = \"\";\n        this.logicoperator = \"=\";\n        this.index = 0;\n        this.composition = true;\n    }\n}\n","export class IdentifierFlags {\n}\nIdentifierFlags.isTypeLoaded = false;\nIdentifierFlags.isCharacterLoaded = false;\nIdentifierFlags.isDataLoaded = false;\nIdentifierFlags.isLocalDataLoaded = false;\nIdentifierFlags.isLocalCharacterLoaded = false;\nIdentifierFlags.isLocalTypeLoaded = false;\nIdentifierFlags.isConnectionLoaded = false;\nIdentifierFlags.isConnectionTypeLoaded = false;\nIdentifierFlags.isLocalConnectionLoaded = false;\n","import { BaseUrl } from \"../BaseUrl\";\nexport class LConcept {\n    constructor(id, userId, typeId, categoryId, accessId, characterValue, typeCharacter, isNew = false, entryTimeStamp, updatedTimeStamp, referentId) {\n        this.structureType = \"lconcept\";\n        this.isComposition = false;\n        this.isTemp = false;\n        this.isSynced = false;\n        this.applicationId = BaseUrl.BASE_RANDOMIZER;\n        this.id = id;\n        this.userId = userId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.categoryId = categoryId;\n        this.characterValue = characterValue;\n        this.accessId = accessId;\n        this.type = null;\n        this.isNew = isNew;\n        this.typeCharacter = typeCharacter;\n        this.entryTimeStamp = entryTimeStamp;\n        this.updatedTimeStamp = updatedTimeStamp;\n        this.isSynced = false;\n        this.referentId = referentId;\n        // ConceptsData.AddConcept(this);\n    }\n    getType() {\n        console.log(this.typeId);\n    }\n}\n","import { CreateDefaultConcept } from \"../../app\";\nimport { BaseUrl } from \"../BaseUrl\";\nexport class LConnection {\n    constructor(id, ofTheConceptId, toTheConceptId, typeId, orderId, accessId) {\n        this.isTemp = false;\n        this.applicationId = BaseUrl.BASE_RANDOMIZER;\n        this.type = CreateDefaultConcept();\n        this.id = id;\n        this.ofTheConceptId = ofTheConceptId;\n        this.toTheConceptId = toTheConceptId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.orderId = orderId;\n        this.typeCharacter = \"\";\n        this.accessId = accessId;\n        this.typeCharacter = \"\";\n        this.entryTimeStamp = new Date();\n        this.terminationDateTime = new Date();\n        this.localSyncTime = new Date();\n    }\n}\n","export class LNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.variants = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n        this.currentNode = null;\n    }\n    addCurrentNode(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        if (passedNode.value.typeId != node.value.typeId) {\n            node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        }\n        return node;\n    }\n    addCurrentNodeType(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        var contains = false;\n        for (let i = 0; i < node.variants.length; i++) {\n            if (node.variants[i].value.id == passedNode.value.id) {\n                contains = true;\n            }\n        }\n        if (!contains) {\n            node.variants.push(passedNode);\n        }\n        //node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        return node;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        var LeftNode = node.leftNode;\n        var RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n    }\n    addCharacterNode(passedNode, node, height) {\n        var debugFlag = false;\n        if (passedNode.value.characterValue != \"\") {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            // if (node.key == passedNode.key && node.key != \"\" ){\n            //     if(passedNode.value.characterValue == \"Default\"){\n            //         console.log(\"equal\");\n            //     }\n            //     node.currentNode = passedNode;\n            //     return node;\n            // }\n            var LeftNode = node.leftNode;\n            var RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addCharacterNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addCharacterNode(passedNode, RightNode, height);\n            }\n            // else if (node.key == passedNode.key && node.key != \"\"){\n            //     node.currentNode = passedNode;\n            // }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != \"\" && node.value.id != passedNode.value.id) {\n                    // node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    addTypeNode(passedNode, node, height) {\n        var debugFlag = false;\n        if (passedNode.value.typeId != 0) {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            var LeftNode = node.leftNode;\n            var RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addTypeNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addTypeNode(passedNode, RightNode, height);\n            }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != 0 && node.value.id != passedNode.value.id) {\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode) + 1);\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode) + 1);\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    updateNodeSyncStatus(id, value, node) {\n        if (node) {\n            if (id == node.key) {\n                let lconcept = node.value;\n                lconcept.isSynced = value;\n                node.value = lconcept;\n                return node;\n            }\n            else if (id < node.key) {\n                return this.updateNodeSyncStatus(id, value, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.updateNodeSyncStatus(id, value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getCharacterFromNode(value, node) {\n        if (node) {\n            if (value == node.key) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndType(value, typeId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && typeId == node.value.typeId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.typeId == typeId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndCategory(value, categoryId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && categoryId == node.value.categoryId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.categoryId == categoryId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     var newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            var immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    removeNodeWithVariants(passedNode, typeIdentifier, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > typeIdentifier) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < typeIdentifier) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        if (passedNode.variants.length > 0) {\n            //condition if the main node is equal to the value\n            if (passedNode.value.id == conceptId) {\n                var newNode = passedNode.variants[0];\n                if (newNode) {\n                    passedNode.value = newNode.value;\n                    passedNode.key = newNode.key;\n                    passedNode.currentNode = newNode.currentNode;\n                    passedNode.variants.splice(0, 1);\n                    return passedNode;\n                }\n            }\n            else {\n                // in the condition that the main node is not equal to the checking value \n                for (let i = 0; i < passedNode.variants.length; i++) {\n                    if (conceptId == passedNode.variants[i].value.id) {\n                        passedNode.variants.splice(i, 1);\n                        return passedNode;\n                    }\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            var immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"./../IdentifierFlags\";\nimport { LNode } from \"./../Local/LNode\";\nexport class LocalBinaryCharacterTree {\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalCharacterLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalBinaryCharacterTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addNodeToTree(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.LocalCharacterRoot == null) {\n                this.LocalCharacterRoot = node;\n                return this.LocalCharacterRoot;\n            }\n            else {\n                this.LocalCharacterRoot = this.LocalCharacterRoot.addCharacterNode(node, this.LocalCharacterRoot, this.LocalCharacterRoot.height);\n            }\n            return this.LocalCharacterRoot;\n        });\n    }\n    static addConceptToTree(concept) {\n        if (concept.characterValue != \"\") {\n            var node = new LNode(concept.characterValue, concept, null, null);\n            this.addNodeToTree(node);\n        }\n    }\n    static getNodeFromTree(value) {\n        if (this.LocalCharacterRoot) {\n            var Node = this.LocalCharacterRoot.getCharacterFromNode(value, this.LocalCharacterRoot);\n            return Node;\n        }\n        return this.LocalCharacterRoot;\n    }\n    static getCharacterAndTypeFromTree(value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.LocalCharacterRoot) {\n                var Node = this.LocalCharacterRoot.getFromNodeWithCharacterAndType(value, typeId, this.LocalCharacterRoot);\n                return Node;\n            }\n            return this.LocalCharacterRoot;\n        });\n    }\n    static getCharacterAndCategoryFromTree(value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.LocalCharacterRoot) {\n                var Node = this.LocalCharacterRoot.getFromNodeWithCharacterAndCategory(value, categoryId, this.LocalCharacterRoot);\n                return Node;\n            }\n            return this.LocalCharacterRoot;\n        });\n    }\n    static removeConceptType(character, id) {\n        if (this.LocalCharacterRoot) {\n            this.LocalCharacterRoot = this.LocalCharacterRoot.removeNodeWithVariants(this.LocalCharacterRoot, character, id);\n        }\n    }\n}\nLocalBinaryCharacterTree.LocalCharacterRoot = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { LNode } from \"./../Local/LNode\";\nexport class LocalBinaryTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static addConceptToTree(concept) {\n        var node = new LNode(concept.id, concept, null, null);\n        var characterNode = new LNode(concept.characterValue, concept, null, null);\n        this.addNodeToTree(node);\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalBinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.root) {\n                var Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static getCharacterAndTypeFromTree(value, typeId) {\n        if (this.root) {\n            var Node = this.root.getFromNodeWithCharacterAndType(value, typeId, this.root);\n            return Node;\n        }\n        return this.root;\n    }\n    static updateSyncStatus(id) {\n        if (this.root) {\n            var Node = this.root.updateNodeSyncStatus(id, true, this.root);\n            return Node;\n        }\n        return this.root;\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n}\nLocalBinaryTree.root = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"./../IdentifierFlags\";\nimport { LNode } from \"./LNode\";\nexport class LocalBinaryTypeTree {\n    static addNodeToTree(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.LocalTypeRoot == null) {\n                this.LocalTypeRoot = node;\n                return this.LocalTypeRoot;\n            }\n            else {\n                this.LocalTypeRoot = this.LocalTypeRoot.addTypeNode(node, this.LocalTypeRoot, this.LocalTypeRoot.height);\n            }\n            return this.LocalTypeRoot;\n        });\n    }\n    static addConceptToTree(concept) {\n        if (concept.typeId != 0) {\n            var node = new LNode(concept.typeId, concept, null, null);\n            this.addNodeToTree(node);\n        }\n    }\n    static removeConceptType(typeId, id) {\n        if (this.LocalTypeRoot) {\n            this.LocalTypeRoot = this.LocalTypeRoot.removeNodeWithVariants(this.LocalTypeRoot, typeId, id);\n        }\n    }\n    static getNodeFromTree(id) {\n        if (this.LocalTypeRoot) {\n            var Node = this.LocalTypeRoot.getFromNode(id, this.LocalTypeRoot);\n            return Node;\n        }\n        return this.LocalTypeRoot;\n    }\n    static getTypeVariantsFromTree(typeId) {\n        var Node = this.getNodeFromTree(typeId);\n        var concepts = [];\n        if (Node) {\n            concepts.push(Node === null || Node === void 0 ? void 0 : Node.value);\n            for (let i = 0; i < Node.variants.length; i++) {\n                concepts.push(Node.variants[i].value);\n            }\n            return concepts;\n        }\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalTypeLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalBinaryTypeTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static getTypeVariantsFromTreeWithUserId(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concepts = [];\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return concepts;\n            }\n            var Node = this.getNodeFromTree(typeId);\n            if (Node) {\n                console.log(\"this is the node to type\", Node);\n                if (Node.value.userId == userId || Node.value.userId == 999) {\n                    concepts.push(Node === null || Node === void 0 ? void 0 : Node.value);\n                }\n                for (let i = 0; i < Node.variants.length; i++) {\n                    if (Node.variants[i].value.userId == userId || Node.value.userId == 999) {\n                        concepts.push(Node.variants[i].value);\n                    }\n                }\n            }\n            return concepts;\n        });\n    }\n}\nLocalBinaryTypeTree.LocalTypeRoot = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { removeFromDatabase, UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { LocalBinaryTree } from \"./LocalBinaryTree\";\nimport { LocalBinaryCharacterTree } from \"./LocalBinaryCharacterTree\";\nimport { LocalBinaryTypeTree } from \"./LocalBinaryTypeTree\";\nimport { CreateDefaultLConcept } from \"../../Services/Local/CreateDefaultLConcept\";\nimport { ConceptsData } from \"../ConceptData\";\nimport { LocalGhostIdTree } from \"./LocalGhostIdTree\";\nexport class LocalConceptsData {\n    constructor() {\n        this.name = \"conceptsArray\";\n    }\n    static AddConcept(concept) {\n        if (concept.id != 0) {\n            UpdateToDatabase(\"localconcept\", concept);\n            LocalBinaryTree.addConceptToTree(concept);\n            LocalBinaryCharacterTree.addConceptToTree(concept);\n            LocalBinaryTypeTree.addConceptToTree(concept);\n            this.localconceptsArray.push(concept);\n        }\n    }\n    static AddPermanentConcept(concept) {\n        if (concept.id != 0) {\n            LocalBinaryTree.removeNodeFromTree(concept.ghostId);\n            LocalBinaryCharacterTree.removeConceptType(concept.characterValue, concept.ghostId);\n            LocalBinaryTypeTree.removeConceptType(concept.typeId, concept.ghostId);\n            LocalGhostIdTree.addConceptToTree(concept);\n            let removeData = removeFromDatabase(\"localconcept\", concept.ghostId);\n            ConceptsData.AddConcept(concept);\n        }\n    }\n    static RemoveConcept(concept) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (concept.id != 0) {\n                    LocalBinaryTree.removeNodeFromTree(concept.ghostId);\n                    LocalBinaryCharacterTree.removeConceptType(concept.characterValue, concept.ghostId);\n                    LocalBinaryTypeTree.removeConceptType(concept.typeId, concept.ghostId);\n                    yield removeFromDatabase(\"localconcept\", concept.ghostId);\n                }\n            }\n            catch (error) {\n                throw error;\n            }\n        });\n    }\n    static AddConceptToMemory(concept) {\n        if (concept.id != 0) {\n            LocalBinaryTree.addConceptToTree(concept);\n            LocalBinaryCharacterTree.addConceptToTree(concept);\n            LocalBinaryTypeTree.addConceptToTree(concept);\n        }\n    }\n    static GetConcept(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var myConcept = CreateDefaultLConcept();\n            var node = yield LocalBinaryTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                var returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConcept = returnedConcept;\n                }\n            }\n            return myConcept;\n        });\n    }\n    static UpdateConceptSyncStatus(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            LocalBinaryTree.updateSyncStatus(id);\n        });\n    }\n    static GetConceptByGhostId(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var myConcept = CreateDefaultLConcept();\n            var node = yield LocalGhostIdTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                var returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConcept = returnedConcept;\n                }\n            }\n            return myConcept;\n        });\n    }\n    static GetConceptByCharacter(characterValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultLConcept();\n            //  for(var i=0; i<this.conceptsArray.length; i++){\n            //      if(this.conceptsArray[i].characterValue == characterValue){\n            //         concept = this.conceptsArray[i];\n            //      }\n            //  }\n            var Node = LocalBinaryCharacterTree.getNodeFromTree(characterValue);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndTypeLocal(character_value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultLConcept();\n            // let conceptList:Concept[] = await this.GetConceptsByTypeId(typeId);\n            // for(var i=0;i<conceptList.length; i++){\n            //     if(character_value == conceptList[i].characterValue){\n            //         concept = conceptList[i];\n            //     }\n            // }\n            var Node = yield LocalBinaryCharacterTree.getCharacterAndTypeFromTree(character_value, typeId);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndCategoryLocal(character_value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultLConcept();\n            var Node = yield LocalBinaryCharacterTree.getCharacterAndCategoryFromTree(character_value, categoryId);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptsByTypeId(typeId) {\n        var myConcept;\n        let ConceptList = [];\n        myConcept = null;\n        for (var i = 0; i < this.localconceptsArray.length; i++) {\n            if (this.localconceptsArray[i].typeId == typeId) {\n                ConceptList.push(this.localconceptsArray[i]);\n            }\n        }\n        return ConceptList;\n    }\n    static GetConceptsByTypeIdAndUser(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var myConcept;\n            let ConceptList = [];\n            // myConcept = null;\n            //  for(var i=0; i<this.conceptsArray.length; i++){\n            //      if(this.conceptsArray[i].typeId == typeId && this.conceptsArray[i].userId == userId){\n            //          ConceptList.push(this.conceptsArray[i]);\n            //      }\n            //  }\n            ConceptList = yield LocalBinaryTypeTree.getTypeVariantsFromTreeWithUserId(typeId, userId);\n            return ConceptList;\n        });\n    }\n    getName() {\n        return this.name;\n    }\n}\nLocalConceptsData.localconceptsArray = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { removeFromDatabase } from \"../../Database/indexdblocal\";\nimport { ConvertFromLConnectionToConnection } from \"../../Services/Local/ConvertFromLConnectionToConnection\";\nimport { ConnectionData } from \"../ConnectionData\";\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nexport class LocalConnectionData {\n    constructor() {\n        this.name = \"Connection Array\";\n    }\n    static CheckContains(connection) {\n        var contains = false;\n        for (var i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConnection(connection) {\n        var contains = this.CheckContains(connection);\n        if (contains) {\n            this.RemoveConnection(connection);\n        }\n        if (connection.id != 0) {\n            UpdateToDatabase(\"localconnection\", connection);\n        }\n        this.connectionArray.push(connection);\n    }\n    static AddConnectionToMemory(connection) {\n        var contains = this.CheckContains(connection);\n        if (contains) {\n            this.RemoveConnection(connection);\n        }\n        this.connectionArray.push(connection);\n    }\n    static AddToDictionary(connection) {\n        this.connectionDictionary[connection.id] = connection;\n    }\n    static RemoveConnection(connection) {\n        console.log(\"this is removing\", connection);\n        for (var i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == connection.id) {\n                this.connectionArray.splice(i, 1);\n            }\n        }\n        if (connection.id != 0) {\n            //  removeFromDatabase(\"connection\",connection.id);\n        }\n    }\n    static AddPermanentConnection(connection) {\n        if (connection.id > 0) {\n            removeFromDatabase(\"localconnection\", connection.ghostId);\n            ConnectionData.AddConnection(ConvertFromLConnectionToConnection(connection));\n        }\n    }\n    static GetConnection(id) {\n        var myConcept;\n        myConcept = null;\n        for (var i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == id) {\n                myConcept = this.connectionArray[i];\n            }\n        }\n        return myConcept;\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalConnectionLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalConnectionData.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static GetConnectionsOfCompositionLocal(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var connectionList = [];\n            try {\n                var data = yield this.waitForDataToLoad();\n                for (var i = 0; i < this.connectionArray.length; i++) {\n                    if (this.connectionArray[i].typeId == id) {\n                        connectionList.push(this.connectionArray[i]);\n                    }\n                }\n                return connectionList;\n            }\n            catch (exception) {\n                return connectionList;\n            }\n        });\n    }\n    static GetConnectionOfCompositionAndTypeLocal(typeId, ofTheConceptId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var connectionList = [];\n            try {\n                var data = yield this.waitForDataToLoad();\n                console.log(\"this is the connections\", this.connectionArray, typeId, ofTheConceptId);\n                for (var i = 0; i < this.connectionArray.length; i++) {\n                    if (this.connectionArray[i].typeId == typeId && this.connectionArray[i].ofTheConceptId == ofTheConceptId) {\n                        connectionList.push(this.connectionArray[i]);\n                    }\n                }\n                return connectionList;\n            }\n            catch (exception) {\n                return connectionList;\n            }\n        });\n    }\n    getName() {\n        return this.name;\n    }\n}\nLocalConnectionData.connectionArray = [];\nLocalConnectionData.connectionDictionary = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { LNode } from \"./../Local/LNode\";\nexport class LocalGhostIdTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static addConceptToTree(concept) {\n        var node = new LNode(concept.ghostId, concept, null, null);\n        this.addNodeToTree(node);\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalGhostIdTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.root) {\n                var Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n}\nLocalGhostIdTree.root = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { PopulateTheLocalConceptsToMemory, PopulateTheLocalConnectionToMemory } from \"../../Services/Local/CreateLocalBinaryTreeFromData\";\nexport class LocalId {\n    static AddConceptId(id) {\n        this.localId = id.value;\n        //UpdateToDatabase(\"localid\", id);\n    }\n    /**\n     *\n     * This function will get the local concept id from the indexdb\n     * @returns the local concept id\n     */\n    static getConceptId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.localId) {\n                    if (this.ReservedLocalId.length < 5) {\n                        yield PopulateTheLocalConceptsToMemory().then(() => {\n                            let finalLocalId = this.localId;\n                            for (let j = 1; j < 10; j++) {\n                                let localId = this.localId - j;\n                                this.ReservedLocalId.push(localId);\n                                finalLocalId = localId;\n                            }\n                            // this.AddConceptId({\"id\":0, \"value\": finalLocalId})\n                        }).catch((event) => {\n                            console.log(\" getid: cannot get the id from indexdb\");\n                            return -Math.floor(Math.random() * 100000000);\n                        });\n                        let id = this.ReservedLocalId[0];\n                        this.ReservedLocalId.shift();\n                        return id;\n                    }\n                    else {\n                        let id = this.ReservedLocalId[0];\n                        this.ReservedLocalId.shift();\n                        return id;\n                    }\n                }\n                else {\n                    yield PopulateTheLocalConceptsToMemory().then(() => {\n                        let finalLocalId = this.localId;\n                        for (let j = 1; j < 10; j++) {\n                            let localId = this.localId - j;\n                            this.ReservedLocalId.push(localId);\n                            finalLocalId = localId;\n                        }\n                        //this.AddConceptId({\"id\":0, \"value\": finalLocalId});\n                    });\n                    return this.getConceptId();\n                }\n            }\n            catch (error) {\n                console.log(\" getid: this is the eror in concept\", error);\n                return -Math.floor(Math.random() * 100000000);\n            }\n        });\n    }\n    /**\n     *\n     * @param object This is the object that needs to be updated\n     */\n    static AddConnectionId(object) {\n        this.localConnectionId = object.value;\n        //UpdateToDatabase(\"localid\", id);\n    }\n    static getConnectionId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.localConnectionId) {\n                    if (this.ReservedConnectionId.length < 5) {\n                        yield PopulateTheLocalConnectionToMemory().then(() => {\n                            let finalLocalId = this.localConnectionId;\n                            for (let j = 1; j < 10; j++) {\n                                let localConId = this.localConnectionId - j;\n                                this.ReservedConnectionId.push(localConId);\n                                finalLocalId = localConId;\n                            }\n                        }).catch((event) => {\n                            console.log(\"this is the new event\", event);\n                            return -Math.floor(Math.random() * 100000000);\n                        });\n                        let id = this.ReservedConnectionId[0];\n                        this.ReservedConnectionId.shift();\n                        return id;\n                    }\n                    else {\n                        let id = this.ReservedConnectionId[0];\n                        this.ReservedConnectionId.shift();\n                        return id;\n                    }\n                }\n                else {\n                    yield PopulateTheLocalConnectionToMemory().then(() => {\n                        let finalLocalId = this.localConnectionId;\n                        for (let j = 1; j < 10; j++) {\n                            let localConId = this.localConnectionId - j;\n                            this.ReservedConnectionId.push(localConId);\n                            finalLocalId = localConId;\n                        }\n                        //this.AddConnectionId({\"id\":1, \"value\": finalLocalId})\n                    });\n                    return this.getConnectionId();\n                }\n            }\n            catch (error) {\n                return -Math.floor(Math.random() * 100000000);\n            }\n        });\n    }\n}\nLocalId.ReservedLocalId = [];\nLocalId.ReservedConnectionId = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheGhostConceptApi } from \"../../Api/Create/CreateTheGhostConceptApi\";\nimport { UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { LocalConceptsData } from \"./LocalConceptData\";\nimport { CreateDefaultLConcept } from \"../../app\";\nimport { LocalConnectionData } from \"./LocalConnectionData\";\nexport class LocalSyncData {\n    static CheckContains(concept) {\n        var contains = false;\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static SyncDataDelete(id) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (id == this.conceptsSyncArray[i].id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].ofTheConceptId == id || this.connectionSyncArray[i].toTheConceptId == id || this.connectionSyncArray[i].typeId == id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static CheckContainsConnection(connection) {\n        var contains = false;\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConcept(concept) {\n        try {\n            let contains = false;\n            let existingConcept = LocalSyncData.CheckIfTheConceptIdExists(concept.id, this.conceptsSyncArray);\n            if (existingConcept.id != 0) {\n                contains = true;\n            }\n            if (!contains) {\n                this.conceptsSyncArray.push(concept);\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    static RemoveConcept(concept) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static SyncDataOnline() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let conceptsArray = this.conceptsSyncArray.slice();\n                let connectionsArray = this.connectionSyncArray.slice();\n                this.connectionSyncArray = [];\n                this.conceptsSyncArray = [];\n                let toSyncConcepts = [];\n                for (let i = 0; i < conceptsArray.length; i++) {\n                    //if(!conceptsArray[i].isSynced){\n                    toSyncConcepts.push(conceptsArray[i]);\n                    //}\n                    // this is used to denote that the local concept has already been synced with the online db\n                    yield LocalConceptsData.UpdateConceptSyncStatus(conceptsArray[i].id);\n                }\n                //if(connectionsArray.length > 0){\n                yield this.UpdateConceptListToIncludeRelatedConcepts(connectionsArray, toSyncConcepts);\n                let result = yield CreateTheGhostConceptApi(toSyncConcepts, connectionsArray);\n                let concepts = result.concepts;\n                let connections = result.connections;\n                for (let i = 0; i < concepts.length; i++) {\n                    LocalConceptsData.AddPermanentConcept(concepts[i]);\n                }\n                for (let i = 0; i < connections.length; i++) {\n                    LocalConnectionData.AddPermanentConnection(connections[i]);\n                }\n                //}\n                return conceptsArray;\n            }\n            catch (error) {\n                throw error;\n            }\n        });\n    }\n    //  static async  SyncDataOnline(){\n    //     if(this.conceptsSyncArray.length > 0){\n    //         let conceptsArray = this.conceptsSyncArray.slice();\n    //         this.conceptsSyncArray = [];\n    //         let concepts = await CreateTheGhostConceptApi(conceptsArray);\n    //         for(let i =0 ; i< concepts.length; i++){\n    //             LocalSyncData.ghostIdMap.set(concepts[i].ghostId,concepts[i].id);\n    //             LocalConceptsData.AddPermanentConcept(concepts[i]);\n    //         }\n    //     }\n    //      if(this.connectionSyncArray.length > 0){\n    //         // for(let i =0 ; i<this.connectionSyncArray.length ; i++){\n    //         //     console.log(\"create the connection in backend\", this.connectionSyncArray[i].ofTheConceptId + \"====\" + this.connectionSyncArray[i].toTheConceptId);\n    //         // }\n    //         let connectionsArray = this.connectionSyncArray.slice();\n    //         this.ConvertGhostIdsInConnections(connectionsArray);\n    //         this.connectionSyncArray = [];\n    //         await CreateTheGhostConnectionApi(connectionsArray);\n    //     }\n    //     return \"done\";\n    //  }\n    static ConvertGhostIdsInConnections(connectionArray) {\n        var _a, _b, _c;\n        for (let i = 0; i < connectionArray.length; i++) {\n            let ofTheConceptId = connectionArray[i].ofTheConceptId;\n            let toTheConceptId = connectionArray[i].toTheConceptId;\n            let typeId = connectionArray[i].typeId;\n            let newOfTheConceptId = (_a = LocalSyncData.ghostIdMap.get(ofTheConceptId)) !== null && _a !== void 0 ? _a : ofTheConceptId;\n            let newToTheConceptId = (_b = LocalSyncData.ghostIdMap.get(toTheConceptId)) !== null && _b !== void 0 ? _b : toTheConceptId;\n            let newTypeId = (_c = LocalSyncData.ghostIdMap.get(typeId)) !== null && _c !== void 0 ? _c : typeId;\n            connectionArray[i].ofTheConceptId = newOfTheConceptId;\n            connectionArray[i].toTheConceptId = newToTheConceptId;\n            connectionArray[i].typeId = newTypeId;\n        }\n    }\n    static UpdateConceptListToIncludeRelatedConcepts(connectionArray, conceptsArray) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < connectionArray.length; i++) {\n                let ofTheConceptId = connectionArray[i].ofTheConceptId;\n                let toTheConceptId = connectionArray[i].toTheConceptId;\n                let typeId = connectionArray[i].typeId;\n                if (ofTheConceptId < 0) {\n                    let ofTheConcept = this.CheckIfTheConceptIdExists(ofTheConceptId, conceptsArray);\n                    if (ofTheConcept.id == 0) {\n                        ofTheConcept = yield LocalConceptsData.GetConceptByGhostId(ofTheConceptId);\n                        if (ofTheConcept.id != 0) {\n                            if (ofTheConcept.id != ofTheConcept.ghostId) {\n                                connectionArray[i].ofTheConceptId = ofTheConcept.id;\n                            }\n                        }\n                        else {\n                            ofTheConcept = yield LocalConceptsData.GetConcept(ofTheConceptId);\n                            // if this has already been synced before and is a composition type then do not send it again\n                            // if(!ofTheConcept.isSynced && !ofTheConcept.isComposition){\n                            this.AddConceptIfDoesNotExist(ofTheConcept, conceptsArray);\n                            //   }\n                        }\n                    }\n                }\n                if (toTheConceptId < 0) {\n                    let toTheConcept = this.CheckIfTheConceptIdExists(toTheConceptId, conceptsArray);\n                    if (toTheConcept.id == 0) {\n                        toTheConcept = yield LocalConceptsData.GetConceptByGhostId(toTheConceptId);\n                        if (toTheConcept.id != 0) {\n                            if (toTheConcept.id != toTheConcept.ghostId) {\n                                connectionArray[i].toTheConceptId = toTheConcept.id;\n                            }\n                        }\n                        else {\n                            toTheConcept = yield LocalConceptsData.GetConcept(toTheConceptId);\n                            // if this has already been synced before and is a composition type then do not send it again\n                            //   if(!toTheConcept.isSynced && !toTheConcept.isComposition){\n                            this.AddConceptIfDoesNotExist(toTheConcept, conceptsArray);\n                            //   }\n                        }\n                    }\n                }\n                if (typeId < 0) {\n                    let type = this.CheckIfTheConceptIdExists(typeId, conceptsArray);\n                    if (type.id == 0) {\n                        type = yield LocalConceptsData.GetConceptByGhostId(typeId);\n                        if (type.id != 0) {\n                            if (type.id != type.ghostId) {\n                                connectionArray[i].typeId = type.id;\n                            }\n                        }\n                        else {\n                            type = yield LocalConceptsData.GetConcept(typeId);\n                            // if this has already been synced before and is a composition type then do not send it again\n                            //    if(!type.isSynced && !type.isComposition){\n                            this.AddConceptIfDoesNotExist(type, conceptsArray);\n                            //    }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    static AddConceptIfDoesNotExist(concept, conceptList = []) {\n        let exists = false;\n        for (let i = 0; i < conceptList.length; i++) {\n            if (concept.ghostId == conceptList[i].ghostId) {\n                exists = true;\n            }\n        }\n        if (!exists) {\n            conceptList.push(concept);\n        }\n    }\n    static CheckIfTheConceptIdExists(id, conceptList = []) {\n        let returnConcept = CreateDefaultLConcept();\n        for (let i = 0; i < conceptList.length; i++) {\n            if (id == conceptList[i].ghostId || id == conceptList[i].id) {\n                returnConcept = conceptList[i];\n            }\n        }\n        return returnConcept;\n    }\n    static AddConnection(connection) {\n        this.connectionSyncArray.push(connection);\n    }\n    static RemoveConnection(connection) {\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static syncDataLocalDb() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.conceptsSyncArray.length > 0) {\n                for (let i = 0; i < this.conceptsSyncArray.length; i++) {\n                    UpdateToDatabase(\"localconcept\", this.conceptsSyncArray[i]);\n                }\n                this.conceptsSyncArray = [];\n            }\n            if (this.connectionSyncArray.length > 0) {\n                for (let i = 0; i < this.connectionSyncArray.length; i++) {\n                    UpdateToDatabase(\"localconnection\", this.connectionSyncArray[i]);\n                }\n                this.connectionSyncArray = [];\n            }\n            return \"done\";\n        });\n    }\n}\nLocalSyncData.conceptsSyncArray = [];\nLocalSyncData.connectionSyncArray = [];\nLocalSyncData.ghostIdMap = new Map();\n","export class Node {\n    constructor(key, value, leftNode, rightNode) {\n        this.variants = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n        this.currentNode = null;\n    }\n    addCurrentNode(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        if (passedNode.value.typeId != node.value.typeId) {\n            node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        }\n        return node;\n    }\n    addCurrentNodeType(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let contains = false;\n        for (let i = 0; i < node.variants.length; i++) {\n            if (node.variants[i].value.id == passedNode.value.id) {\n                contains = true;\n            }\n        }\n        if (!contains) {\n            node.variants.push(passedNode);\n        }\n        //node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        return node;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let LeftNode = node.leftNode;\n        let RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n    }\n    checkIfIdsInNode(node, ids, connectionArray, remainingIds) {\n        if (node) {\n            if (ids.includes(node.key)) {\n                connectionArray.push(node.value);\n                // remainingIds[node.key] = true;\n                let index = ids.indexOf(node.key);\n                ids.splice(index, 1);\n            }\n            if (node.leftNode) {\n                this.checkIfIdsInNode(node.leftNode, ids, connectionArray, remainingIds);\n            }\n            if (node.rightNode) {\n                this.checkIfIdsInNode(node.rightNode, ids, connectionArray, remainingIds);\n            }\n        }\n    }\n    addCharacterNode(passedNode, node, height) {\n        let debugFlag = false;\n        if (passedNode.value.characterValue != \"\") {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            // if (node.key == passedNode.key && node.key != \"\" ){\n            //     if(passedNode.value.characterValue == \"Default\"){\n            //         console.log(\"equal\");\n            //     }\n            //     node.currentNode = passedNode;\n            //     return node;\n            // }\n            let LeftNode = node.leftNode;\n            let RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addCharacterNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addCharacterNode(passedNode, RightNode, height);\n            }\n            // else if (node.key == passedNode.key && node.key != \"\"){\n            //     node.currentNode = passedNode;\n            // }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != \"\" && node.value.id != passedNode.value.id) {\n                    // node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    addTypeNode(passedNode, node, height) {\n        let debugFlag = false;\n        if (passedNode.value.typeId != 0) {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                console.log(\"adding the type node to the tree\", passedNode);\n                node = passedNode;\n                return node;\n            }\n            let LeftNode = node.leftNode;\n            let RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addTypeNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addTypeNode(passedNode, RightNode, height);\n            }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                console.log(\"adding the type node to the tree down\", passedNode);\n                if (node.key == passedNode.key && node.key != 0 && node.value.id != passedNode.value.id) {\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                console.log(\"adding the type node to the tree last\", node);\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode) + 1);\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode) + 1);\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                // if(node.value.count){\n                //     node.value.count++ ;\n                // }\n                // else{\n                //     node.value.count = 1;\n                // }\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getCharacterFromNode(value, node) {\n        if (node) {\n            if (value == node.key) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getCharacterFromNodeUpdated(value, node) {\n        var _a;\n        if (node) {\n            if (value == node.key || ((_a = node.value) === null || _a === void 0 ? void 0 : _a.typeId) == 51) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndType(value, typeId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && typeId == node.value.typeId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.typeId == typeId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndCategory(value, categoryId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && categoryId == node.value.categoryId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.categoryId == categoryId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     var newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    removeNodeWithVariants(passedNode, typeIdentifier, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > typeIdentifier) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < typeIdentifier) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        if (passedNode.variants.length > 0) {\n            //condition if the main node is equal to the value\n            if (passedNode.value.id == conceptId) {\n                let newNode = passedNode.variants[0];\n                if (newNode) {\n                    passedNode.value = newNode.value;\n                    passedNode.key = newNode.key;\n                    passedNode.currentNode = newNode.currentNode;\n                    passedNode.variants.splice(0, 1);\n                    return passedNode;\n                }\n            }\n            else {\n                // in the condition that the main node is not equal to the checking value \n                for (let i = 0; i < passedNode.variants.length; i++) {\n                    if (conceptId == passedNode.variants[i].value.id) {\n                        passedNode.variants.splice(i, 1);\n                        return passedNode;\n                    }\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","export class PatcherStructure {\n    constructor() {\n        this.compositionId = 0;\n        this.userId = 999;\n        this.sessionId = 999;\n        this.accessId = 4;\n        this.ofTheCompositionId = 0;\n        this.patchObject = {};\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetReservedConnectionIds } from \"../Api/GetReservedConnectionIds\";\nimport { GetReservedIds } from \"../Api/GetReservedIds\";\nexport class ReservedIds {\n    static getId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.ids.length < 5) {\n                var ids = yield GetReservedIds();\n            }\n            var id = this.ids[0];\n            this.ids.shift();\n            return id;\n        });\n    }\n    static AddId(id) {\n        if (!this.ids.includes(id)) {\n            this.ids.push(id);\n        }\n    }\n}\nReservedIds.ids = [];\nexport class ReservedConnectionIds {\n    static getId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionIds.length < 5) {\n                var connectionIds = yield GetReservedConnectionIds();\n            }\n            var id = this.connectionIds[0];\n            this.connectionIds.shift();\n            return id;\n        });\n    }\n    static AddId(id) {\n        if (!this.connectionIds.includes(id)) {\n            this.connectionIds.push(id);\n        }\n    }\n}\nReservedConnectionIds.connectionIds = [];\n","import { BaseUrl } from \"../BaseUrl\";\n/**\n * This is a class that is used to standardize the Response that is sent by FreeSchema.\n * This is done so that we do not have to send a HttpResponse codes.\n */\nexport class FreeSchemaResponse {\n    /**\n     *\n     * @param message this is the message for the response\n     * @param ok  this is the status can be true or false boolean in case that request succeds or fails\n     * @param status this is the standard http codes 200 for ok, 500 for internal error etc.\n     * @param data  this is the standard data that can be anything.\n     */\n    constructor(message, ok, status, data) {\n        this.url = BaseUrl.BASE_URL;\n        this.message = message;\n        this.ok = ok;\n        this.status = status;\n        this.data = data;\n    }\n    /**\n     * This function gets the message of the error\n     * @returns\n     */\n    getMessage() {\n        return this.message;\n    }\n    /**\n     *\n     * @param message This allows you to set a message variable in the FreeSchemaResponse\n     * @returns\n     */\n    setMessage(message) {\n        this.message = message;\n        return this;\n    }\n    /**\n     *\n     * @returns status code of the FreeSchemaResponse\n     */\n    getStatus() {\n        return this.status;\n    }\n    /**\n     *\n     * @param status standard http error codes (200 ok , 401 unauthorized, 500 internal server error etc.)\n     * @returns\n     */\n    setStatus(status) {\n        this.status = status;\n        return this;\n    }\n    /**\n     *\n     * @returns returns the data for the request\n     */\n    getData() {\n        return this.data;\n    }\n    /**\n     *\n     * @param data any type of data can be given here\n     * @returns FreeSchemaReponse\n     */\n    setData(data) {\n        this.data = data;\n        return this;\n    }\n    /**\n     *\n     * @returns the status of the FreeSchemaReponse (either true or false)\n     */\n    getOk() {\n        return this.ok;\n    }\n    /**\n     *\n     * @param status if the status is true then the response was successful else the success was not achieved.\n     * @returns returns the FreeSchemaResponse\n     */\n    setOk(ok) {\n        this.ok = ok;\n        return this;\n    }\n    /**\n     *\n     * @returns the url that caused the error\n     */\n    getUrl() {\n        return this.url;\n    }\n    /**\n     *\n     * @param url the url from which the error or response originates\n     * @returns FreeSchemaResponse\n     */\n    setUrl(url) {\n        this.url = url;\n        return this;\n    }\n}\n","export class Returner {\n    constructor(id, userId, referentId, isNew) {\n        this.id = id;\n        this.userId = userId;\n        this.referentId = referentId;\n        this.isNew = isNew;\n    }\n}\n","export class SearchQuery {\n    constructor() {\n        this.composition = 0;\n        this.type = \"\";\n        this.linker = \"\";\n        this.inpage = 10;\n        this.page = 1;\n        this.listLinkers = [];\n        this.fullLinkers = [];\n        this.textSearch = \"\";\n        this.logic = \"or\";\n        this.reverse = false;\n        this.doFilter = false;\n        this.filterSearches = [];\n        this.selectors = [];\n    }\n}\n","export class SearchStructure {\n    constructor() {\n        this.type = \"\";\n        this.search = \"\";\n        this.composition = \"\";\n        this.internalComposition = \"\";\n        this.userId = 999;\n        this.inpage = 10;\n        this.page = 1;\n    }\n}\n","export class TokenStorage {\n}\nTokenStorage.BearerAccessToken = \"\";\n","export class SessionData {\n    constructor() {\n        this.id = \"0\";\n        this.remote_address = \"\";\n        this.server_port = \"\";\n        this.server_address = \"\";\n        this.server_name = \"\";\n        this.server_software = \"\";\n        this.http_user_agent = \"\";\n        this.self = \"\";\n        this.port = \"\";\n        this.userId = \"\";\n        this.email = \"\";\n    }\n}\n","export class SettingData {\n    constructor(isOnlineSync) {\n        this.id = 1;\n        this.isOnlineSync = false;\n        this.isOnlineSync = isOnlineSync;\n    }\n}\n","export class Settings {\n}\nSettings.isUpdated = false;\nSettings.isOnlineSync = false;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { storeToDatabase } from \"./../Database/indexeddb\";\nimport { CreateTheConceptApi } from \"../Api/Create/CreateTheConceptApi\";\nimport { CreateTheConnectionApi } from \"../Api/Create/CreateTheConnectionApi\";\nimport { ConceptsData } from \"./ConceptData\";\nimport { ConnectionData } from \"./ConnectionData\";\nexport class SyncData {\n    static CheckContains(concept) {\n        var contains = false;\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static SyncDataDelete(id) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (id == this.conceptsSyncArray[i].id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].ofTheConceptId == id || this.connectionSyncArray[i].toTheConceptId == id || this.connectionSyncArray[i].typeId == id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static CheckContainsConnection(connection) {\n        var contains = false;\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConcept(concept) {\n        var contains = false;\n        // ConceptsData.AddConceptTemporary(concept);\n        if (!contains) {\n            this.conceptsSyncArray.push(concept);\n        }\n    }\n    static RemoveConcept(concept) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static AddConnection(connection) {\n        this.connectionSyncArray.push(connection);\n    }\n    static RemoveConnection(connection) {\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static SyncDataOnline() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < this.conceptsSyncArray.length; i++) {\n                ConceptsData.AddConcept(this.conceptsSyncArray[i]);\n            }\n            for (let i = 0; i < this.connectionSyncArray.length; i++) {\n                ConnectionData.AddConnection(this.connectionSyncArray[i]);\n            }\n            if (this.conceptsSyncArray.length > 0) {\n                let conceptsArray = this.conceptsSyncArray.slice();\n                this.conceptsSyncArray = [];\n                CreateTheConceptApi(conceptsArray);\n            }\n            if (this.connectionSyncArray.length > 0) {\n                // for(let i =0 ; i<this.connectionSyncArray.length ; i++){\n                //     console.log(\"create the connection in backend\", this.connectionSyncArray[i].ofTheConceptId + \"====\" + this.connectionSyncArray[i].toTheConceptId);\n                // }\n                let connectionsArray = this.connectionSyncArray.slice();\n                this.connectionSyncArray = [];\n                yield CreateTheConnectionApi(connectionsArray);\n            }\n            return \"done\";\n        });\n    }\n    static syncDataLocalDb() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.conceptsSyncArray.length > 0) {\n                for (let i = 0; i < this.conceptsSyncArray.length; i++) {\n                    storeToDatabase(\"localconcept\", this.conceptsSyncArray[i]);\n                }\n                this.conceptsSyncArray = [];\n            }\n            if (this.connectionSyncArray.length > 0) {\n                for (let i = 0; i < this.connectionSyncArray.length; i++) {\n                    storeToDatabase(\"localconnection\", this.connectionSyncArray[i]);\n                }\n                this.connectionSyncArray = [];\n            }\n            return \"done\";\n        });\n    }\n}\nSyncData.conceptsSyncArray = [];\nSyncData.connectionSyncArray = [];\n","export class TheCharacter {\n    constructor(userId, data, securityId, securityUserId, accessId, accessUserId, sessionId, sessionUserId, entryTimestamp, isNew) {\n        this.id = 0;\n        this.isNew = false;\n        this.userId = userId;\n        this.data = `${data}`;\n        this.securityId = securityId;\n        this.securityUserId = securityUserId;\n        this.accessId = accessId;\n        this.accessUserId = accessUserId;\n        this.sessionId = sessionId;\n        this.sessionUserId = sessionUserId;\n        this.isNew = isNew;\n    }\n}\n","export class TheTexts {\n    constructor(userId, data, securityId, securityUserId, accessId, accessUserId, sessionId, sessionUserId, entryTimestamp, isNew) {\n        this.id = 0;\n        this.userId = userId;\n        this.data = data;\n        this.securityId = securityId;\n        this.securityUserId = securityUserId;\n        this.accessId = accessId;\n        this.accessUserId = accessUserId;\n        this.sessionId = sessionId;\n        this.sessionUserId = sessionUserId;\n        this.entryTimestamp = entryTimestamp;\n        this.isNew = isNew;\n    }\n}\n","export class TypeNode {\n    constructor(key, value) {\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value.push(value);\n        this.leftNode = null;\n        this.rightNode = null;\n        this.currentNode = null;\n    }\n    addType(node, key, value) {\n        var _a, _b, _c, _d;\n        if (node == null) {\n            return new TypeNode(key, value);\n        }\n        if (key < node.key) {\n            node.leftNode = this.addType(node.leftNode, key, value);\n        }\n        else if (key > node.key) {\n            node.rightNode = this.addType(node.rightNode, key, value);\n        }\n        else {\n            // If key already exists, insert unique value into the set\n            node.value.push(value);\n            return node;\n        }\n        // Step 2: Update height of this ancestor node\n        node.height = Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode)) + 1;\n        // Step 3: Get the balance factor to check if this node became unbalanced\n        const balance = this.getBalanceFactor(node);\n        // Step 4: If the node is unbalanced, perform rotations\n        // Left Left Case (Right Rotation)\n        if (balance > 1 && key < ((_a = node.leftNode) === null || _a === void 0 ? void 0 : _a.key)) {\n            return this.rightRotate(node);\n        }\n        // Right Right Case (Left Rotation)\n        if (balance < -1 && key > ((_b = node.rightNode) === null || _b === void 0 ? void 0 : _b.key)) {\n            return this.leftRotate(node);\n        }\n        // Left Right Case (Left rotation, then right rotation)\n        if (balance > 1 && key > ((_c = node.leftNode) === null || _c === void 0 ? void 0 : _c.key)) {\n            node.leftNode = this.leftRotate(node.leftNode);\n            return this.rightRotate(node);\n        }\n        // Right Left Case (Right rotation, then left rotation)\n        if (balance < -1 && key < ((_d = node.rightNode) === null || _d === void 0 ? void 0 : _d.key)) {\n            node.rightNode = this.rightRotate(node.rightNode);\n            return this.leftRotate(node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode) + 1);\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode) + 1);\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                // if(node.value.count){\n                //     node.value.count++ ;\n                // }\n                // else{\n                //     node.value.count = 1;\n                // }\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    removeNodeWithVariants(passedNode, key, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > key) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, key, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < key) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, key, conceptId);\n            return passedNode;\n        }\n        if (passedNode.value.length > 0) {\n            // in the condition that the main node is not equal to the checking value \n            for (let i = 0; i < passedNode.value.length; i++) {\n                if (conceptId == passedNode.value[i]) {\n                    passedNode.value.splice(i, 1);\n                    return passedNode;\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UserNode } from \"./UserNode\";\nimport { IdentifierFlags } from \"./../IdentifierFlags\";\nexport class UserBinaryTree {\n    static compositeKey(userId, sessionId) {\n        let userHex = ('0000' + userId.toString(16).toUpperCase()).slice(-4);\n        let sessionHex = ('0000' + sessionId.toString(16).toUpperCase()).slice(-4);\n        return userHex + sessionHex;\n    }\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(UserBinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addConceptToTree(concept, userId, sessionId = 999) {\n        let key = this.compositeKey(userId, sessionId);\n        var node = new UserNode(key, concept, null, null);\n        this.addNodeToTree(node);\n    }\n    static getNodeFromTree(userId, sessionId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            let key = this.compositeKey(userId, sessionId);\n            if (this.root) {\n                var Node = this.root.getFromNode(key, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(userId_1) {\n        return __awaiter(this, arguments, void 0, function* (userId, sessionId = 999) {\n            if (this.root) {\n                let key = this.compositeKey(userId, sessionId);\n                this.root = this.root.removeNode(this.root, key);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.root) {\n            return this.root.countNodeBelow(this.root);\n        }\n        return 0;\n    }\n}\nUserBinaryTree.root = null;\n","export class UserNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value.push(value);\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        var LeftNode = node.leftNode;\n        var RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        else {\n            node.value.push(...passedNode.value);\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode) + 1);\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode) + 1);\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            var immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SettingData } from \"../DataStructures/SettingData\";\nimport { IndexDb } from \"./indexeddb\";\nexport function openDatabase(databaseName) {\n    return IndexDb.db;\n}\nexport function storeToDatabase(databaseName, object) {\n}\nexport function GetStatsFromDatabase() {\n    var settingsData = new SettingData(true);\n    return settingsData;\n}\nexport function AiUpdateFlag(object) {\n}\nexport function getFromDatabaseWithType(databaseName, type, id) {\n    return __awaiter(this, void 0, void 0, function* () {\n    });\n}\nexport function getObjectsFromIndexDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n    });\n}\nexport function removeFromDatabase(databaseName, id) {\n}\nexport function getAllFromLocalDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../app\";\n/**\n * version of the database. If you want to change the database then you must update this version also.\n */\nvar version = 9;\n/**\n * This class will help us store the indexdb  reference in memory and not go back to index db.\n */\nexport class LocalIndexDb {\n}\n/**\n *\n * @param databaseName not required actually. This is not used you can pass anything.\n * @returns a promise that either resolves or rejects opening the database.\n */\nexport function openDatabase(databaseName) {\n    return new Promise(function (resolve, reject) {\n        // if the indexdb is already initialized then you do not need to again initialize the db so you can get \n        // from memory.\n        if (LocalIndexDb.db) {\n            resolve(LocalIndexDb.db);\n        }\n        // the name of the database is passed here. We are statically passing the dbName with inputs from user\n        // the BASE_URL is the api that the framework calls\n        // the BASE_APPLICATION is a thing that differentiates an application from another so no two application create\n        // and use the same index db.  \n        let localDbName = BaseUrl.BASE_URL + \"_FreeSchemaLocal\" + BaseUrl.BASE_APPLICATION;\n        const request = indexedDB.open(localDbName, version);\n        // in case that the database is not opened then log the error.\n        // then we delete the database that is already present with the name\n        // then again try to create the database, since this is a temporary database so it might not matter\n        // but this is a point that we might need to be careful about.\n        // we then reject the promise and report this problem.\n        request.onerror = (event) => {\n            console.error(\"Why didn't you allow my web app to use IndexedDB?!\", event);\n            indexedDB.deleteDatabase(localDbName);\n            openDatabase(databaseName);\n            reject(event);\n        };\n        // in case that the database is allowed to be opened then we return the database object.\n        request.onsuccess = function (event) {\n            var target = event.target;\n            LocalIndexDb.db = target.result;\n            resolve(LocalIndexDb.db);\n        };\n        // in case that the version is upgraded then we delete all the old databases and then create a new database.\n        // version upgrade is a way which we can clean up old databases and its structures.\n        request.onupgradeneeded = (event) => {\n            var target = event.target;\n            var db = target.result;\n            var conceptDb = \"localconcept\";\n            var connectionDb = \"localconnection\";\n            var idDb = \"localid\";\n            console.log(\"this is the version upgrade\", version);\n            if (db.objectStoreNames.contains(conceptDb)) {\n                db.deleteObjectStore(conceptDb);\n            }\n            if (db.objectStoreNames.contains(connectionDb)) {\n                db.deleteObjectStore(connectionDb);\n            }\n            if (db.objectStoreNames.contains(idDb)) {\n                db.deleteObjectStore(idDb);\n            }\n            if (!db.objectStoreNames.contains(conceptDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(conceptDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                };\n            }\n            if (!db.objectStoreNames.contains(connectionDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(connectionDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                };\n            }\n            if (!db.objectStoreNames.contains(idDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(idDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // this is the event in which we initialize the local database\n                    // we assume the start of the localconcept by -100, localconnection by -200 and a random value \n                    // which will enable us to identify this local database from others.\n                    storeToDatabase(idDb, { \"id\": 0, \"value\": -100 });\n                    storeToDatabase(idDb, { \"id\": 1, \"value\": -200 });\n                    storeToDatabase(idDb, { \"id\": 3, \"value\": BaseUrl.BASE_RANDOMIZER });\n                };\n            }\n            resolve(db);\n        };\n    });\n}\nexport function LockTheDatabase(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"lock : locked db\");\n        yield UpdateToDatabase(databaseName, { \"id\": 4, \"value\": true });\n    });\n}\nexport function UnlockDatabase(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield UpdateToDatabase(databaseName, { \"id\": 4, \"value\": false });\n        console.log(\"lock :locked opened\");\n    });\n}\nexport function GetLockStatus(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let list = yield getObjectsFromLocalIndexDb(databaseName);\n            console.log(\"lock :for lock locked\", list);\n            if (Array.isArray(list)) {\n                console.log(\"lock : This is the list vallue\", list[4].value);\n                return list[4].value;\n            }\n            console.log(\"lock : This is not a list\", Array.isArray(list));\n            return false;\n        }\n        catch (error) {\n            console.log(\"lock : this is the error\", error);\n        }\n    });\n}\n/**\n*  this function will return all the objects that are in the database\n* @param databaseName name of the database\n* @returns all the objects that are in the database\n*/\nexport function getObjectsFromLocalIndexDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(function (resolve, reject) {\n            openDatabase(databaseName).then((db) => {\n                var concept;\n                var ConceptList = [];\n                let transaction = db.transaction(databaseName, \"readwrite\");\n                let objectStore = transaction.objectStore(databaseName);\n                var allobjects = objectStore.getAll();\n                allobjects.onsuccess = () => {\n                    const students = allobjects.result;\n                    for (var i = 0; i < students.length; i++) {\n                        ConceptList.push(students[i]);\n                    }\n                    resolve(ConceptList);\n                };\n            }).catch((event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot get objects from database because you cannot open the Local database\",\n                    \"data\": event\n                };\n                reject(errorObject);\n            });\n        });\n    });\n}\n/**\n *\n * @param databaseName name of the database that you want to store data to.\n * @param object any object that can be stored but keep in mind it must follow the convention that we created\n * while creating the datbase.\n * @returns a promise that if a store is successful then the obejct is returned else rejects with the event.\n */\nexport function storeToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.add(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot store to the Local database \" + databaseName,\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot store to database because you cannot open the Local database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *\n * @param databaseName name of the database\n * @param object this is the object that you want to update\n * @returns returns the object if it is updated successfully.\n */\nexport function UpdateToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        console.log(\"this is wriring to the database local\", object);\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.put(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot Update to the Local database\" + databaseName,\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot update to database because you cannot open the Local database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n//   /**\n//  *  this function will return all the objects that are in the database \n//  * @param databaseName name of the database\n//  * @returns all the objects that are in the database\n//  */\n// export async function getLConceptsFromLocalDb(databaseName:string){\n//   return new Promise(function(resolve, reject){\n//         var ConceptList:any[] = [];\n//       openDatabase(databaseName).then(db=>{\n//           let transaction = LocalIndexDb.db.transaction(databaseName, \"readwrite\") as IDBTransaction;\n//           let objectStore =transaction.objectStore(databaseName) as IDBObjectStore;\n//           var allobjects = objectStore.getAll();\n//           allobjects.onsuccess = ()=> {\n//             const readObjects = allobjects.result;\n//             for(var i=0; i<readObjects.length; i++){\n//                 ConceptList.push(readObjects[i]);\n//             }\n//             resolve(ConceptList); \n//         }\n//       });\n//   });\n// }\n/**\n *\n * @param databaseName name of the database\n * @param id the id that we need to remove from the database (this is the index)\n * @returns an id if the deletion is successful and error with even in case it cannot.\n */\nexport function removeFromDatabase(databaseName, id) {\n    return new Promise(function (resolve, reject) {\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objectStore = transaction.objectStore(databaseName);\n            let getRequest = objectStore.delete(id);\n            getRequest.onsuccess = function (event) {\n                resolve(id);\n            };\n            getRequest.onerror = function (event) {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot Update to the Local database\" + databaseName,\n                    \"data\": event,\n                    \"body\": id\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot remove object from database because you cannot open the Local database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SettingData } from \"../DataStructures/SettingData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\n/**\n * version of the database. If you want to change the database then you must update this version also.\n */\nvar version = 9;\n/**\n * This class will help us store the indexdb  reference in memory and not go back to index db.\n */\nexport class IndexDb {\n}\n/**\n *\n * @param databaseName not required actually. This is not used you can pass anything.\n * @returns a promise that either resolves or rejects opening the database.\n */\nexport function openDatabase(databaseName) {\n    return new Promise(function (resolve, reject) {\n        // if the indexdb is already initialized then you do not need to again initialize the db so you can get \n        // from memory.\n        if (IndexDb.db) {\n            resolve(IndexDb.db);\n        }\n        // the name of the database is passed here. We are statically passing the dbName with inputs from user\n        // the BASE_URL is the api that the framework calls\n        // the BASE_APPLICATION is a thing that differentiates an application from another so no two application create\n        // and use the same index db.\n        let dbName = BaseUrl.BASE_URL + \"_FreeSchema\" + BaseUrl.BASE_APPLICATION;\n        // open the database.\n        const request = indexedDB.open(dbName, version);\n        // in case that the database is not opened then log the error.\n        // then we delete the database that is already present with the name\n        // then again try to create the database, since this is a temporary database so it might not matter\n        // but this is a point that we might need to be careful about.\n        // we then reject the promise and report this problem.\n        request.onerror = (event) => {\n            console.error(\"Why didn't you allow my web app to use IndexedDB?!\", event);\n            indexedDB.deleteDatabase(dbName);\n            openDatabase(databaseName);\n            reject(event);\n        };\n        // in case that the database is allowed to be opened then we return the database object.\n        request.onsuccess = function (event) {\n            let target = event.target;\n            IndexDb.db = target.result;\n            resolve(IndexDb.db);\n        };\n        // in case that the version is upgraded then we delete all the old databases and then create a new database.\n        // version upgrade is a way which we can clean up old databases and its structures.\n        request.onupgradeneeded = (event) => {\n            let target = event.target;\n            let db = target.result;\n            let conceptDb = \"concept\";\n            let connectionDb = \"connection\";\n            let settings = \"settings\";\n            console.log(\"this is the version update for index\", version);\n            if (db.objectStoreNames.contains(conceptDb)) {\n                db.deleteObjectStore(conceptDb);\n            }\n            if (db.objectStoreNames.contains(connectionDb)) {\n                db.deleteObjectStore(connectionDb);\n            }\n            if (db.objectStoreNames.contains(settings)) {\n                db.deleteObjectStore(settings);\n            }\n            if (!db.objectStoreNames.contains(conceptDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(conceptDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // you can do something here after the db has been created.\n                };\n            }\n            if (!db.objectStoreNames.contains(connectionDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(connectionDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // you can do something here after the db has been created.\n                };\n            }\n            if (!db.objectStoreNames.contains(settings)) {\n                let objectStore = db.createObjectStore(settings, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // you can do something here after the db has been created.\n                };\n            }\n            resolve(db);\n        };\n    });\n}\n/**\n *\n * @param databaseName name of the database that you want to store data to.\n * @param object any object that can be stored but keep in mind it must follow the convention that we created\n * while creating the datbase.\n * @returns a promise that if a store is successful then the obejct is returned else rejects with the event.\n */\nexport function storeToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        console.log(\"this is storing to the database\", object);\n        openDatabase(databaseName).then((db) => {\n            if (object.id != 0) {\n                let transaction = db.transaction(databaseName, \"readwrite\");\n                let objStore = transaction.objectStore(databaseName);\n                const request = objStore.add(object);\n                request.onsuccess = (event) => {\n                    resolve(object);\n                };\n                request.onerror = (event) => {\n                    let errorObject = {\n                        \"status\": 400,\n                        \"ok\": false,\n                        \"message\": \"Cannot store to the database\" + databaseName,\n                        \"data\": event,\n                        \"body\": object\n                    };\n                    reject(errorObject);\n                };\n            }\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot store to the database because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n  *\n  * @param databaseName name of the database\n  * @param object this is the object that you want to update\n  * @returns returns the object if it is updated successfully.\n  */\nexport function UpdateToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        console.log(\"this is wriring to the database\", object);\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.put(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot Update to the database\" + databaseName,\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot update to database because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *\n * @returns This returns the last object from the database.\n */\nexport function GetLastSettingsFromDatabase() {\n    return new Promise(function (resolve, reject) {\n        let databaseName = \"settings\";\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objectStore = transaction.objectStore(databaseName);\n            let allobjects = objectStore.getAll();\n            allobjects.onsuccess = () => {\n                let settingsData = new SettingData(false);\n                let settingsArray = allobjects.result;\n                for (let i = 0; i < settingsArray.length; i++) {\n                    settingsData = settingsArray[i];\n                    settingsData = settingsData;\n                }\n                resolve(settingsData);\n            };\n            allobjects.onerror = (event) => {\n                reject(event);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot get last object from database because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *\n * @param object SettingData\n * @returns this will update the indexdb with the ai flag so that another time we do not have to pull\n *  ai data from the api.\n */\nexport function AiUpdateFlag(object) {\n    return new Promise(function (resolve, reject) {\n        let databaseName = \"settings\";\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.put(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot update AI flag\",\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        })\n            .catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot update AI flag because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *  this function will return all the objects that are in the database\n * @param databaseName name of the database\n * @returns all the objects that are in the database\n */\nexport function getObjectsFromIndexDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(function (resolve, reject) {\n            openDatabase(databaseName).then((db) => {\n                let ConceptList = [];\n                let transaction = db.transaction(databaseName, \"readwrite\");\n                let objectStore = transaction.objectStore(databaseName);\n                let allobjects = objectStore.getAll();\n                allobjects.onsuccess = () => {\n                    const students = allobjects.result;\n                    for (let i = 0; i < students.length; i++) {\n                        ConceptList.push(students[i]);\n                    }\n                    resolve(ConceptList);\n                };\n            }).catch((event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot get objects from the database because you cannot open the database\",\n                    \"data\": event\n                };\n                reject(errorObject);\n            });\n        });\n    });\n}\n/**\n *\n * @param databaseName name of the database\n * @param id the id that we need to remove from the database (this is the index)\n * @returns an id if the deletion is successful and error with even in case it cannot.\n */\nexport function removeFromDatabase(databaseName, id) {\n    return new Promise(function (resolve, reject) {\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objectStore = transaction.objectStore(databaseName);\n            const request = objectStore.delete(Number(id));\n            request.onsuccess = function (event) {\n                resolve(id);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot remove from the database\" + databaseName,\n                    \"data\": event\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot remove from the database because you cannot open the database\",\n                \"data\": event,\n                \"body\": id\n            };\n            reject(errorObject);\n        });\n    });\n}\n","import { Connection } from \"../DataStructures/Connection\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nexport function CheckIfConceptsExistsInArray(conceptList = [], concept) {\n    let foundConcept = CreateDefaultConcept();\n    if (Array.isArray(conceptList)) {\n        const check = conceptList.find(c => c.id === concept.id);\n        if (check) {\n            foundConcept = check;\n        }\n    }\n    return foundConcept;\n}\n// export function CheckIfTypeConceptExistsInArray(\n//   conceptList: Concept[] = [],\n//   concept: Concept,\n// ) {\n//   let newConceptType = concept.type?.characterValue;\n//   if(!newConceptType?.startsWith(\"the_\")){\n//     newConceptType = \"the_\" + newConceptType;\n//   }\n//   let startsWith = conceptList[i].type?.characterValue;\n//   if(!startsWith?.startsWith(\"the_\")){\n//     startsWith = \"the_\" + startsWith;\n//   }\n//   let foundConcept = CreateDefaultConcept()\n//   if (Array.isArray(conceptList)) {\n//     const check = conceptList.find(c => c.typeId == concept.typeId)\n//     if (check) {\n//       foundConcept = check\n//     }\n//   }\n//   return foundConcept\n// }\nexport function CheckIfTypeConceptsExistsInArray(conceptList = [], concept) {\n    var _a, _b;\n    let foundConcepts = [];\n    let newConceptType = (_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue;\n    if (!(newConceptType === null || newConceptType === void 0 ? void 0 : newConceptType.startsWith(\"the_\"))) {\n        newConceptType = \"the_\" + newConceptType;\n    }\n    if (Array.isArray(conceptList)) {\n        for (let i = 0; i < conceptList.length; i++) {\n            let startsWith = (_b = conceptList[i].type) === null || _b === void 0 ? void 0 : _b.characterValue;\n            if (!(startsWith === null || startsWith === void 0 ? void 0 : startsWith.startsWith(\"the_\"))) {\n                startsWith = \"the_\" + startsWith;\n            }\n            if (concept.typeId == conceptList[i].typeId || newConceptType == startsWith) {\n                foundConcepts.push(conceptList[i]);\n            }\n        }\n    }\n    return foundConcepts;\n}\nexport function CheckIfTypeLConceptsExistsInArray(conceptList = [], concept) {\n    let foundConcepts = [];\n    let newConceptType = concept.typeCharacter;\n    if (!(newConceptType === null || newConceptType === void 0 ? void 0 : newConceptType.startsWith(\"the_\"))) {\n        newConceptType = \"the_\" + newConceptType;\n    }\n    if (Array.isArray(conceptList)) {\n        for (let i = 0; i < conceptList.length; i++) {\n            let startsWith = conceptList[i].typeCharacter;\n            if (!(startsWith === null || startsWith === void 0 ? void 0 : startsWith.startsWith(\"the_\"))) {\n                startsWith = \"the_\" + startsWith;\n            }\n            if (concept.typeId == conceptList[i].typeId || newConceptType == startsWith) {\n                foundConcepts.push(conceptList[i]);\n            }\n        }\n    }\n    return foundConcepts;\n}\nexport function CheckIfConnectionExistsInArray(connectionList = [], connection) {\n    let foundConnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.id === connection.id);\n        if (check) {\n            foundConnection = check;\n        }\n    }\n    return foundConnection;\n}\nexport function CheckIfToTheConceptExistsInConnectionArray(connectionList = [], conceptId) {\n    let foundConnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.toTheConceptId === conceptId);\n        if (check) {\n            foundConnection = check;\n        }\n        const toCheck = connectionList.find(c => c.ofTheConceptId === conceptId);\n        if (toCheck) {\n            foundConnection = toCheck;\n        }\n    }\n    return foundConnection;\n}\nexport function CheckAllConnectionsConnectedInConnectionArray(connectionList = [], conceptId) {\n    let foundConnections = [];\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.toTheConceptId == conceptId);\n        if (check) {\n            foundConnections.push(check);\n        }\n        const toCheck = connectionList.find(c => c.ofTheConceptId == conceptId);\n        if (toCheck) {\n            foundConnections.push(toCheck);\n        }\n    }\n    return foundConnections;\n}\nexport function CheckAllConnectionsConnectedInLConnectionArray(connectionList = [], conceptId) {\n    let foundConnections = [];\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.toTheConceptId == conceptId);\n        if (check) {\n            foundConnections.push(check);\n        }\n        const toCheck = connectionList.find(c => c.ofTheConceptId == conceptId);\n        if (toCheck) {\n            foundConnections.push(toCheck);\n        }\n    }\n    return foundConnections;\n}\n","export function RemoveConceptFromList(conceptList = [], concept) {\n    if (Array.isArray(conceptList)) {\n        conceptList.splice(conceptList.findIndex(function (i) {\n            return i.id === concept.id;\n        }), 1);\n    }\n}\nexport function RemoveConnectionFromList(connectionList = [], connection) {\n    if (Array.isArray(connectionList)) {\n        connectionList.splice(connectionList.findIndex(function (i) {\n            return i.id === connection.id;\n        }), 1);\n    }\n}\nexport function RemoveLConnectionFromList(connectionList = [], connection) {\n    if (Array.isArray(connectionList)) {\n        connectionList.splice(connectionList.findIndex(function (i) {\n            return i.id === connection.id;\n        }), 1);\n    }\n}\n","export default function InsertUniqueNumber(Array, toInsert) {\n    if (Array.indexOf(toInsert) === -1) {\n        Array.push(toInsert);\n    }\n    return Array;\n}\n","export function CheckForConnectionDeletion(newConnections = [], oldConnections = []) {\n    // for(let i=0; i<oldConnections.length; i++){\n    //     if(Array.isArray(newConnections)){\n    //         if(!newConnections.find(obj => obj.id === oldConnections[i].id)){\n    //             ConnectionData.RemoveConnection(oldConnections[i]);\n    //        }\n    //     }\n    // }\n}\nexport function CheckForConnectionDeletionWithIds(newConnectionIds = [], oldConnections = []) {\n    // for(let i=0; i<oldConnections.length; i++){\n    //     if(!newConnectionIds.includes(oldConnections[i].id)){\n    //           ConnectionData.RemoveConnection(oldConnections[i]);\n    //     }\n    // }\n}\n","/**\n *\n * @param ms The time required to wait before executing this function\n * @param callback This is the function that needs to be executed\n * @returns returns a promise for the resolve\n */\nexport function DelayFunctionExecution(ms, callback) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(callback);\n        }, ms);\n    });\n}\n","import { FreeSchemaResponse } from \"../../DataStructures/Responses/ErrorResponse\";\nexport function HandleHttpError(response) {\n    if (response.status == 401 || response.status == 406) {\n        let errorResponse = new FreeSchemaResponse(response.statusText, false, response.status, \"\");\n        errorResponse.setUrl(response.url);\n        throw errorResponse;\n    }\n    else if (response.status == 500) {\n        let errorResponse = new FreeSchemaResponse(response.statusText, false, response.status, \"\");\n        errorResponse.setUrl(response.url);\n        throw errorResponse;\n    }\n}\nexport function HandleInternalError(error, url = \"\") {\n    if (error.status) {\n        let errorResponse = new FreeSchemaResponse(error.message, false, error.status, error.stack);\n        errorResponse.setUrl(url);\n        throw errorResponse;\n    }\n    else {\n        let errorResponse = new FreeSchemaResponse(error.message, false, 500, error.stack);\n        errorResponse.setUrl(url);\n        throw errorResponse;\n    }\n    throw error;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from '../../DataStructures/ConceptData';\nimport { CreateDefaultConcept } from '../../Services/CreateDefaultConcept';\nimport { default as GetTheConcept } from '../../Services/GetTheConcept';\n// this is a different type of recurisve fetch because here all the concepts and connections are passed as it is\n// so there is no need to query the connections and concepts from outside\n// if the concept connection is not found then it will go to the backend to fetch it\nexport function recursiveFetchNew(id_1, connectionList_1, conceptList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, conceptList, compositionList, visitedConcepts = []) {\n        var _a, _b;\n        let output = {};\n        const arroutput = [];\n        if (id == 0) {\n            return '';\n        }\n        // get concept from a list of concepts\n        let concept = getConceptFromList(conceptList, id);\n        // if we cannot find the concept from the concept list then find it from the backend\n        if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n            // get the concepts tries to find it from the binary tree else from the backend if cannot find it then\n            // it will become null\n            const conceptString = yield GetTheConcept(id);\n            concept = conceptString;\n        }\n        if (concept.id != 0) {\n            // if the concept type is non existent then you have to get the type from the backend\n            if (concept.type == null) {\n                // get the concept type id from the concept which is stored in typeId\n                const toConceptTypeId = concept.typeId;\n                //\n                let toConceptType = getConceptFromList(conceptList, toConceptTypeId);\n                concept.type = toConceptType;\n                if (toConceptType == null &&\n                    toConceptTypeId != null &&\n                    toConceptTypeId != undefined) {\n                    const conceptString = yield GetTheConcept(toConceptTypeId);\n                    toConceptType = conceptString;\n                    concept.type = toConceptType;\n                }\n            }\n        }\n        //let mainString = concept?.type?.characterValue ?? ''\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            // loop over all the connections\n            for (let i = 0; i < connectionList.length; i++) {\n                // if the connection has the id that has been passed in the recursion\n                // oftheconceptId -----> toTheConceptId\n                // this only gives the valid concept id that are inside of this id\n                if (connectionList[i].ofTheConceptId == id) {\n                    // then take out the toTheConceptId from the connection\n                    const toConceptId = connectionList[i].toTheConceptId;\n                    if (compositionList.includes(id)) {\n                        // convert the toTheConceptId to a real Concept Object\n                        let toConcept = getConceptFromList(conceptList, toConceptId);\n                        // get the concept\n                        if ((toConcept == null || toConcept.id == 0) &&\n                            toConceptId != null &&\n                            toConceptId != undefined) {\n                            const conceptString = yield GetTheConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        // if the toConcept is valid\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                // get the type in casee type is not defined\n                                const toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null &&\n                                    toConceptTypeId != null &&\n                                    toConceptTypeId != undefined) {\n                                    const conceptString = yield GetTheConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        // the regex to filter out the the_ from the type concepts\n                        const regex = 'the_';\n                        // then create the key of the key value pair that is the type of the concept\n                        const localmainString = (_b = (_a = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : '';\n                        // replace the the_ with an empty string\n                        const localKey = localmainString.replace(regex, '');\n                        // if the  type  is a number then put it inside of an object\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetchNew(toConceptId, connectionList, conceptList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            // if the type is a number then put it inside an array\n                            const result = yield recursiveFetchNew(toConceptId, connectionList, conceptList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n// gets the concept from the list of concepts using the conceptId\nfunction getConceptFromList(conceptList, conceptId) {\n    let concept = CreateDefaultConcept();\n    for (let i = 0; i < conceptList.length; i++) {\n        if (conceptId == conceptList[i].id) {\n            concept = conceptList[i];\n            return concept;\n        }\n    }\n    return concept;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from '../../DataStructures/ConceptData';\nimport { GetAllConnectionsOfComposition } from '../../Api/GetAllConnectionsOfComposition';\nimport { GetConnectionBulk } from '../../Api/GetConnectionBulk';\nimport { GetConcept } from '../../Api/GetConcept';\nimport { recursiveFetchNew } from './BuildComposition';\nimport { recursiveFetch } from '../GetComposition';\nimport { Composition } from '../../DataStructures/Composition/Composition';\nimport { CompositionBinaryTree } from '../../DataStructures/Composition/CompositionBinaryTree';\nimport { BulkConceptGetterApi } from '../../Api/GetConceptBulk';\n// get the composition with the passed id\n// here an optional parameter is passed which will pass the internal connections if given\n// else the function is designed to get the internal connections itself\nexport function GetCompositionWithCache(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionListPassed = []) {\n        var _a, _b;\n        let connectionList = [];\n        const conceptIdList = [];\n        let returnOutput = {};\n        let output = {};\n        const x = yield CompositionBinaryTree.getNodeFromTree(id);\n        const compositionList = [];\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            const conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (x == null) {\n            let connectionListString = [];\n            if (connectionListPassed.length > 0) {\n                connectionListString = getMyConnections(id, connectionListPassed);\n            }\n            else {\n                connectionListString = yield GetAllConnectionsOfComposition(id);\n            }\n            connectionList = connectionListString;\n            //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                    conceptIdList.push(connectionList[i].ofTheConceptId);\n                }\n                if (!conceptIdList.includes(connectionList[i].toTheConceptId)) {\n                    conceptIdList.push(connectionList[i].toTheConceptId);\n                }\n            }\n            SaveToCompositionCache(concept, connectionList, conceptIdList, compositionList);\n            let visitedConcepts = [];\n            output = yield recursiveFetch(id, connectionList, compositionList, visitedConcepts);\n            const mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : '';\n            returnOutput[mainString] = output;\n        }\n        else {\n            output = x.value.GetDataCache();\n            returnOutput = output;\n        }\n        if (concept.id == 0) {\n            return '';\n        }\n        return returnOutput;\n    });\n}\n// this gets the list of connections of a composition from a list of bulk connection pull\nfunction getMyConnections(id, connectionList) {\n    const connections = [];\n    for (let i = 0; i < connectionList.length; i++) {\n        if (connectionList[i].typeId == id) {\n            connections.push(connectionList[i]);\n        }\n    }\n    return connections;\n}\n// get the composition with the passed id\n// here an optional parameter is passed which will pass the internal connections if given\n// else the function is designed to get the internal connections itself\n// this function has a  format of data -- id\nexport function GetCompositionWithDataIdWithCache(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionListPassed = []) {\n        var _a, _b;\n        let FinalReturn = {};\n        let connectionList = [];\n        const conceptIdList = [];\n        let output;\n        const returnOutput = {};\n        const x = yield CompositionBinaryTree.getNodeFromTree(id);\n        const compositionList = [];\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            const conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (x == null) {\n            let connectionListString = [];\n            if (connectionListPassed.length > 0) {\n                connectionListString = getMyConnections(id, connectionListPassed);\n            }\n            else {\n                connectionListString = yield GetAllConnectionsOfComposition(id);\n            }\n            connectionList = connectionListString;\n            //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                    conceptIdList.push(connectionList[i].ofTheConceptId);\n                }\n                if (!conceptIdList.includes(connectionList[i].toTheConceptId)) {\n                    conceptIdList.push(connectionList[i].toTheConceptId);\n                }\n            }\n            SaveToCompositionCache(concept, connectionList, conceptIdList, compositionList);\n            output = yield recursiveFetch(id, connectionList, compositionList);\n            const mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : '';\n            returnOutput[mainString] = output;\n            FinalReturn[\"created_at\"] = concept.entryTimeStamp;\n            FinalReturn['data'] = returnOutput;\n            FinalReturn['id'] = id;\n        }\n        else {\n            output = x.value.GetDataCache();\n            FinalReturn = output;\n        }\n        if (concept.id == 0) {\n            return '';\n        }\n        return FinalReturn;\n    });\n}\n// this function needs to be passed with bulk compositions and bulk internal connections of them\n// so that i can conver them to actual list of compositions\nexport function GetCompositionWithDataIdBulk(ids, connections) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connectionList = [];\n        const compositions = [];\n        const newConnections = yield GetConnectionBulk(connections);\n        connectionList = newConnections;\n        for (let i = 0; i < ids.length; i++) {\n            const output = yield GetCompositionWithDataIdWithCache(ids[i], connectionList);\n            if (output) {\n                compositions.push(output);\n            }\n        }\n        return compositions;\n    });\n}\nfunction SaveToCompositionCache(concept, connections, conceptIdList, numbers) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const composition = new Composition();\n        const concepts = yield BulkConceptGetter(conceptIdList);\n        composition.connections = connections;\n        composition.concepts = concepts;\n        composition.id = concept.id;\n        composition.subcompositions = numbers;\n        composition.mainConcept = concept;\n        let visitedConcepts = [];\n        const output = yield recursiveFetchNew(concept.id, connections, concepts, numbers, visitedConcepts);\n        composition.cached = output;\n        CompositionBinaryTree.addCompositionToTree(composition);\n    });\n}\nfunction BulkConceptGetter(conceptIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let conceptList = [];\n        const bulkConceptFetch = [];\n        for (let i = 0; i < (conceptIds === null || conceptIds === void 0 ? void 0 : conceptIds.length); i++) {\n            const conceptUse = yield ConceptsData.GetConcept(conceptIds[i]);\n            if (conceptUse.id == 0) {\n                bulkConceptFetch.push(conceptIds[i]);\n            }\n            else {\n                conceptList.push(conceptUse);\n            }\n        }\n        if ((bulkConceptFetch === null || bulkConceptFetch === void 0 ? void 0 : bulkConceptFetch.length) == 0) {\n            return conceptList;\n        }\n        else {\n            conceptList = yield BulkConceptGetterApi(bulkConceptFetch);\n        }\n        return conceptList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateDefaultConcept } from '../CreateDefaultConcept';\nimport { Composition } from '../../DataStructures/Composition/Composition';\nimport MakeTheInstanceConcept from '../MakeTheInstanceConcept';\nimport { createTheConnection } from '../../Services/CreateTheConnection';\n// create a composition with caching mechanism\nexport function CreateTheCompositionWithCache(json_1) {\n    return __awaiter(this, arguments, void 0, function* (json, ofTheConceptId = null, ofTheConceptUserId = null, mainKey = null, userId = null, accessId = null, sessionInformationId = null, composition = null) {\n        const localUserId = userId !== null && userId !== void 0 ? userId : 999;\n        const localAccessId = accessId !== null && accessId !== void 0 ? accessId : 4;\n        const localSessionId = sessionInformationId !== null && sessionInformationId !== void 0 ? sessionInformationId : 999;\n        let MainKeyLocal = mainKey !== null && mainKey !== void 0 ? mainKey : 0;\n        let MainConcept = CreateDefaultConcept();\n        if (composition == null) {\n            // if no composition is passed then create a new composition\n            composition = new Composition();\n        }\n        for (const key in json) {\n            if (typeof json[key] == 'object' || Array.isArray(json[key])) {\n                const conceptString = yield MakeTheInstanceConcept(key, '', true, localUserId, localAccessId, localSessionId);\n                const concept = conceptString;\n                // if (typeof json[key] != 'string' && typeof json[key] != 'number') {\n                if (ofTheConceptId == null && ofTheConceptUserId == null) {\n                    // if there is no parent conceptId and conceptUserId passed then we know this is the main concept\n                    // everything is related to this concept.\n                    let localMainKey = MainKeyLocal;\n                    MainConcept = concept;\n                    localMainKey = concept.id;\n                    MainKeyLocal = concept.id;\n                    composition.concepts.push(concept);\n                    composition.id = concept.id;\n                    yield CreateTheCompositionWithCache(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId, composition);\n                }\n                else {\n                    // this is the concept which has parent passed onto it and this is a subcomposition\n                    const ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                    const ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                    const localMainKey = MainKeyLocal;\n                    MainConcept = concept;\n                    composition.concepts.push(concept);\n                    const connectionString = yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n                    const connection = connectionString;\n                    composition.connections.push(connection);\n                    yield CreateTheCompositionWithCache(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId, composition);\n                }\n                if (json[key] != null && json[key] != undefined) {\n                    composition.subcompositions.push(concept.id);\n                }\n            }\n            else {\n                // this is the part where the concept is now a key value pair and has the actual data\n                const ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                const ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                const localMainKey = MainKeyLocal;\n                const conceptString = yield MakeTheInstanceConcept(key, json[key], false, localUserId, localAccessId, localSessionId);\n                const concept = conceptString;\n                composition.concepts.push(concept);\n                const connectionString = yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n                const connection = connectionString;\n                composition.connections.push(connection);\n            }\n        }\n        // return the main concept\n        return MainConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterValue } from \"../../Api/GetConceptByCharacterValue\";\nimport { GetConceptByCharacterAndCategoryDirectApi } from \"../../Api/SearchConcept/GetConceptByCharacterAndCategoryDirect\";\nimport { ConceptsData, CreateDefaultConcept, SplitStrings } from \"../../app\";\nexport function GetConceptByCharacterAndCategory(character) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = CreateDefaultConcept();\n        if (character == \"the\") {\n            concept.id = 1;\n            concept.typeId = 5;\n            concept.characterValue = \"the\";\n            return concept;\n        }\n        let splittedStringArray = SplitStrings(character);\n        if (splittedStringArray.length > 1) {\n            let category = 1;\n            let prefix = yield GetConceptByCharacterAndCategory(splittedStringArray[0]);\n            if (prefix.id != 0) {\n                category = prefix.id;\n            }\n            concept = yield GetConceptByCharacterAndCategoryFromMemory(character, category);\n        }\n        else if (splittedStringArray[0] == character) {\n            concept = yield GetConceptByCharacter(character);\n        }\n        return concept;\n    });\n}\nexport function GetConceptByCharacter(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield ConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, 51);\n        if (concept.id == 0) {\n            concept = yield GetConceptByCharacterValue(characterValue);\n        }\n        return concept;\n    });\n}\nexport function GetConceptByCharacterAndCategoryFromMemory(character, category) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield ConceptsData.GetConceptByCharacterAndCategoryLocal(character, category);\n        if (concept.id == 0) {\n            concept = yield GetConceptByCharacterAndCategoryDirectApi(character, category);\n        }\n        return concept;\n    });\n}\n","import { Connection } from \"../../DataStructures/Connection\";\nimport { CreateDefaultConcept } from \"../CreateDefaultConcept\";\nimport { CreateDefaultLConcept } from \"../Local/CreateDefaultLConcept\";\nexport function convertFromConceptToLConcept(concept) {\n    var _a, _b;\n    const LConcept = CreateDefaultLConcept();\n    LConcept.id = concept.id;\n    LConcept.ghostId = concept.ghostId;\n    LConcept.userId = concept.userId;\n    LConcept.accessId = concept.accessId;\n    LConcept.categoryId = concept.categoryId;\n    LConcept.characterValue = concept.characterValue;\n    LConcept.entryTimeStamp = concept.entryTimeStamp;\n    LConcept.typeId = concept.typeId;\n    LConcept.type = concept.type;\n    LConcept.isTemp = false;\n    LConcept.typeCharacter = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n    return LConcept;\n}\nexport function convertFromLConceptToConcept(lconcept) {\n    const concept = CreateDefaultConcept();\n    concept.id = lconcept.id;\n    concept.ghostId = lconcept.ghostId;\n    concept.userId = lconcept.userId;\n    concept.accessId = lconcept.accessId;\n    concept.entryTimeStamp = lconcept.entryTimeStamp;\n    concept.typeId = lconcept.typeId;\n    concept.categoryId = lconcept.categoryId;\n    return concept;\n}\nexport function convertFromConnectionToLConnection(connection) {\n    const Lconnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    Lconnection.id = connection.id;\n    Lconnection.ghostId = connection.ghostId;\n    Lconnection.accessId = connection.accessId;\n    Lconnection.ofTheConceptId = connection.ofTheConceptId;\n    Lconnection.toTheConceptId = connection.toTheConceptId;\n    Lconnection.entryTimeStamp = connection.entryTimeStamp;\n    Lconnection.typeId = connection.typeId;\n    Lconnection.isTemp = false;\n    return Lconnection;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DelayFunctionExecution } from \"../app\";\nimport { getObjectsFromIndexDb } from \"../Database/indexeddb\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { IdentifierFlags } from \"../DataStructures/IdentifierFlags\";\n/**\n * This function builds up the binary tree on startup from the indexdb\n */\nexport default function CreateConceptBinaryTreeFromIndexDb() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let conceptList = yield getObjectsFromIndexDb(\"concept\");\n            if (Array.isArray(conceptList)) {\n                for (let i = 0; i < conceptList.length; i++) {\n                    let concept = conceptList[i];\n                    ConceptsData.AddConceptToMemory(concept);\n                }\n            }\n            IdentifierFlags.isDataLoaded = true;\n            IdentifierFlags.isCharacterLoaded = true;\n            IdentifierFlags.isTypeLoaded = true;\n        }\n        catch (error) {\n            yield DelayFunctionExecution(2000, CreateConceptBinaryTreeFromIndexDb());\n            let errorObject = {\n                \"message\": \"Cannot create Binary Tree Concept\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            throw errorObject;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConnectionOfTheConcept } from \"../Api/GetConnectionOfTheConcept\";\nimport { Connection } from \"../DataStructures/Connection\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport { CreateTheConnectionGeneral } from \"./CreateTheConnectionGeneral\";\nimport { DeleteConnectionById } from \"./DeleteConnection\";\nimport GetTheConcept from \"./GetTheConcept\";\nimport MakeTheInstanceConcept from \"./MakeTheInstanceConcept\";\nexport function CreateConnectionBetweenTwoConcepts(ofTheConcept_1, toTheConcept_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, both = false, count = false) {\n        var _a, _b;\n        let userId = ofTheConcept.userId;\n        let accessId = 4;\n        if (both) {\n            let prefix1 = ((_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\";\n            let linkerAdd1 = linker + \"_by\";\n            let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n            if (count) {\n                yield CountRelationship(linkerAdd1, toTheConcept, userId);\n            }\n            let connectionConceptReverse = yield MakeTheInstanceConcept(\"connection\", backwardLinker, false, 999, 999, 999);\n            let newConnection = new Connection(0, toTheConcept.id, ofTheConcept.id, userId, connectionConceptReverse.id, 1000, accessId);\n            SyncData.AddConnection(newConnection);\n        }\n        let prefix = ((_b = ofTheConcept.type) === null || _b === void 0 ? void 0 : _b.characterValue) + \"_s\";\n        let linkerAdd = linker + \"_s\";\n        let forwardLinker = prefix + \"_\" + linkerAdd;\n        if (count) {\n            yield CountRelationship(linkerAdd, ofTheConcept, userId);\n        }\n        let connectionConcept = yield MakeTheInstanceConcept(\"connection\", forwardLinker, false, 999, 999, 999);\n        let newConnection = new Connection(0, ofTheConcept.id, toTheConcept.id, userId, connectionConcept.id, 1000, accessId);\n        SyncData.AddConnection(newConnection);\n        return newConnection;\n    });\n}\nexport function CountRelationship(linker_1, concept_1) {\n    return __awaiter(this, arguments, void 0, function* (linker, concept, passedUserId = null) {\n        var _a;\n        let concept1 = concept;\n        let userId = passedUserId !== null && passedUserId !== void 0 ? passedUserId : concept.userId;\n        let accessId = 4;\n        let sessionInformationId = 999;\n        let forwardLinkerCount = linker + \"_count\";\n        let forwardLinkerCountString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + forwardLinkerCount;\n        let forwardLinkerCountConcept = yield MakeTheInstanceConcept(\"connection\", forwardLinkerCountString, false, userId, accessId, sessionInformationId);\n        let connectionsString = yield GetConnectionOfTheConcept(forwardLinkerCountConcept.id, concept.id, userId, 10, 1);\n        let connections = connectionsString;\n        let countConceptList = [];\n        let countConcept = CreateDefaultConcept();\n        for (let i = 0; i < connections.length; i++) {\n            let toConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            countConceptList.push(toConcept);\n        }\n        if (countConceptList.length < 1) {\n            countConcept = yield MakeTheInstanceConcept(\"count\", \"1\", false, userId, accessId, sessionInformationId);\n        }\n        else {\n            let oldcountConcept = countConceptList[0];\n            let count = 0;\n            try {\n                count = Number(oldcountConcept.characterValue);\n            }\n            catch (ex) {\n                count = 0;\n            }\n            count = count + 1;\n            countConcept = yield MakeTheInstanceConcept(\"count\", count.toString(), false, userId, accessId, sessionInformationId);\n            for (let i = 0; i < connections.length; i++) {\n                DeleteConnectionById(connections[i].id);\n            }\n        }\n        let newConnection = new Connection(0, concept1.id, countConcept.id, concept1.userId, forwardLinkerCountConcept.id, 1000, accessId);\n        yield SyncData.AddConnection(newConnection);\n    });\n}\nexport function CreateConnectionBetweenTwoConceptsGeneral(ofTheConcept_1, toTheConcept_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, both = false, count = false) {\n        var _a, _b;\n        let userId = ofTheConcept.userId;\n        let accessId = 4;\n        if (both) {\n            let prefix1 = ((_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\";\n            let linkerAdd1 = linker + \"_by\";\n            let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n            if (count) {\n                yield CountRelationship(linkerAdd1, toTheConcept, userId);\n            }\n            let connectionConceptReverse = yield MakeTheInstanceConcept(\"connection\", backwardLinker, false, 999, 999, 999);\n            let newConnection = new Connection(0, toTheConcept.id, ofTheConcept.id, userId, connectionConceptReverse.id, 1000, accessId);\n            SyncData.AddConnection(newConnection);\n        }\n        let prefix = ((_b = ofTheConcept.type) === null || _b === void 0 ? void 0 : _b.characterValue) + \"_s\";\n        let linkerAdd = linker + \"_s\";\n        let forwardLinker = prefix + \"_\" + linkerAdd;\n        if (count) {\n            yield CountRelationship(linkerAdd, ofTheConcept, userId);\n        }\n        let connectionConcept = yield MakeTheInstanceConcept(\"connection\", forwardLinker, false, 999, 999, 999);\n        let newConnection = yield CreateTheConnectionGeneral(ofTheConcept.id, ofTheConcept.userId, toTheConcept.id, connectionConcept.id, 1000, accessId);\n        return newConnection;\n    });\n}\n","import { Concept } from \"../DataStructures/Concept\";\nexport function CreateDefaultConcept() {\n    let created_on = new Date();\n    let updated_on = new Date();\n    let concept = new Concept(0, 0, 0, 0, 0, \"0\", 0, false, created_on, updated_on, \"0\");\n    return concept;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport { createTheConnection } from \"./CreateTheConnection\";\nimport MakeTheInstanceConcept from \"./MakeTheInstanceConcept\";\nexport default function CreateTheComposition(json_1) {\n    return __awaiter(this, arguments, void 0, function* (json, ofTheConceptId = null, ofTheConceptUserId = null, mainKey = null, userId = null, accessId = null, sessionInformationId = null) {\n        let localUserId = userId !== null && userId !== void 0 ? userId : 999;\n        let localAccessId = accessId !== null && accessId !== void 0 ? accessId : 4;\n        let localSessionId = sessionInformationId !== null && sessionInformationId !== void 0 ? sessionInformationId : 999;\n        let MainKeyLocal = mainKey !== null && mainKey !== void 0 ? mainKey : 0;\n        let MainConcept = CreateDefaultConcept();\n        for (const key in json) {\n            if ((typeof json[key] != 'string' && typeof json[key] != 'number')) {\n                if (ofTheConceptId == null && ofTheConceptUserId == null) {\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConcept(key, \"\", true, localUserId, localAccessId, localSessionId);\n                    let concept = conceptString;\n                    MainConcept = concept;\n                    localMainKey = concept.id;\n                    MainKeyLocal = concept.id;\n                    yield CreateTheComposition(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId);\n                }\n                else {\n                    let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                    let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConcept(key, \"\", true, localUserId, localAccessId, localSessionId);\n                    let concept = conceptString;\n                    MainConcept = concept;\n                    yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n                    yield CreateTheComposition(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId);\n                }\n            }\n            else {\n                let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 10267;\n                let localMainKey = MainKeyLocal;\n                let conceptString = yield MakeTheInstanceConcept(key, json[key].toString(), false, localUserId, localAccessId, localSessionId);\n                let concept = conceptString;\n                yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n            }\n        }\n        return MainConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheConceptApi } from \"../Api/Create/CreateTheConceptApi\";\nimport { Concept } from \"../DataStructures/Concept\";\nimport { ReservedIds } from \"../DataStructures/ReservedIds\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nimport { ConceptsData } from \"../app\";\nexport default function CreateTheConcept(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let id = yield ReservedIds.getId();\n        let isNew = true;\n        let created_on = new Date();\n        let updated_on = new Date();\n        // let concept = new Concept(id,userId,typeId,typeUserId,categoryId,categoryUserId,referentId, referentUserId, referent, securityId,\n        // securityUserId,accessId, accessUserId,sessionInformationId, sessionInformationUserId,isNew,created_on,updated_on);\n        let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typeCharacter);\n        concept.isTemp = false;\n        SyncData.AddConcept(concept);\n        return concept;\n    });\n}\nexport function CreateTheConceptTemporary(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let id = yield ReservedIds.getId();\n        let isNew = true;\n        let created_on = new Date();\n        let updated_on = new Date();\n        // let concept = new Concept(id,userId,typeId,typeUserId,categoryId,referentId, referent,\n        //     accessId,isNew,created_on, updated_on);\n        let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typeCharacter);\n        concept.isTemp = true;\n        return concept;\n    });\n}\nexport function CreateTheConceptImmediate(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let id = yield ReservedIds.getId();\n        let isNew = false;\n        let created_on = new Date();\n        let updated_on = new Date();\n        // let concept = new Concept(id,userId,typeId,typeUserId,categoryId,categoryUserId,referentId, referentUserId, referent, securityId,\n        //     securityUserId,accessId, accessUserId,sessionInformationId, sessionInformationUserId,isNew,created_on, updated_on);\n        let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typeCharacter);\n        ConceptsData.AddConcept(concept);\n        CreateTheConceptApi([concept]);\n        //SyncData.AddConcept(concept);\n        return concept;\n    });\n}\n","import { Connection } from \"../DataStructures/Connection\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nimport { HandleInternalError } from \"./Common/ErrorPosting\";\n/**\n * This function is used to create a connection that is internal(inside of a composition)\n * @param ofTheConceptId Start of the connection\n * @param userId user id fo the user creating the connection\n * @param toTheConceptId the end of the connection\n * @param typeId this is the type of the connection\n * @returns\n */\nexport function createTheConnection(ofTheConceptId, userId, toTheConceptId, typeId) {\n    var orderId = 1;\n    var localUserId = userId;\n    var accessId = 4;\n    var connection = new Connection(0, ofTheConceptId, toTheConceptId, localUserId, typeId, orderId, accessId);\n    if (ofTheConceptId == toTheConceptId) {\n        connection.ofTheConceptId = 0;\n        connection.toTheConceptId = 1;\n        return connection;\n    }\n    try {\n        connection.isTemp = true;\n        connection.id = Math.floor(Math.random() * 100000000);\n        SyncData.AddConnection(connection);\n    }\n    catch (error) {\n        HandleInternalError(error);\n    }\n    return connection;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Connection } from \"../DataStructures/Connection\";\nimport { ReservedConnectionIds } from \"../DataStructures/ReservedIds\";\nimport { FreeSchemaResponse } from \"../DataStructures/Responses/ErrorResponse\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nexport function CreateTheConnectionGeneral(ofTheConceptId_1, ofTheConceptUserId_1, toTheConceptId_1, typeId_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConceptId, ofTheConceptUserId, toTheConceptId, typeId, orderId = 1, accessId = 4) {\n        if (ofTheConceptId > 0 && toTheConceptId > 0) {\n            var userId = ofTheConceptUserId;\n            var id = yield ReservedConnectionIds.getId();\n            var connection = new Connection(id, ofTheConceptId, toTheConceptId, userId, typeId, orderId, accessId);\n            if (ofTheConceptId == toTheConceptId) {\n                connection.ofTheConceptId = 0;\n                connection.toTheConceptId = 1;\n                return connection;\n            }\n            // this will cause the connection to go and update the existing with the reserved id\n            connection.toUpdate = true;\n            connection.isTemp = false;\n            SyncData.AddConnection(connection);\n            return connection;\n        }\n        else {\n            throw new FreeSchemaResponse(\"cannot create connection because id are negative \", false, 400, \"\");\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DeleteTheConcept from \"../Api/DeleteTheConcept\";\nimport { BinaryCharacterTree } from \"../DataStructures/BinaryCharacterTree\";\nimport { BinaryTree } from \"../DataStructures/BinaryTree\";\nimport { BinaryTypeTree } from \"../DataStructures/BinaryTypeTree\";\nimport { ConnectionOfTheTree } from \"../DataStructures/ConnectionBinaryTree/ConnectionOfTheTree\";\nimport GetTheConcept from \"./GetTheConcept\";\nexport function DeleteConceptById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var concept = yield GetTheConcept(id);\n        var typeId = concept.typeId;\n        var character = concept.characterValue;\n        yield BinaryTypeTree.removeTypeConcept(typeId, id);\n        yield BinaryCharacterTree.removeNodeByCharacter(character, id);\n        //removeFromDatabase(\"concept\",id);\n        yield DeleteTheConcept(id);\n        yield BinaryTree.removeNodeFromTree(id);\n        yield ConnectionOfTheTree.removeNodeFromTree(id);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DeleteTheConnection from \"../Api/DeleteTheConnection\";\nimport { ConnectionBinaryTree } from \"../DataStructures/ConnectionBinaryTree/ConnectionBinaryTree\";\nimport { ConnectionTypeTree } from \"../DataStructures/ConnectionBinaryTree/ConnectionTypeTree\";\nimport { GetConnectionById } from \"./GetConnections\";\nexport function DeleteConnectionById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connection = yield GetConnectionById(id);\n        yield DeleteTheConnection(id);\n        //removeFromDatabase(\"connection\",id);\n        ConnectionBinaryTree.removeNodeFromTree(id);\n        ConnectionTypeTree.removeTypeConcept(connection.typeId, id);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptBulk } from \"../Api/GetConceptBulk\";\n/**\n * This function takes in a list of connections and in bulk gets the concepts that are related with these connections.\n * @param connectionList list of connections whose concepts need to be found out.\n */\nexport function FindConceptsFromConnections() {\n    return __awaiter(this, arguments, void 0, function* (connectionList = []) {\n        let ConceptList = [];\n        if (connectionList.length > 0) {\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!ConceptList.includes(connectionList[i].ofTheConceptId)) {\n                    ConceptList.push(connectionList[i].ofTheConceptId);\n                }\n                if (!ConceptList.includes(connectionList[i].toTheConceptId)) {\n                    ConceptList.push(connectionList[i].toTheConceptId);\n                }\n            }\n            yield GetConceptBulk(ConceptList);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nexport function FindConnectionsOfCompositionsBulkInMemory() {\n    return __awaiter(this, arguments, void 0, function* (composition_ids = []) {\n        let FinalConnectionList = [];\n        for (let i = 0; i < composition_ids.length; i++) {\n            // let connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(composition_ids[i]);\n            let connectionList = yield ConnectionData.GetConnectionsOfConcept(composition_ids[i]);\n            FinalConnectionList.push(...connectionList);\n        }\n        return FinalConnectionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConcept } from \"../Api/GetConcept\";\nimport { GetAllConnectionsOfComposition } from \"../Api/GetAllConnectionsOfComposition\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { GetTheConcept } from \"../app\";\nexport function GetCompositionById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        return { \"connectionList\": connectionList, \"compositionList\": compositionList };\n    });\n}\n/**\n * ## format JUSTDATA ##\n * this function builds the composition with the main id as the point of building.\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function RecursiveFetchBuildLayer(id, connectionList, compositionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let returnOutput = {};\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ## format DATAID ##\n * this function builds the composition with the main id as the point of building.\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function RecursiveFetchBuildLayerDataId(id, connectionList, compositionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let returnOutput = {};\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ## format Normal ##\n * this function builds the composition with the main id as the point of building.\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function RecursiveFetchBuildLayerNormal(id, connectionList, compositionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let returnOutput = {};\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConceptNormal(concept, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ## format JUSTDATA ##\n * this function builds the composition with the main id as the point of building.\n * This just requires the id\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function GetComposition(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        console.log(\"this is the connection list online\", connectionList);\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\nexport function GetCompositionWithAllIds(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchWithSubCompositions(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ### Format JUSTDATA ###\n * This function just builds data from the memory.\n * This is a function that takes on all the concepts and connections of the concept (as a composition ) and builds\n * it into a json data.\n * @param id this id is just used to get all the composition data from the concepts and connections in memory\n * @returns\n */\nexport function GetCompositionFromMemory(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        connectionList = yield ConnectionData.GetConnectionsOfConcept(id);\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(id);\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConcept(concept, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ### Format Normal ###\n * This function just builds data from the memory.\n * This is a function that takes on all the concepts and connections of the concept (as a composition ) and builds\n * it into a json data.\n * @param id this id is just used to get all the composition data from the concepts and connections in memory\n * @returns\n */\nexport function GetCompositionFromMemoryNormal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        connectionList = yield ConnectionData.GetConnectionsOfConcept(id);\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(id);\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        console.log(\"this is the connection list that you build\", connectionList);\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConceptNormal(concept, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        console.log(\"this is the output of memory normal\", returnOutput);\n        return returnOutput;\n    });\n}\n/**\n * ### Format DATAIDDATE ####\n * Gets data just from memory\n * @param id\n * @returns\n */\nexport function GetCompositionWithIdFromMemory(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        connectionList = yield ConnectionData.GetConnectionsOfConcept(id);\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            console.log(\"this concept you cannot find \", id);\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConcept(concept, connectionList, compositionList);\n        // let output = await recursiveFetchConceptSingleLoop(concept, connectionList,compositionList );\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ### Format DATAIDDATE ####\n * ### experimental ####\n * This is the new format that needs to work with a single or max two loops\n * @param id the id whose composition needs to be created\n * @returns\n */\nexport function GetCompositionWithIdFromMemoryNew(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        connectionList = yield ConnectionData.GetConnectionsOfConcept(id);\n        // connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            console.log(\"this concept you cannot find \", id);\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let startTime = new Date().getTime();\n        //console.log(\"this is the connection list which has to be looped\", connectionList);\n        let output = yield recursiveFetchConceptSingleLoop(concept, connectionList, compositionList);\n        console.log(\"this is the time for the data to be made\", new Date().getTime() - startTime);\n        // let output = await recursiveFetchConceptSingleLoop(concept, connectionList,compositionList );\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput = output;\n        let FinalReturn = {};\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ### Format DATAIDDATE #####\n * ### This just returns composition from memory and not from anywhere else.\n * @param id\n * @returns\n */\nexport function GetCompositionWithIdAndDateFromMemory(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(id);\n        connectionList = yield ConnectionData.GetConnectionsOfConcept(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        return FinalReturn;\n    });\n}\nexport function GetCompositionWithIdFromMemoryFromConnections(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList = []) {\n        var _a, _b;\n        let returnOutput = {};\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * #### Format DATAID ####\n * ## This will return the composition even if it is not in the local memory ##\n * @param id\n * @returns\n */\nexport function GetCompositionWithId(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ## Format justdata ###\n * ## This contains a concept in the parameter so that you dont have to again find the concept ##\n * This function takes concepts and connections and then builds a json.\n * @param concept The concept that needs to get other concepts that are inside of it.\n * @param connectionList List of connections that are available in the composition. We have to loop over it.\n * @param compositionList Composition list is the list of concepts that have connections inside of them.\n * @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.\n * @returns\n */\nexport function recursiveFetchConcept(concept_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        let id = concept.id;\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    if (id != connectionList[i].toTheConceptId) {\n                        let toConceptId = connectionList[i].toTheConceptId;\n                        let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                        if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                            let conceptString = yield GetConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                let toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                    let conceptString = yield GetConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        let regex = \"the_\";\n                        let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                        let localKey = localmainString.replace(regex, \"\");\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                    else {\n                        console.log(\"this is the faulty connection \", connectionList[i]);\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n/**\n* ## Format Normal ###\n* ## This contains a concept in the parameter so that you dont have to again find the concept ##\n* This function takes concepts and connections and then builds a json.\n* @param concept The concept that needs to get other concepts that are inside of it.\n* @param connectionList List of connections that are available in the composition. We have to loop over it.\n* @param compositionList Composition list is the list of concepts that have connections inside of them.\n* @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.\n* @returns\n*/\nexport function recursiveFetchConceptNormal(concept_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let startTime = new Date().getTime();\n        let output = {};\n        let arroutput = [];\n        let id = concept.id;\n        output[\"id\"] = id;\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    if (id != connectionList[i].toTheConceptId) {\n                        let toConceptId = connectionList[i].toTheConceptId;\n                        let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                        if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                            let conceptString = yield GetConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                let toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                    let conceptString = yield GetConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        let regex = \"the_\";\n                        let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                        let localKey = localmainString.replace(regex, \"\");\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                    else {\n                        console.log(\"this is the faulty connection \", connectionList[i]);\n                    }\n                }\n            }\n        }\n        // console.log(\"second loop normal\", new Date().getTime() - startTime);\n        return output;\n    });\n}\n/**\n * ## experimental ##\n* This function takes concepts and connections and then builds a json.\n* @param concept The concept that needs to get other concepts that are inside of it.\n* @param connectionList List of connections that are available in the composition. We have to loop over it.\n* @param compositionList Composition list is the list of concepts that have connections inside of them.\n* @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.\n* @returns\n*/\nexport function recursiveFetchConceptSingleLoop(concept_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let output = {};\n        let id = concept.id;\n        let startTime = new Date().getTime();\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            let myString = mainString;\n            let returnoutput = { [myString]: concept === null || concept === void 0 ? void 0 : concept.characterValue };\n            return returnoutput;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                let newData = yield GetTheConcept(connectionList[i].ofTheConceptId);\n                let toConcept = yield GetTheConcept(connectionList[i].toTheConceptId);\n                connectionList[i].ofConcept = newData;\n                connectionList[i].toConcept = toConcept;\n                let ofKey = newData.id;\n                let toConceptKey = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                let regex = \"the_\";\n                let localmainString = toConceptKey;\n                let localToKey = localmainString.replace(regex, \"\");\n                if (output[ofKey] == undefined || output[ofKey] == null) {\n                    output[ofKey] = {};\n                }\n                output[ofKey][localToKey] = toConcept.characterValue;\n            }\n        }\n        let finalOutput = {};\n        for (let i = 0; i < connectionList.length; i++) {\n            let ofConcept = connectionList[i].ofConcept;\n            let toConcept = connectionList[i].toConcept;\n            let ofConceptKey = (_f = (_e = ofConcept === null || ofConcept === void 0 ? void 0 : ofConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) !== null && _f !== void 0 ? _f : \"\";\n            let toConceptKey = (_h = (_g = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _g === void 0 ? void 0 : _g.characterValue) !== null && _h !== void 0 ? _h : \"\";\n            let regex = \"the_\";\n            let localmainString = toConceptKey;\n            let localToKey = localmainString.replace(regex, \"\");\n            if (finalOutput[ofConcept.id] == undefined || finalOutput[ofConcept.id] == null) {\n                finalOutput[ofConcept.id] = {};\n            }\n            let internalOutput = finalOutput[ofConcept.id];\n            if (internalOutput[ofConceptKey] == undefined || internalOutput[ofConceptKey] == null) {\n                internalOutput[ofConceptKey] = {};\n            }\n            if (output[connectionList[i].ofTheConceptId] != undefined && output[connectionList[i].toTheConceptId] != undefined) {\n                internalOutput[ofConceptKey][localToKey] = output[toConcept.id];\n            }\n            else {\n                internalOutput[ofConceptKey][localToKey] = toConcept.characterValue;\n            }\n        }\n        return finalOutput[concept.id];\n    });\n}\n/**\n * ## Format justdata ##\n * @param id\n * @param connectionList\n * @param compositionList\n * @param visitedConcepts\n * @returns\n */\nexport function recursiveFetch(id_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        if (id == 0) {\n            return null;\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (concept.id != 0) {\n            if (concept.type == null) {\n                let toConceptTypeId = concept.typeId;\n                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                concept.type = toConceptType;\n                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                    let conceptString = yield GetConcept(toConceptTypeId);\n                    toConceptType = conceptString;\n                    concept.type = toConceptType;\n                }\n            }\n        }\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                let insideTime = new Date().getTime();\n                if (connectionList[i].ofTheConceptId == id) {\n                    if (id != connectionList[i].toTheConceptId) {\n                        let toConceptId = connectionList[i].toTheConceptId;\n                        let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                        if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                            let conceptString = yield GetConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                let toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                    let conceptString = yield GetConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        let regex = \"the_\";\n                        let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                        let localKey = localmainString.replace(regex, \"\");\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetch(toConceptId, connectionList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            const result = yield recursiveFetch(toConceptId, connectionList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                    else {\n                        console.log(\"this is the faulty connection \", connectionList[i]);\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\nexport function recursiveFetchWithSubCompositions(id_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        if (id == 0) {\n            return null;\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (concept.id != 0) {\n            if (concept.type == null) {\n                let toConceptTypeId = concept.typeId;\n                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                concept.type = toConceptType;\n                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                    let conceptString = yield GetConcept(toConceptTypeId);\n                    toConceptType = conceptString;\n                    concept.type = toConceptType;\n                }\n            }\n        }\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            output[\"id\"] = id;\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    let toConceptId = connectionList[i].toTheConceptId;\n                    let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                    if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                        let conceptString = yield GetConcept(toConceptId);\n                        toConcept = conceptString;\n                    }\n                    if (toConcept) {\n                        if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                            let toConceptTypeId = toConcept.typeId;\n                            let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                            toConcept.type = toConceptType;\n                            if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                let conceptString = yield GetConcept(toConceptTypeId);\n                                toConceptType = conceptString;\n                                toConcept.type = toConceptType;\n                            }\n                        }\n                    }\n                    let regex = \"the_\";\n                    let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                    let localKey = localmainString.replace(regex, \"\");\n                    if (isNaN(Number(localKey))) {\n                        if (localKey) {\n                            const result = yield recursiveFetchWithSubCompositions(toConceptId, connectionList, compositionList);\n                            output[localKey] = result;\n                        }\n                    }\n                    else {\n                        const result = yield recursiveFetchWithSubCompositions(toConceptId, connectionList, compositionList);\n                        arroutput[localKey] = result;\n                        output = arroutput;\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nimport { GetConnectionBulk } from \"../Api/GetConnectionBulk\";\nimport { ConnectionData, GetConceptBulk } from \"../app\";\nimport { CheckForConnectionDeletionWithIds } from \"./CheckForConnectionDeletion\";\nimport { FindConnectionsOfCompositionsBulkInMemory } from \"./FindConnectionsOfCompositionBulkInMemory\";\nimport { GetCompositionFromMemory, GetCompositionFromMemoryNormal, GetCompositionWithIdFromMemory, GetCompositionWithIdFromMemoryNew } from \"./GetComposition\";\n/**\n * ## Format JUSTDATA ##\n * Function converts the conceptIds to json (compositions)\n * This function takes in the conceptIds and returns a list of compositions related to those concepts.\n * @param conceptIds  list of concept ids that are compositions.\n * @returns compositions\n */\nexport function GetCompositionBulk() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = []) {\n        yield GetAllConnectionsOfCompositionBulk(conceptIds);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemory(conceptIds[i]);\n            compositions.push(comp);\n        }\n        return compositions;\n    });\n}\n/**\n * ## FORMAT DATAIDDATE ##\n * Function converts the conceptIds to json (compositions)\n * @param conceptIds this is the list of concept ids that should be converted to compostions in data - id format.\n * @returns list of compositions in the data - id format.\n */\nexport function GetCompositionBulkWithDataId() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = []) {\n        yield GetAllConnectionsOfCompositionBulk(conceptIds);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions.push(comp);\n        }\n        return compositions;\n    });\n}\n/**\n * ## FORMAT DATAIDDATE ##\n * This function converts the conceptIds and internal connectionIds to compositions in data-Id format.\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns list of compositions created from the passed conceptIds and connectionIds.\n */\nexport function GetCompositionFromConnectionsWithDataId() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        let oldConnections = yield FindConnectionsOfCompositionsBulkInMemory(conceptIds);\n        CheckForConnectionDeletionWithIds(connectionIds, oldConnections);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions.push(comp);\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format DATAIDDATE ##\n * This function converts the conceptIds and internal connectionIds to compositions in data-Id format with index(conceptId).\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns dictionary of compositions created from the passed conceptIds and connectionIds with conceptId as its index .\n */\nexport function GetCompositionFromConnectionsWithDataIdIndex() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        let myNewConnections = newConnections;\n        let oldConnections = yield FindConnectionsOfCompositionsBulkInMemory(conceptIds);\n        CheckForConnectionDeletionWithIds(connectionIds, oldConnections);\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format is dictionary with key as concept id and value as data (json) ##\n * This function converts the conceptIds and internal connectionIds to compositions format with index(conceptId).\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns dictionary of compositions created from the passed conceptIds and connectionIds with conceptId as its index .\n */\nexport function GetCompositionFromConnectionsWithIndex() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        let myNewConnections = newConnections;\n        let oldConnections = yield FindConnectionsOfCompositionsBulkInMemory(conceptIds);\n        CheckForConnectionDeletionWithIds(connectionIds, oldConnections);\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemory(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * Used to prefetch all the connections and their related concepts.\n * @param connectionIds these are the connection ids that are used to fetch all the connections and also their related concepts.\n * @returns all the connections that are passed as ids.\n */\nexport function GetConnectionDataPrefetch(connectionIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let remainingConnections = [];\n        let connectionsAll = [];\n        let remainingIds = {};\n        for (let i = 0; i < connectionIds.length; i++) {\n            let connection = yield ConnectionData.GetConnection(connectionIds[i]);\n            // console.log(\"this is the connection fetch\", connection);\n            if (connection.id == 0) {\n                remainingConnections.push(connectionIds[i]);\n            }\n            else {\n                connectionsAll.push(connection);\n            }\n        }\n        for (let i = 0; i < connectionIds.length; i++) {\n            remainingIds[connectionIds[i]] = false;\n        }\n        //await ConnectionData.GetConnectionBulkData(connectionIds, connectionsAll, remainingIds);\n        // for(let key in remainingIds){\n        //     if(remainingIds[key] == false){\n        //         remainingConnections.push(Number(key));\n        //     }\n        // }\n        // remainingConnections = connectionIds;\n        let prefetchConcepts = [];\n        let connectionsAllLocal = yield GetConnectionBulk(remainingConnections);\n        connectionsAll = [...connectionsAll, ...connectionsAllLocal];\n        for (let j = 0; j < connectionsAll.length; j++) {\n            prefetchConcepts.push(connectionsAll[j].ofTheConceptId);\n            prefetchConcepts.push(connectionsAll[j].toTheConceptId);\n        }\n        yield GetConceptBulk(prefetchConcepts);\n        return connectionsAll;\n    });\n}\n/**\n * ## Format DATAIDDATE ##\n * This function converts the conceptIds and internal connections to create compositions.\n * Format is of a dictionary with ids as the key and value is the composition data.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsWithDataIdInObject() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format DATAIDDATE ##\n * ## duplicate ##\n * This function converts the conceptIds and internal connections to create compositions.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsWithDataIdInObjectNew() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemoryNew(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format justdata ##\n * This function converts the conceptIds and internal connections to create compositions.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsInObject() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemory(conceptIds[i]);\n            console.log(\"this is the comp\", comp);\n            compositions[conceptIds[i]] = comp;\n        }\n        console.log(\"This is the composition list\", compositions);\n        return compositions;\n    });\n}\n/**\n * ## Format Normal ##\n * This function converts the conceptIds and internal connections to create compositions.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsInObjectNormal() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemoryNormal(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConceptsByType } from \"../Api/GetAllConceptsByType\";\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { LocalConceptsData } from \"../DataStructures/Local/LocalConceptData\";\nimport { GetCompositionListLocal, GetCompositionLocalWithId } from \"../app\";\nimport { GetCompositionFromMemory, GetCompositionWithIdFromMemory } from \"./GetComposition\";\nimport GetConceptByCharacter, { GetConceptByCharacterUpdated } from \"./GetConceptByCharacter\";\nimport GetConceptByCharacterLocal from \"./Local/GetConceptByCharacterLocal\";\n// get the list of compositions from the type \n// for eg get list of boomgpt\nexport function GetCompositionList(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        let concept = yield GetConceptByCharacter(compositionName);\n        let CompositionList = [];\n        if (concept) {\n            yield GetAllConceptsByType(compositionName, userId);\n            let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n            let startPage = inpage * (page - 1);\n            let prefetchComposition = [];\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    prefetchComposition.push(conceptList[i].id);\n                }\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    let compositionJson = yield GetCompositionFromMemory(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n        }\n        return CompositionList;\n    });\n}\nexport function GetCompositionListAll(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        let LocalCompositionList = GetCompositionListLocal(compositionName, userId);\n        let CompositionList = GetCompositionList(compositionName, userId);\n        let AllList = [];\n        Promise.race([LocalCompositionList, CompositionList])\n            .then((result) => {\n            console.log(\"Promise result\", result);\n            AllList.push(...result);\n        })\n            .catch((error) => {\n            console.log(\"error in handling\", error);\n        });\n        CompositionList.then((result) => {\n            console.log(\"This is the second promise result\", result);\n            AllList.push(...result);\n        });\n        return AllList;\n    });\n}\n// export async function GetCompositionListAllWithId(compositionName: string,userId:number,  inpage:number = 10, page:number =1){\n//    let LocalCompositionList =  await GetCompositionListLocalWithId(compositionName, userId);\n//    console.log(\"tbis is the local composition list\", LocalCompositionList);\n//    let CompositionList =    await GetCompositionListWithId(compositionName,userId)\n//    console.log(\"this is the online composition list\", CompositionList);\n//    let AllList: any[] = [];\n//    // Promise.race([LocalCompositionList, CompositionList])\n//    // .then((result)=> {\n//    //    console.log(\"Promise result\", result);\n//    //    AllList.push(...result);\n//    // })\n//    // .catch((error)=>{\n//    //    console.log(\"error in handling\", error);\n//    // });\n//    // CompositionList.then((result)=>{\n//    //    console.log(\"This is the second promise result\", result);\n//    //    AllList.push(...result);\n//    // })\n//    AllList.push(...LocalCompositionList);\n//    AllList.push(...CompositionList);\n//    return AllList;\n// }\nexport function GetCompositionListAllWithId(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        let conceptLocal = yield GetConceptByCharacterLocal(compositionName);\n        let conceptOnline = yield GetConceptByCharacter(compositionName);\n        let CompositionList = [];\n        let conceptList = [];\n        let conceptListLocal = [];\n        let finalLocal = [];\n        let conceptListOnline = [];\n        if (conceptLocal.id != 0) {\n            conceptListLocal = yield LocalConceptsData.GetConceptsByTypeIdAndUser(conceptLocal.id, userId);\n        }\n        if (conceptOnline.id != 0) {\n            yield GetAllConceptsByType(compositionName, userId);\n            conceptListOnline = yield ConceptsData.GetConceptsByTypeIdAndUser(conceptOnline.id, userId);\n            conceptList = conceptListOnline;\n        }\n        for (let i = 0; i < conceptListLocal.length; i++) {\n            let isDuplicate = false;\n            for (let j = 0; j < conceptListOnline.length; j++) {\n                if (conceptListLocal[i].ghostId == conceptListOnline[j].ghostId) {\n                    isDuplicate = true;\n                }\n            }\n            if (!isDuplicate) {\n                finalLocal.push(conceptListLocal[i]);\n            }\n        }\n        console.log(\"This is the all list\", finalLocal);\n        let AllList = [];\n        AllList = yield FormatTheConcepts(conceptList, finalLocal, inpage, page);\n        return AllList;\n    });\n}\nexport function GetCompositionListWithId(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        let concept = yield GetConceptByCharacter(compositionName);\n        let CompositionList = [];\n        if (concept) {\n            yield GetAllConceptsByType(compositionName, userId);\n            let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n            let startPage = inpage * (page - 1);\n            let prefetchComposition = [];\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    prefetchComposition.push(conceptList[i].id);\n                }\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    let compositionJson = yield GetCompositionWithIdFromMemory(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n        }\n        return CompositionList;\n    });\n}\nexport function GetCompositionListWithIdUpdated(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        let concept = yield GetConceptByCharacterUpdated(compositionName);\n        let CompositionList = [];\n        if (concept) {\n            yield GetAllConceptsByType(compositionName, userId);\n            let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n            let startPage = inpage * (page - 1);\n            let prefetchComposition = [];\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    prefetchComposition.push(conceptList[i].id);\n                }\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    let compositionJson = yield GetCompositionWithIdFromMemory(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n        }\n        return CompositionList;\n    });\n}\nexport function FormatTheConcepts(conceptList_1, localConceptList_1) {\n    return __awaiter(this, arguments, void 0, function* (conceptList, localConceptList, inpage = 10, page = 1) {\n        let CompositionList = [];\n        let startPage = inpage * (page - 1);\n        let prefetchComposition = [];\n        let localConceptLength = localConceptList.length;\n        for (let i = startPage; i < startPage + inpage - localConceptLength; i++) {\n            if (conceptList[i]) {\n                prefetchComposition.push(conceptList[i].id);\n            }\n        }\n        for (let i = 0; i < localConceptList.length; i++) {\n            let compositionJson = yield GetCompositionLocalWithId(localConceptList[i].id);\n            CompositionList.push(compositionJson);\n        }\n        yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n        for (let i = startPage; i < startPage + inpage - localConceptLength; i++) {\n            if (conceptList[i]) {\n                let compositionJson = yield GetCompositionWithIdFromMemory(conceptList[i].id);\n                CompositionList.push(compositionJson);\n            }\n        }\n        return CompositionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterValue } from \"../Api/GetConceptByCharacterValue\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nexport default function GetConceptByCharacter(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n        let literalCharacter = `${characterValue}`;\n        if ((concept == null || (concept === null || concept === void 0 ? void 0 : concept.id) == 0) && literalCharacter) {\n            yield GetConceptByCharacterValue(characterValue);\n            concept = yield ConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, 51);\n            if (concept.id == 0) {\n                concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n            }\n        }\n        return concept;\n    });\n}\nexport function GetConceptByCharacterUpdated(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n        let literalCharacter = `${characterValue}`;\n        if ((concept == null || (concept === null || concept === void 0 ? void 0 : concept.id) == 0) && literalCharacter) {\n            yield GetConceptByCharacterValue(characterValue);\n            concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetCompositionConnectionsBetweenTwoConcepts } from \"../Api/GetCompositionConnectionsBetweenTwoConcepts\";\nimport { CreateDefaultConcept, MakeTheTypeConceptApi } from \"../app\";\nimport MakeTheInstanceConcept from \"./MakeTheInstanceConcept\";\n/**\n * This function will give you all the connections between two concepts by their linker or fullLinker\n * @param ofTheConcept start of the connecction\n * @param toTheConcept end of the connection\n * @param linker the primitive linkers with type connection (16) these are the old type of linkers (if you want full linker then put this as empty string)\n * @param fullLinker fullLinker is the modern linker (if you want linker then put this as empty string)\n * @param forward if you want to get the forward relation in the primitive linker put true else for backward linker false.\n * @returns list of connections\n */\nexport function GetConnectionBetweenTwoConceptsLinker(ofTheConcept_1, toTheConcept_1, linker_1, fullLinker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, fullLinker, forward = true) {\n        var _a, _b;\n        let typeConcept = CreateDefaultConcept();\n        if (linker != \"\") {\n            let typeLinker = \"\";\n            if (forward) {\n                let prefix = ((_a = ofTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\";\n                let linkerAdd = linker + \"_s\";\n                let forwardLinker = prefix + \"_\" + linkerAdd;\n                typeLinker = forwardLinker;\n            }\n            else {\n                let prefix1 = ((_b = toTheConcept.type) === null || _b === void 0 ? void 0 : _b.characterValue) + \"_s\";\n                let linkerAdd1 = linker + \"_by\";\n                let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n                typeLinker = backwardLinker;\n            }\n            typeConcept = yield MakeTheInstanceConcept(\"connection\", typeLinker, false, 999);\n        }\n        if (fullLinker != \"\") {\n            typeConcept = yield MakeTheTypeConceptApi(fullLinker, 999);\n        }\n        let connections = yield GetCompositionConnectionsBetweenTwoConcepts(ofTheConcept.id, toTheConcept.id, typeConcept.id);\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConnection } from \"../Api/GetConnection\";\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nexport function GetConnectionById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connection = yield ConnectionData.GetConnection(id);\n        if ((connection == null || connection.id == 0) && id != null && id != undefined) {\n            let connectionString = yield GetConnection(id);\n            connection = connectionString;\n        }\n        return connection;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { LocalConnectionData } from \"../DataStructures/Local/LocalConnectionData\";\nimport { getObjectsFromLocalIndexDb } from \"../Database/indexdblocal\";\nimport { getObjectsFromIndexDb } from \"../Database/indexeddb\";\nexport function GetConnectionsFromIndexDb() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let connectionList = yield getObjectsFromIndexDb(\"connection\");\n            if (Array.isArray(connectionList)) {\n                for (let i = 0; i < connectionList.length; i++) {\n                    ConnectionData.AddConnectionToMemory(connectionList[i]);\n                }\n            }\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot create Connection Binary Tree Concept\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            throw errorObject;\n        }\n    });\n}\nexport function GetConnectionsFromIndexDbLocal() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let connectionList = yield getObjectsFromLocalIndexDb(\"localconnection\");\n            if (Array.isArray(connectionList)) {\n                for (let i = 0; i < connectionList.length; i++) {\n                    LocalConnectionData.AddConnectionToMemory(connectionList[i]);\n                }\n            }\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot create Local Connection Binary Tree Concept\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            throw errorObject;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterAndType } from \"../Api/GetConceptByCharacterAndType\";\nimport { GetConnectionOfTheConcept } from \"../Api/GetConnectionOfTheConcept\";\nimport { GetCompositionWithIdAndDateFromMemory } from \"./GetComposition\";\nimport GetTheConcept from \"./GetTheConcept\";\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nexport function GetLink(id_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (id, linker, inpage = 10, page = 1) {\n        var _a;\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let linkString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + linker;\n        let relatedConceptString = yield GetConceptByCharacterAndType(linkString, 16);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetch);\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                output.push(newComposition);\n            }\n        }\n        return output;\n    });\n}\nexport function GetLinkRaw(id_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (id, linker, inpage = 10, page = 1) {\n        var _a;\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let linkString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + linker;\n        let relatedConceptString = yield GetConceptByCharacterAndType(linkString, 16);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                output.push(toConcept);\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllLinkerConnectionsFromTheConcept } from \"../Api/GetAllLinkerConnectionsFromTheConcept\";\nimport { GetAllLinkerConnectionsToTheConcept } from \"../Api/GetAllLinkerConnectionsToTheConcept\";\nimport GetTheConcept from \"./GetTheConcept\";\nexport function GetLinkerConnectionFromConcepts(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connections = yield GetAllLinkerConnectionsFromTheConcept(id);\n        for (let i = 0; i < connections.length; i++) {\n            let localConnection = connections[i];\n            let connectionIdentifier = localConnection.typeId;\n            let concept = yield GetTheConcept(connectionIdentifier);\n            localConnection.type = concept;\n        }\n        return connections;\n    });\n}\nexport function GetLinkerConnectionToConcepts(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connections = yield GetAllLinkerConnectionsToTheConcept(id);\n        for (let i = 0; i < connections.length; i++) {\n            let localConnection = connections[i];\n            let connectionIdentifier = localConnection.typeId;\n            let concept = yield GetTheConcept(connectionIdentifier);\n            localConnection.type = concept;\n        }\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConnectionOfTheConcept } from \"../Api/GetConnectionOfTheConcept\";\nimport { GetCompositionWithIdAndDateFromMemory } from \"./GetComposition\";\nimport GetTheConcept from \"./GetTheConcept\";\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nimport { GetConceptByCharacterAndCategory } from \"./ConceptFinding/GetConceptByCharacterAndCategory\";\nexport function GetRelation(id_1, relation_1) {\n    return __awaiter(this, arguments, void 0, function* (id, relation, inpage = 10, page = 1) {\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let relatedConceptString = yield GetConceptByCharacterAndCategory(relation);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetch);\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                output.push(newComposition);\n            }\n        }\n        return output;\n    });\n}\nexport function GetRelationRaw(id_1, relation_1) {\n    return __awaiter(this, arguments, void 0, function* (id, relation, inpage = 10, page = 1) {\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let relatedConceptString = yield GetConceptByCharacterAndCategory(relation);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                output.push(toConcept);\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConcept } from \"../Api/GetConcept\";\nimport { convertFromLConceptToConcept, GetUserGhostId } from \"../app\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\n/**\n *\n * @param id this is the id that can be used to get the concept.\n * @param userId This is the user that calls the concept\n * @returns Concept if it exists\n */\nexport default function GetTheConcept(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, userId = 999) {\n        try {\n            let concept = CreateDefaultConcept();\n            if (id < 0) {\n                let lconcept = yield GetUserGhostId(userId, id);\n                concept = convertFromLConceptToConcept(lconcept);\n                return concept;\n            }\n            concept = yield ConceptsData.GetConcept(id);\n            if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n                let conceptString = yield GetConcept(id);\n                concept = conceptString;\n            }\n            if (concept.id != 0) {\n                if (concept.type == null) {\n                    let conceptType = yield ConceptsData.GetConcept(concept.typeId);\n                    if (conceptType == null && concept.typeId != null && concept.typeId != undefined) {\n                        let typeConceptString = yield GetConcept(concept.typeId);\n                        let typeConcept = typeConceptString;\n                        concept.type = typeConcept;\n                    }\n                }\n            }\n            return concept;\n        }\n        catch (err) {\n            console.error(\"this is the error in the getting concept\", err);\n            throw err;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAiData } from \"../Api/GetAiData\";\nimport { SettingData } from \"../DataStructures/SettingData\";\nimport { Settings } from \"../DataStructures/Settings\";\nimport { AiUpdateFlag, GetLastSettingsFromDatabase, openDatabase } from \"../Database/indexeddb\";\nimport { openDatabase as localopenDb } from '../Database/indexdblocal';\nexport default function InitializeSystem() {\n    return __awaiter(this, arguments, void 0, function* (enableAi = true) {\n        try {\n            yield openDatabase(\"concepts\");\n            yield localopenDb(\"concepts\");\n            if (enableAi) {\n                var statsData = yield GetLastSettingsFromDatabase();\n                var settings = statsData;\n                if (settings.isOnlineSync) {\n                    return true;\n                }\n                yield GetAiData();\n            }\n            return true;\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"cannot initlize the AI system\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            console.log(errorObject);\n            return true;\n        }\n    });\n}\nexport function PurgatoryDatabaseUpdated() {\n    return __awaiter(this, void 0, void 0, function* () {\n        Settings.isOnlineSync = true;\n        var settingData = new SettingData(Settings.isOnlineSync);\n        AiUpdateFlag(settingData);\n    });\n}\n","import { Connection } from \"../../DataStructures/Connection\";\nexport function ConvertFromLConnectionToConnection(lconnection) {\n    let connection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    connection.ofTheConceptId = lconnection.ofTheConceptId;\n    connection.toTheConceptId = lconnection.toTheConceptId;\n    connection.typeId = lconnection.typeId;\n    connection.orderId = lconnection.orderId;\n    connection.id = lconnection.id;\n    return connection;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheConnectionLocal, MakeTheInstanceConceptLocal } from \"../../app\";\nexport function CreateConnectionBetweenTwoConceptsLocal(ofTheConcept_1, toTheConcept_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, both = false) {\n        var _a, _b;\n        try {\n            var userId = ofTheConcept.userId;\n            if (both) {\n                let prefix1 = ((_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\";\n                let linkerAdd1 = linker + \"_by\";\n                let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n                // if(count){\n                //    await CountRelationship(linkerAdd1, toTheConcept, userId);\n                //   }\n                var connectionConceptReverse = yield MakeTheInstanceConceptLocal(\"connection\", backwardLinker, false, 999, 999, 999);\n                let pewCon = yield CreateTheConnectionLocal(toTheConcept.id, ofTheConcept.id, connectionConceptReverse.id, 1000);\n            }\n            let prefix = ((_b = ofTheConcept.type) === null || _b === void 0 ? void 0 : _b.characterValue) + \"_s\";\n            let linkerAdd = linker + \"_s\";\n            let forwardLinker = prefix + \"_\" + linkerAdd;\n            // if(count){\n            // // await CountRelationship(linkerAdd, ofTheConcept, userId);\n            // }\n            var connectionConcept = yield MakeTheInstanceConceptLocal(\"connection\", forwardLinker, false, 999, 999, 999);\n            let newConnection = yield CreateTheConnectionLocal(ofTheConcept.id, toTheConcept.id, connectionConcept.id, 1000);\n            return newConnection;\n        }\n        catch (ex) {\n            throw ex;\n        }\n    });\n}\n","import { Concept } from \"../../DataStructures/Concept\";\nexport function CreateDefaultLConcept() {\n    let created_on = new Date();\n    let updated_on = new Date();\n    let concept = new Concept(0, 0, 0, 0, 0, \"0\", 0, false, created_on, updated_on, \"0\");\n    return concept;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../../DataStructures/IdentifierFlags\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalId } from \"../../DataStructures/Local/LocalId\";\nimport { getObjectsFromLocalIndexDb, UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { BaseUrl, DelayFunctionExecution } from \"../../app\";\n/**\n * This will create a binary tree of local concepts that is saved from the indexdb.\n */\nexport default function CreateLocalBinaryTreeFromIndexDb() {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"this is trying to create local binary tree\");\n        try {\n            let conceptList = yield getObjectsFromLocalIndexDb(\"localconcept\");\n            if (Array.isArray(conceptList)) {\n                for (let i = 0; i < conceptList.length; i++) {\n                    let concept = conceptList[i];\n                    LocalConceptsData.AddConceptToMemory(concept);\n                }\n            }\n            IdentifierFlags.isLocalDataLoaded = true;\n            IdentifierFlags.isLocalTypeLoaded = true;\n            IdentifierFlags.isLocalCharacterLoaded = true;\n        }\n        catch (error) {\n            yield DelayFunctionExecution(2000, CreateLocalBinaryTreeFromIndexDb());\n            let errorObject = {\n                \"message\": \"Cannot create local binary tree from index db\",\n                \"data\": error,\n                \"ok\": false,\n                \"status\": 400\n            };\n            throw errorObject;\n        }\n    });\n}\n/**\n * We have designed our system to use local concepts and connections with its own local ids(negative ids) that\n * is only valid for the browser that creates this. We have a translator in our node server.\n * We cannot keep on using the indexdb to get the new data so we populate the data from indexdb to our memory\n * then we use these ids from memory and update the indexdb with the latest id frequently.\n * This function does this process in initlization from indexdb to memory.\n *\n * Here we have locked this function so that other processes cannot access this process in the case that this process is ongoing\n *\n *\n */\nexport function PopulateTheLocalConceptsToMemory() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // put a lock on the indexdb for the domain so that no two things do this same process.\n            yield navigator.locks.request(\"dblock\", (lock) => __awaiter(this, void 0, void 0, function* () {\n                // get the last local concept id(-ve) from the indexdb\n                let idList = yield getObjectsFromLocalIndexDb(\"localid\");\n                // if the list is valid then.\n                if (Array.isArray(idList)) {\n                    // if the zeroth component that is the concept component is present\n                    if (idList[0]) {\n                        // if the zeroth component (concept component) has a valid value;\n                        let localConceptIdValue = idList[0].value;\n                        if (localConceptIdValue) {\n                            // add the new concept id to the memory\n                            LocalId.AddConceptId(idList[0]);\n                            // update the indexdb with the new concept value that other programs can use and\n                            // reserve the 10 ids for this program.\n                            yield UpdateToDatabase(\"localid\", { \"id\": 0, \"value\": localConceptIdValue - 10 });\n                        }\n                        else {\n                            // incase there is invalid id then choose a random id .\n                            localConceptIdValue = -Math.floor(Math.random() * 100000000);\n                            let object = { \"id\": 0, \"value\": localConceptIdValue };\n                            let newObject = { \"id\": 0, \"value\": localConceptIdValue - 10 };\n                            LocalId.AddConceptId(object);\n                            yield UpdateToDatabase(\"localid\", newObject);\n                        }\n                    }\n                    if (idList[2]) {\n                        BaseUrl.BASE_RANDOMIZER = idList[2].value;\n                    }\n                }\n            }));\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot populate Local Ids from the Index Db\",\n                \"data\": error,\n                \"ok\": false,\n                \"status\": 400\n            };\n            throw errorObject;\n        }\n    });\n}\n/**\n* We have designed our system to use local concepts and connections with its own local ids(negative ids) that\n* is only valid for the browser that creates this. We have a translator in our node server.\n* We cannot keep on using the indexdb to get the new data so we populate the data from indexdb to our memory\n* then we use these ids from memory and update the indexdb with the latest id frequently.\n* This function does this process in initlization from indexdb to memory.\n*\n* This function locked so that no two parallel process can access this functionality at the same time.\n* That might cause some ids to be repeated.\n*\n*\n*/\nexport function PopulateTheLocalConnectionToMemory() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // put a lock on the indexdb for the domain so that no two things do this same process.\n            yield navigator.locks.request(\"dblock\", (lock) => __awaiter(this, void 0, void 0, function* () {\n                let idList = yield getObjectsFromLocalIndexDb(\"localid\");\n                if (Array.isArray(idList)) {\n                    if (idList[1]) {\n                        let localConnectionId = idList[1].value;\n                        if (localConnectionId) {\n                            LocalId.AddConnectionId(idList[1]);\n                            yield UpdateToDatabase(\"localid\", { \"id\": 1, \"value\": localConnectionId - 10 });\n                        }\n                        else {\n                            // incase there is invalid id then choose a random id .\n                            localConnectionId = -Math.floor(Math.random() * 100000000);\n                            let object = { \"id\": 0, \"value\": localConnectionId };\n                            let newObject = { \"id\": 0, \"value\": localConnectionId - 10 };\n                            LocalId.AddConnectionId(object);\n                            yield UpdateToDatabase(\"localid\", newObject);\n                        }\n                    }\n                    if (idList[2]) {\n                        BaseUrl.BASE_RANDOMIZER = idList[2].value;\n                    }\n                }\n            }));\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot populate Local Ids from the Index Db\",\n                \"data\": error,\n                \"ok\": false,\n                \"status\": 400\n            };\n            throw errorObject;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateDefaultLConcept } from \"../Local/CreateDefaultLConcept\";\nimport { CreateTheConnectionLocal } from \"./CreateTheConnectionLocal\";\nimport { MakeTheInstanceConceptLocal } from \"./MakeTheInstanceConceptLocal\";\n/**\n * This function converts a json data to concept connection and also preserves its relation.\n * @param json The json data that needs to be converted to the concept connection system\n * @param ofTheConceptId If in case that this composition is part of other composition then this must be the connecting concept.\n * @param ofTheConceptUserId If in case that this composition is part of other composition then this must be the user Id of the  connecting concept.\n * @param mainKey If in case that this composition is part of other composition then this must be the main composition\n * @param userId The user Id of the user creating the composition.\n * @param accessId The accessId of the user creating the composition.\n * @param sessionInformationId Session of the user.\n * @param automaticSync for future use.\n * @returns the main concept of this composition.\n */\nexport function CreateTheCompositionLocal(json_1) {\n    return __awaiter(this, arguments, void 0, function* (json, ofTheConceptId = null, ofTheConceptUserId = null, mainKey = null, userId = null, accessId = null, sessionInformationId = null, automaticSync = false) {\n        let localUserId = userId !== null && userId !== void 0 ? userId : 999;\n        let localAccessId = accessId !== null && accessId !== void 0 ? accessId : 999;\n        let localSessionId = sessionInformationId !== null && sessionInformationId !== void 0 ? sessionInformationId : 999;\n        let MainKeyLocal = mainKey !== null && mainKey !== void 0 ? mainKey : 0;\n        let MainConcept = CreateDefaultLConcept();\n        for (const key in json) {\n            if (typeof json[key] != 'string' && typeof json[key] != 'number') {\n                if (ofTheConceptId == null && ofTheConceptUserId == null) {\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConceptLocal(key, \"\", true, localUserId, localAccessId, localSessionId);\n                    let concept = conceptString;\n                    MainConcept = concept;\n                    localMainKey = concept.id;\n                    MainKeyLocal = concept.id;\n                    yield CreateTheCompositionLocal(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId);\n                }\n                else {\n                    let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                    let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConceptLocal(key, \"\", true, localUserId, localAccessId, localSessionId);\n                    let concept = conceptString;\n                    yield CreateTheConnectionLocal(ofThe, concept.id, localMainKey);\n                    yield CreateTheCompositionLocal(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId);\n                }\n            }\n            else {\n                let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                let localMainKey = MainKeyLocal;\n                let conceptString = yield MakeTheInstanceConceptLocal(key, json[key].toString(), false, localUserId, localAccessId, localSessionId);\n                let concept = conceptString;\n                yield CreateTheConnectionLocal(ofThe, concept.id, localMainKey);\n            }\n        }\n        return MainConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Concept } from \"../../DataStructures/Concept\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalId } from \"../../DataStructures/Local/LocalId\";\n/**\n * This function creates the concept in the local system (Local memory and IndexDb) but not in the backend database\n * To create this concept in the backend database you need to sync the local data to the backend by LocalSyncData class.\n *\n * This function creates a id and ghost id which are equal to each other.\n * These id and ghostId are negative which means that they are virtual concepts. After these concepts have been synced with the backend\n * they are converted to real id. After returning from the backend the id changes to positive(+) and real id while the ghostId remains the same\n *\n * The system then saves this relation between -ve id and real id in the backend server and also in the local memory.\n *\n * @param referent This is the string that is the actual value of the concept.\n * @param typecharacter The string that defines the type of the concept.\n * @param userId This is the userId of the creator.\n * @param categoryId This is the category Id of the concept.\n * @param typeId This is the type Id of the concept that relates to the typecharacter passed above.\n * @param accessId This is the accessId of the concept(most probably is the accessId of the user)\n * @param isComposition This is set in the case that the composition needs to be created.\n * @param referentId if this concept refers to any other concept then this needs to be passed.\n * @returns\n */\nexport default function CreateTheConceptLocal(referent_1, typecharacter_1, userId_1, categoryId_1, typeId_1, accessId_1) {\n    return __awaiter(this, arguments, void 0, function* (referent, typecharacter, userId, categoryId, typeId, accessId, isComposition = false, referentId = 0) {\n        try {\n            //let id = -Math.floor(Math.random() * 100000000);\n            let id = yield LocalId.getConceptId();\n            console.log(\"this is the getting id type connection\", id);\n            let isNew = true;\n            let created_on = new Date();\n            let updated_on = new Date();\n            if (referent == \"the\") {\n                let concept = new Concept(1, 999, 5, 5, referentId, referent, accessId, isNew, created_on, updated_on, typecharacter);\n                return concept;\n            }\n            let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typecharacter);\n            concept.isTemp = true;\n            concept.isComposition = isComposition;\n            LocalConceptsData.AddConcept(concept);\n            //storeToDatabase(\"localconcept\",concept);\n            return concept;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Connection } from \"../../DataStructures/Connection\";\nimport { LocalConnectionData } from \"../../DataStructures/Local/LocalConnectionData\";\nimport { LocalId } from \"../../DataStructures/Local/LocalId\";\nimport { LocalSyncData } from \"../../app\";\n/**\n * This function creates a connection for the concept connection system. This connection will only be created in real sense\n * once the data is synced using LocalSyncData.SyncDataOnline()\n * Here id and ghostId are created which are negative(these are virtual ids). After they are synced then they become real ids\n * The real ids are then associated with these ghost ids in node server (backend) and also in the local memory.\n * @param ofTheConceptId Of the concept Id for the connection\n * @param toTheConceptId To the concept Id for the connection\n * @param typeId Type of the connection, should be the composition id for internal connection and type concept in case\n * of external connection.\n * @param orderId current context is that for internal connections the order id is less than 3 and for external connections greater than 999\n * @param typeString this is the typeString in the case of external connections.\n * @returns a connection that is created and stored in the local system.\n */\nexport function CreateTheConnectionLocal(ofTheConceptId_1, toTheConceptId_1, typeId_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConceptId, toTheConceptId, typeId, orderId = 1, typeString = \"\", userId = 999) {\n        try {\n            let accessId = 4;\n            // let randomid = -Math.floor(Math.random() * 100000000);\n            let randomid = yield LocalId.getConnectionId();\n            let realOfTheConceptId = 0;\n            let realToTheConceptId = 0;\n            let realTypeId = 0;\n            realOfTheConceptId = ofTheConceptId;\n            realToTheConceptId = toTheConceptId;\n            realTypeId = typeId;\n            let connection = new Connection(0, 0, 0, 0, 0, 0, 0);\n            if (ofTheConceptId != toTheConceptId) {\n                connection = new Connection(randomid, realOfTheConceptId, realToTheConceptId, userId, typeId, orderId, accessId);\n                connection.isTemp = true;\n                connection.typeCharacter = typeString;\n                yield LocalSyncData.AddConnection(connection);\n                LocalConnectionData.AddConnection(connection);\n                //storeToDatabase(\"localconnection\", connection);\n            }\n            return connection;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { GetTheConceptLocal } from \"./GetTheConceptLocal\";\nexport function DeleteConceptLocal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield GetTheConceptLocal(id);\n        LocalConceptsData.RemoveConcept(concept);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { GetCompositionLocal, GetCompositionLocalWithId } from \"./GetCompositionLocal\";\nimport GetConceptByCharacterLocal from \"./GetConceptByCharacterLocal\";\n/**\n * This function returns the list of composition which have the type @param compositionName\n * @param compositionName The type of the composition to pull\n * @param userId User Id of the user trying to pull the list\n * @returns list of compositions.\n */\nexport function GetCompositionListLocal(compositionName, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let concept = yield GetConceptByCharacterLocal(compositionName);\n            let CompositionList = [];\n            if (concept.id != 0) {\n                let conceptList = yield LocalConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n                for (let i = 0; i < conceptList.length; i++) {\n                    let compositionJson = yield GetCompositionLocal(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n            return CompositionList;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n/**\n * This function returns the list of composition with data - id format which have the type @param compositionName\n * @param compositionName The type of the composition to pull\n * @param userId User Id of the user trying to pull the list\n * @returns list of compositions with data - id format.\n */\nexport function GetCompositionListLocalWithId(compositionName, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let concept = yield GetConceptByCharacterLocal(compositionName);\n            let CompositionList = [];\n            if (concept.id != 0) {\n                let conceptList = yield LocalConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n                for (let i = 0; i < conceptList.length; i++) {\n                    let compositionJson = yield GetCompositionLocalWithId(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n            return CompositionList;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalConnectionData } from \"../../DataStructures/Local/LocalConnectionData\";\nimport { TranslateLocalToReal } from \"../../Api/Translate/TranslateLocalToReal\";\nimport { GetComposition } from \"../GetComposition\";\nexport function GetCompositionLocal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n            let connectionList = [];\n            let returnOutput = {};\n            connectionList = yield LocalConnectionData.GetConnectionsOfCompositionLocal(id);\n            //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n            let compositionList = [];\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                }\n            }\n            let concept = yield LocalConceptsData.GetConcept(id);\n            if (concept.id == 0) {\n                let realConcept = yield TranslateLocalToReal(id);\n                if (realConcept.id > 0) {\n                    return yield GetComposition(realConcept.id);\n                }\n            }\n            let output = yield recursiveFetchLocal(id, connectionList, compositionList);\n            let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"top\";\n            returnOutput[mainString] = output;\n            return returnOutput;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\nexport function GetCompositionLocalWithId(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n            let connectionList = [];\n            let returnOutput = {};\n            let FinalReturn = {};\n            connectionList = yield LocalConnectionData.GetConnectionsOfCompositionLocal(id);\n            let compositionList = [];\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                }\n            }\n            let concept = yield LocalConceptsData.GetConcept(id);\n            if (concept.id != 0) {\n                let output = yield recursiveFetchLocal(id, connectionList, compositionList);\n                let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"top\";\n                returnOutput[mainString] = output;\n            }\n            FinalReturn['data'] = returnOutput;\n            FinalReturn['id'] = id;\n            return FinalReturn;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\nfunction recursiveFetchLocal(id_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        let concept = yield LocalConceptsData.GetConcept(id);\n        if (concept.id != 0) {\n            if (concept.type == null) {\n                let toConceptTypeId = concept.typeId;\n                let toConceptType = yield LocalConceptsData.GetConcept(toConceptTypeId);\n                concept.type = toConceptType;\n            }\n        }\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"top\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    let toConceptId = connectionList[i].toTheConceptId;\n                    let toConcept = yield LocalConceptsData.GetConcept(toConceptId);\n                    if (toConcept.id != 0) {\n                        if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                            let toConceptTypeId = toConcept.typeId;\n                            let toConceptType = yield LocalConceptsData.GetConcept(toConceptTypeId);\n                            toConcept.type = toConceptType;\n                        }\n                    }\n                    let regex = \"the_\";\n                    let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"top\";\n                    let localKey = localmainString.replace(regex, \"\");\n                    if (isNaN(Number(localKey))) {\n                        if (localKey) {\n                            const result = yield recursiveFetchLocal(toConceptId, connectionList, compositionList);\n                            output[localKey] = result;\n                        }\n                    }\n                    else {\n                        const result = yield recursiveFetchLocal(toConceptId, connectionList, compositionList);\n                        arroutput[localKey] = result;\n                        output = arroutput;\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetLocalConceptByCharacterValue } from \"../../Api/Local/GetLocalConceptByCharacterValue\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { CreateDefaultLConcept, SplitStrings } from \"../../app\";\nexport default function GetConceptByCharacterLocal(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield LocalConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, 51);\n        return concept;\n    });\n}\n/**\n *\n * @param character the character value of the concept we want to find in our local system.\n * @returns LConcept which will be the associated concept with the character Value.\n */\nexport function GetConceptByCharacterAndCategoryLocal(character) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let lconcept = CreateDefaultLConcept();\n        if (character == \"the\") {\n            lconcept.id = 1;\n            lconcept.typeId = 5;\n            lconcept.characterValue = \"the\";\n            return lconcept;\n        }\n        let splittedStringArray = SplitStrings(character);\n        if (splittedStringArray.length > 1) {\n            let category = 1;\n            let prefix = yield GetConceptByCharacterAndCategoryLocal(splittedStringArray[0]);\n            if (prefix.id != 0) {\n                category = prefix.id;\n            }\n            lconcept = yield GetConceptByCategoryAndCharacterLocalMemory(character, category);\n        }\n        else if (splittedStringArray[0] == character) {\n            lconcept = yield GetConceptByCharacterLocal(character);\n        }\n        return lconcept;\n    });\n}\nexport function GetConceptByCategoryAndCharacterLocalMemory(value, categoryId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = LocalConceptsData.GetConceptByCharacterAndCategoryLocal(value, categoryId);\n        return concept;\n    });\n}\nexport function GetConceptByCharacterLocalFull(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let concept = yield LocalConceptsData.GetConceptByCharacter(characterValue);\n            let literalCharacter = `${characterValue}`;\n            if ((concept == null || (concept === null || concept === void 0 ? void 0 : concept.id) == 0) && literalCharacter) {\n                yield GetLocalConceptByCharacterValue(characterValue);\n                concept = yield LocalConceptsData.GetConceptByCharacter(characterValue);\n            }\n            return concept;\n        }\n        catch (error) {\n            console.log(\"this is the error in Get Concept By Character Local full\", error);\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConnectionData } from \"../../DataStructures/Local/LocalConnectionData\";\nexport function GetConnectionOfTheConceptLocal(ofTheConcept, typeId, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let connections = yield LocalConnectionData.GetConnectionOfCompositionAndTypeLocal(typeId, ofTheConcept);\n            return connections;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetCompositionLocal, GetConceptByCharacterAndCategoryLocal } from \"../../app\";\nimport { GetConnectionOfTheConceptLocal } from \"./GetConnectionOfTheConceptLocal\";\nexport function GetRelationLocal(id, relation, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let typeConcept = yield GetConceptByCharacterAndCategoryLocal(relation);\n            let localConnections = [];\n            if (typeConcept.id != 0) {\n                localConnections = yield GetConnectionOfTheConceptLocal(id, typeConcept.id, userId);\n            }\n            let output = [];\n            for (let i = 0; i < localConnections.length; i++) {\n                let comp = yield GetCompositionLocal(localConnections[i].toTheConceptId);\n                output.push(comp);\n            }\n            return output;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalGhostIdTree } from \"../../DataStructures/Local/LocalGhostIdTree\";\nimport { CreateDefaultLConcept, GetTheConcept } from \"../../app\";\nimport { convertFromConceptToLConcept } from \"../Conversion/ConvertConcepts\";\n/**\n * This function converts any local/ virtual or real concept id to a LConcept.\n * In case that the id is virtual then it tries to find it from the local memory. This will return -ve id.\n * In case that the virtual id has already been synced to the backend then it gets this from the relational binary tree(LocalGhostIdTree). This will return +ve id.\n * In case that we pass real id then this will return real concept but formatted in LConcept form. This might have undefined ghostId.\n * @param id the id that you want to find out the concept of. This could be a negative (virtual id ) or a real concept id.\n * @returns LConcept with either (-ve or +ve id)\n */\nexport function GetTheConceptLocal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let lconcept = CreateDefaultLConcept();\n            if (id < 0) {\n                lconcept = yield LocalConceptsData.GetConcept(id);\n                if (lconcept.id == 0) {\n                    let localNode = yield LocalGhostIdTree.getNodeFromTree(id);\n                    if (localNode === null || localNode === void 0 ? void 0 : localNode.value) {\n                        let returnedConcept = localNode.value;\n                        if (returnedConcept) {\n                            lconcept = returnedConcept;\n                        }\n                    }\n                }\n            }\n            else {\n                let concept = yield GetTheConcept(id);\n                lconcept = convertFromConceptToLConcept(concept);\n            }\n            return lconcept;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport CreateTheConceptLocal from \"./CreateTheConceptLocal\";\nexport default function MakeTheConceptLocal(referent, typeCharacter, userId, categoryId, typeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let conceptString = yield LocalConceptsData.GetConceptByCharacterAndTypeLocal(referent, typeId);\n        let concept = conceptString;\n        let accessId = 4;\n        if (typeCharacter == \"the\") {\n            categoryId = 1;\n        }\n        if (concept.id == 0) {\n            conceptString = yield CreateTheConceptLocal(referent, typeCharacter, userId, categoryId, typeId, accessId);\n            concept = conceptString;\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport CreateTheConceptLocal from \"./CreateTheConceptLocal\";\nimport { MakeTheTypeConceptLocal } from \"./MakeTheTypeLocal\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalSyncData } from \"../../app\";\n/**\n * This is the basic function of the concept connection system. This function let's you create a concept within the constraints of the\n * concept connection system. This function is the building block of the concept connection system.\n * This function automatically passes the concept to be synced to the background. Next time you sync the data this concept will also be created in the backend.\n * @param type this is the type of the concept. You can also think of this as the key of concept. first_name, last_name etc.\n * @param referent the actual value of the concept. The actual name of value of the concept.\n * @param composition this is a boolean that defines if the concept is a composition or not. If this is a composition then other things are also\n * connected internally with this concept. If composition is true then always a new concept is created otherwise it checks if the concept already exists\n * and creates only in the case that the concept does not already exists with its type and value as its unique identifier.\n * @param userId the userId of the creator.\n * @param accessId this is the accessId of the creator. By default should be 4.\n * @param sessionInformationId this is the session that is created by the system.\n * @param referentId In case we need this concept to refer to any other concept.\n * @returns a concept which is either newly created or an older concept that already exists.\n */\nexport function MakeTheInstanceConceptLocal(type_1, referent_1) {\n    return __awaiter(this, arguments, void 0, function* (type, referent, composition = false, userId, accessId, sessionInformationId = 999, referentId = 0) {\n        try {\n            let sessionInformationId = 999;\n            let categoryId = 4;\n            let sessionInformationUserId = userId;\n            // change this\n            let accessId = 4;\n            let stringToCheck = \"\";\n            let stringLength = referent.length;\n            let typeConcept;\n            let concept;\n            let startsWithThe = type.startsWith(\"the_\");\n            if (startsWithThe) {\n                stringToCheck = type;\n            }\n            else {\n                stringToCheck = \"the_\" + type;\n            }\n            if (composition) {\n                let typeConceptString = yield MakeTheTypeConceptLocal(type, sessionInformationId, userId, userId);\n                typeConcept = typeConceptString;\n                let conceptString = yield CreateTheConceptLocal(referent, type, userId, categoryId, typeConcept.id, accessId, true, referentId);\n                concept = conceptString;\n            }\n            else if (stringLength > 255) {\n                let typeConceptString = yield MakeTheTypeConceptLocal(stringToCheck, sessionInformationId, sessionInformationUserId, userId);\n                typeConcept = typeConceptString;\n                let conceptString = yield CreateTheConceptLocal(referent, stringToCheck, userId, categoryId, typeConcept.id, accessId);\n                concept = conceptString;\n            }\n            else {\n                let typeConceptString = yield MakeTheTypeConceptLocal(stringToCheck, sessionInformationId, sessionInformationUserId, userId);\n                typeConcept = typeConceptString;\n                let conceptByCharTypeString = yield LocalConceptsData.GetConceptByCharacterAndTypeLocal(referent, typeConcept.id);\n                let conceptTypeCharacter = conceptByCharTypeString;\n                concept = conceptTypeCharacter;\n                if (conceptTypeCharacter.id == 0 && conceptTypeCharacter.userId == 0) {\n                    let conceptString = yield CreateTheConceptLocal(referent, stringToCheck, userId, categoryId, typeConcept.id, accessId);\n                    concept = conceptString;\n                }\n            }\n            concept.type = typeConcept;\n            LocalSyncData.AddConcept(concept);\n            return concept;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport CreateTheConceptLocal from \"./CreateTheConceptLocal\";\nimport { GetConceptByCharacterAndCategoryLocal } from \"./GetConceptByCharacterLocal\";\nimport { SplitStrings } from \"../SplitStrings\";\nimport MakeTheConceptLocal from \"./MakeTheConceptLocal\";\n/**\n * There are two types of concepts. One type of concept is a type concept. These concepts have no actual value and do not mean\n * anything unless they are associated with other values. These are placeholders like first_name, last_name, age etc that are required in the system.\n * These types need to be created seperately.\n *\n *\n * @param typeString type of the concept that needs to be created.\n * @param sessionId SessionId of the user\n * @param sessionUserId Not required pass 999\n * @param userId UserId of the user creating this concept\n * @returns\n */\nexport function MakeTheTypeConceptLocal(typeString, sessionId, sessionUserId, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let accessId = 4;\n        let existingConcept = yield GetConceptByCharacterAndCategoryLocal(typeString);\n        if (existingConcept) {\n            if (existingConcept.id == 0 || existingConcept.userId == 0) {\n                let splittedStringArray = SplitStrings(typeString);\n                if (splittedStringArray[0] == typeString) {\n                    let concept = yield MakeTheConceptLocal(typeString, \"the\", userId, 1, 51);\n                    existingConcept = concept;\n                }\n                else {\n                    // var categoryConcept = await MakeTheTypeConceptLocal(splittedStringArray[0], sessionId, sessionUserId, userId);\n                    // var typeConcept = await MakeTheTypeConceptLocal(splittedStringArray[1], sessionId, sessionUserId, userId );\n                    // if(typeConcept){\n                    let categoryConcept = yield MakeTheTypeConceptLocal(splittedStringArray[0], sessionId, sessionUserId, userId);\n                    let typeConcept = yield MakeTheTypeConceptLocal(splittedStringArray[1], sessionId, sessionUserId, userId);\n                    let concept = yield CreateTheConceptLocal(typeString, splittedStringArray[1], userId, categoryConcept.id, typeConcept.id, accessId);\n                    existingConcept = concept;\n                    //   }\n                }\n            }\n        }\n        // LocalSyncData.AddConcept(existingConcept);\n        return existingConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport InsertUniqueNumber from '../../Helpers/UniqueInsert';\nimport { CheckAllConnectionsConnectedInLConnectionArray, CheckIfTypeLConceptsExistsInArray, } from '../../Helpers/CheckIfExists';\nimport { GetAllConnectionsOfComposition } from '../../Api/GetAllConnectionsOfComposition';\nimport GetTheConcept from './../GetTheConcept';\nimport { DeleteConnectionById } from './../DeleteConnection';\nimport { CreateTheCompositionLocal } from './CreateTheCompositionLocal';\nimport { MakeTheInstanceConceptLocal } from './MakeTheInstanceConceptLocal';\nimport { CreateDefaultLConcept, CreateTheConnectionLocal, LocalSyncData } from '../../app';\nimport { convertFromConceptToLConcept, convertFromConnectionToLConnection } from '../Conversion/ConvertConcepts';\n// function to update the cache composition\nexport function UpdateCompositionLocal(patcherStructure) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // get all the default userId, sessionId, accessId passed by the patcherStructure\n        const userId = patcherStructure.userId;\n        const sessionId = patcherStructure.sessionId;\n        const accessId = patcherStructure.accessId;\n        let connectionList = [];\n        const conceptList = [];\n        let composition = CreateDefaultLConcept();\n        let parentConcept = CreateDefaultLConcept();\n        const toDeleteConcepts = [];\n        // the main composition Id that has the data that needs to be patched\n        const compositionId = patcherStructure.compositionId;\n        // if you want to edit the subcompositions of the composition then you have to pass to this\n        const ofTheConceptId = patcherStructure.ofTheCompositionId;\n        let toDeleteConnections = [];\n        // get all connections from the backend because it needs latest data\n        const connectionListString = yield GetAllConnectionsOfComposition(compositionId);\n        let connectionListOriginal = connectionListString;\n        for (let i = 0; i < connectionListOriginal.length; i++) {\n            connectionList.push(convertFromConnectionToLConnection(connectionListOriginal[i]));\n        }\n        const conceptIdList = [];\n        const compositionList = [];\n        // put this in the upper section before updating because this will tell all other distributed\n        //servers to destroy the copy of the composition that they have as new composition is coming up\n        // get all the connections that are inside of the composition and store them in\n        let allConcepts = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            InsertUniqueNumber(compositionList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].toTheConceptId);\n            allConcepts.push(connectionList[i].ofTheConceptId);\n        }\n        // get all the concepts that are inside of the composition and store them in a conceptList\n        for (let i = 0; i < conceptIdList.length; i++) {\n            const conceptString = yield GetTheConcept(conceptIdList[i]);\n            const concept = conceptString;\n            if (compositionId == conceptIdList[i]) {\n                composition = convertFromConceptToLConcept(concept);\n            }\n            if (ofTheConceptId == conceptIdList[i]) {\n                parentConcept = convertFromConceptToLConcept(concept);\n            }\n            conceptList.push(convertFromConceptToLConcept(concept));\n        }\n        // now trying to patch the new object into the composition\n        const object = patcherStructure.patchObject;\n        for (const key in object) {\n            let insertingConcept = CreateDefaultLConcept();\n            const value = object[key];\n            let localConcept = composition;\n            // if the immedidate parent exists in the composition (i.e. for multilevel composition)\n            if (parentConcept.id > 0) {\n                localConcept = parentConcept;\n            }\n            if (Array.isArray(value) || typeof value == 'object') {\n                insertingConcept = yield MakeTheInstanceConceptLocal(key, \"\", true, composition.userId, 4, 999);\n                yield CreateTheCompositionLocal(object[key], insertingConcept.id, insertingConcept.userId, composition.id, composition.userId, 4, 999);\n            }\n            else {\n                // make the new concept in the object\n                insertingConcept = yield MakeTheInstanceConceptLocal(key, value, false, userId, accessId, sessionId);\n            }\n            // check if the concept exists in the concept list because if it exists then we have to delete old connection\n            const ExistingConcepts = CheckIfTypeLConceptsExistsInArray(conceptList, insertingConcept);\n            // if the existing concept then start the process for deleting the concept in the list\n            for (let i = 0; i < ExistingConcepts.length; i++) {\n                if (ExistingConcepts[i].id > 0) {\n                    const deletingConnections = CheckAllConnectionsConnectedInLConnectionArray(connectionList, ExistingConcepts[i].id);\n                    toDeleteConnections = toDeleteConnections.concat(deletingConnections);\n                    toDeleteConcepts.push(ExistingConcepts[i]);\n                }\n            }\n            // create the connection between the new concept and the old composition\n            const connectionString = yield CreateTheConnectionLocal(localConcept.id, insertingConcept.id, composition.id, 2);\n            const connection = connectionString;\n            conceptList.push(insertingConcept);\n        }\n        // now you have to delete the connection in bulk\n        for (let j = 0; j < toDeleteConnections.length; j++) {\n            // remove from the cache list\n            // delete the connection in the backend\n            yield DeleteConnectionById(toDeleteConnections[j].id);\n        }\n        yield LocalSyncData.SyncDataOnline();\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport MakeTheCharacterData from \"./MakeTheCharacterData\";\nimport MakeTheConcept from \"./MakeTheConcept\";\nexport default function MakeTheCharacter(the_character_data, userId, securityId, accessId, accessUserId, sessionId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let categoryUserId = userId;\n        let securityUserId = userId;\n        let categoryId = 4;\n        let typeId = 51;\n        let typeUserId = userId;\n        let sessionUserId = userId;\n        let referentUserId = userId;\n        let lengthOfCharacters = the_character_data.length;\n        let concept;\n        if (lengthOfCharacters == 1) {\n            let referentId = the_character_data.charCodeAt(0);\n            let typeIdForCharacter = 49;\n            let characterDataString = yield MakeTheCharacterData(the_character_data, userId, securityId, accessId, sessionId);\n            concept = MakeTheConcept(the_character_data, userId, categoryId, typeIdForCharacter, referentId, accessId, \"the_character\");\n        }\n        else {\n            let characterDataString = yield MakeTheCharacterData(the_character_data, userId, securityId, accessId, sessionId);\n            let characterData = characterDataString;\n            if (characterData.isNew) {\n                let conceptString = yield MakeTheConcept(the_character_data, userId, categoryId, typeId, characterData.id, accessId, \"the_characters\");\n                concept = conceptString;\n            }\n            else {\n                let conceptString = yield MakeTheConcept(the_character_data, userId, categoryId, typeId, characterData.id, accessId, \"the_characters\");\n                concept = conceptString;\n            }\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheCharacter } from \"../Api/Create/CreateTheCharacter\";\nimport { TheCharacter } from \"../DataStructures/TheCharacter\";\nexport default function MakeTheCharacterData(the_character_data, userId, securityId, accessId, sessionId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var categoryUserId = userId;\n        var accessUserId = userId;\n        var securityUserId = userId;\n        var sessionInformationUserId = userId;\n        var theCharacter = new TheCharacter(userId, the_character_data, securityId, securityUserId, accessId, accessUserId, sessionId, sessionInformationUserId, \"\", false);\n        var output = yield CreateTheCharacter(theCharacter);\n        var returner = output;\n        return returner;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterAndType } from \"../Api/GetConceptByCharacterAndType\";\nimport CreateTheConcept from \"./CreateTheConcept\";\nexport default function MakeTheConcept(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let conceptString = yield GetConceptByCharacterAndType(referent, typeId);\n        let concept = conceptString;\n        if (concept.id == 0) {\n            conceptString = yield CreateTheConcept(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter);\n            concept = conceptString;\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTextData } from \"../Api/Create/CreateTheTextData\";\nimport { GetConceptByCharacterAndType } from \"../Api/GetConceptByCharacterAndType\";\nimport { MakeTheNameInBackend } from \"../Api/MakeTheNameInBackend\";\nimport { TheTexts } from \"../DataStructures/TheTexts\";\nimport { MakeTheTypeConceptApi } from \"../app\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport CreateTheConcept, { CreateTheConceptImmediate } from \"./CreateTheConcept\";\n/**\n * This is the basic function of the concept connection system. This function let's you create a concept within the constraints of the\n * concept connection system. This function is the building block of the concept connection system.\n * @param type this is the type of the concept. You can also think of this as the key of concept. first_name, last_name etc.\n * @param referent the actual value of the concept. The actual name of value of the concept.\n * @param composition this is a boolean that defines if the concept is a composition or not. If this is a composition then other things are also\n * connected internally with this concept. If composition is true then always a new concept is created otherwise it checks if the concept already exists\n * and creates only in the case that the concept does not already exists with its type and value as its unique identifier.\n * @param userId the userId of the creator.\n * @param passedAccessId this is the accessId of the creator. By default should be 4.\n * @param passedSessionId this is the session that is created by the system.\n * @param referentId In case we need this concept to refer to any other concept.\n * @returns a concept which is either newly created or an older concept that already exists.\n */\nexport default function MakeTheInstanceConcept(type_1, referent_1) {\n    return __awaiter(this, arguments, void 0, function* (type, referent, composition = false, userId, passedAccessId = 4, passedSessionId = 999, referentId = 0) {\n        let sessionInformationId = passedSessionId;\n        let categoryId = 4;\n        let categoryUserId = userId;\n        let referentUserId = 999;\n        let securityId = 999;\n        let securityUserId = userId;\n        let sessionInformationUserId = userId;\n        // change this\n        let accessId = passedAccessId;\n        let accessUserId = userId;\n        let stringToCheck = \"\";\n        let stringLength = referent.length;\n        let typeConcept = CreateDefaultConcept();\n        let concept;\n        let startsWithThe = type.startsWith(\"the_\");\n        if (startsWithThe) {\n            stringToCheck = type;\n        }\n        else {\n            stringToCheck = \"the_\" + type;\n        }\n        if (composition) {\n            let typeConceptString = yield MakeTheTypeConceptApi(type, userId);\n            typeConcept = typeConceptString;\n            let conceptString = yield CreateTheConcept(referent, userId, categoryId, typeConcept.id, referentId, accessId, type);\n            concept = conceptString;\n        }\n        else if (stringLength > 255) {\n            let typeConceptString = yield MakeTheTypeConceptApi(stringToCheck, userId);\n            typeConcept = typeConceptString;\n            let conceptString = yield CreateTheConcept(referent, userId, categoryId, typeConcept.id, referentId, accessId, stringToCheck);\n            concept = conceptString;\n            let TheTextsData = new TheTexts(userId, referent, securityId, securityUserId, accessId, accessUserId, sessionInformationId, sessionInformationUserId, Date.now().toString(), true);\n            CreateTextData(TheTextsData);\n        }\n        else {\n            let typeConceptString = yield MakeTheTypeConceptApi(stringToCheck, userId);\n            typeConcept = typeConceptString;\n            let conceptByCharTypeString = yield GetConceptByCharacterAndType(referent, typeConcept.id);\n            let conceptTypeCharacter = conceptByCharTypeString;\n            concept = conceptTypeCharacter;\n            if (conceptTypeCharacter.id == 0 && conceptTypeCharacter.userId == 0) {\n                // let makeTheNameString = await MakeTheName(referent,userId, securityId, securityUserId, accessId, accessUserId, sessionInformationId, sessionInformationUserId,typeConcept.id, typeConcept.userId,conceptTypeCharacter );\n                // let makeTheNameConcept = makeTheNameString as Concept;\n                // concept = conceptTypeCharacter;\n                let conceptString = yield CreateTheConceptImmediate(referent, userId, categoryId, typeConcept.id, 12, accessId, stringToCheck);\n                concept = conceptString;\n                MakeTheNameInBackend(concept.id, `${referent}`, typeConcept.id, userId);\n            }\n        }\n        // if(concept){\n        //     if(concept.type == null){\n        //         let conceptType = ConceptsData.GetConcept(concept.typeId);\n        //         if(conceptType == null && concept.typeId != null && concept.typeId != undefined){\n        //             let typeConceptStringNew = await GetConcept(concept.typeId);\n        //             let newTypeConcept = typeConceptStringNew as Concept;\n        //             concept.type = newTypeConcept;\n        //         }\n        //     }\n        // }\n        concept.type = typeConcept;\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MakeTheTypeConceptApi } from \"../app\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport MakeTheConcept from \"./MakeTheConcept\";\nexport function MakeTheTimestamp(type_1, referent_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (type, referent, userId, accessId = 4, sessionInformationId = 999) {\n        let categoryId = 4;\n        let referentId = 0;\n        // change this\n        let stringToCheck = \"\";\n        let startsWithThe = type.startsWith(\"the_\");\n        let typeConcept = CreateDefaultConcept();\n        let concept;\n        if (startsWithThe) {\n            stringToCheck = type;\n        }\n        else {\n            stringToCheck = \"the_\" + type;\n        }\n        let typeConceptString = yield MakeTheTypeConceptApi(stringToCheck, userId);\n        typeConcept = typeConceptString;\n        let conceptString = yield MakeTheConcept(referent, userId, categoryId, typeConcept.id, referentId, accessId, stringToCheck);\n        concept = conceptString;\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheConceptImmediate } from \"./CreateTheConcept\";\nimport GetConceptByCharacter from \"./GetConceptByCharacter\";\nimport MakeTheCharacter from \"./MakeTheCharacter\";\nimport { SplitStrings } from \"./SplitStrings\";\nexport function MakeTheTypeConcept(typeString, sessionId, sessionUserId, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let referentId = 999;\n        let securityId = 999;\n        let accessId = 999;\n        let accessUserId = userId;\n        let existingConcept = yield GetConceptByCharacter(typeString);\n        if (existingConcept) {\n            if (existingConcept.id == 0 || existingConcept.userId == 0) {\n                let splittedStringArray = SplitStrings(typeString);\n                if (splittedStringArray.length > 0) {\n                    if (splittedStringArray[0] == typeString) {\n                        let conceptString = yield MakeTheCharacter(typeString, userId, securityId, accessId, accessUserId, sessionId);\n                        existingConcept = conceptString;\n                    }\n                    else {\n                        let categoryId = 1;\n                        let categoryConcept = yield MakeTheTypeConcept(splittedStringArray[0], sessionId, sessionUserId, userId);\n                        let typeConcept = yield MakeTheTypeConcept(splittedStringArray[1], sessionId, sessionUserId, userId);\n                        if (typeConcept) {\n                            let concept = yield CreateTheConceptImmediate(typeString, userId, categoryConcept.id, typeConcept.id, referentId, accessId, splittedStringArray[1]);\n                            existingConcept = concept;\n                        }\n                    }\n                }\n            }\n        }\n        return existingConcept;\n    });\n}\n","import { BaseUrl } from \"../../DataStructures/BaseUrl\";\nexport function publishMessage(topic, message) {\n    if (BaseUrl.MQTT_CONNECTION) {\n        BaseUrl.MQTT_CONNECTION.publish(topic, message);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchInternalApi } from \"../../Api/Search/SearchInternalApi\";\nimport { ViewInternalData } from \"../../app\";\nexport function SearchLinkInternal(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        try {\n            let conceptsConnections = yield SearchInternalApi(searchQuery, token);\n            let out = yield ViewInternalData(conceptsConnections);\n            return out;\n        }\n        catch (ex) {\n            throw ex;\n        }\n    });\n}\nexport function SearchLinkInternalAll(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        try {\n            let conceptsConnections = yield SearchInternalApi(searchQuery, token);\n            let out = yield ViewInternalData(conceptsConnections);\n            return out;\n        }\n        catch (ex) {\n            throw ex;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchLinkMultipleApi } from \"../../Api/Search/SearchLinkMultipleApi\";\nimport { DATAID, JUSTDATA, NORMAL } from \"../../Constants/FormatConstants\";\nimport { GetConceptBulk, GetConnectionBulk, GetTheConcept } from \"../../app\";\nimport { GetCompositionFromConnectionsInObject, GetCompositionFromConnectionsInObjectNormal, GetCompositionFromConnectionsWithDataIdInObject, GetCompositionFromConnectionsWithDataIdInObjectNew, GetConnectionDataPrefetch } from \"../GetCompositionBulk\";\nexport function SearchLinkMultipleAll(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\", caller = null, format = DATAID) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let conceptIds = [];\n        let linkers = [];\n        let connections = [];\n        let reverse = [];\n        let mainCompositionId = searchQuery[0].composition;\n        let conceptsConnections = {};\n        let result = {};\n        try {\n            if (caller === null || caller === void 0 ? void 0 : caller.isDataLoaded) {\n                conceptsConnections.compositionIds = (_a = caller.conceptIds) === null || _a === void 0 ? void 0 : _a.slice();\n                conceptsConnections.internalConnections = (_b = caller.internalConnections) === null || _b === void 0 ? void 0 : _b.slice();\n                conceptsConnections.linkers = (_c = caller.linkers) === null || _c === void 0 ? void 0 : _c.slice();\n                conceptsConnections.reverse = (_d = caller.reverse) === null || _d === void 0 ? void 0 : _d.slice();\n                result = conceptsConnections;\n                conceptIds = result.compositionIds;\n                connections = result.internalConnections;\n                linkers = result.linkers;\n                reverse = result.reverse;\n            }\n            else {\n                conceptsConnections = yield SearchLinkMultipleApi(searchQuery, token);\n                if (caller) {\n                    caller.conceptIds = (_e = conceptsConnections.compositionIds) === null || _e === void 0 ? void 0 : _e.slice();\n                    caller.internalConnections = (_f = conceptsConnections.internalConnections) === null || _f === void 0 ? void 0 : _f.slice();\n                    caller.linkers = (_g = conceptsConnections.linkers) === null || _g === void 0 ? void 0 : _g.slice();\n                    caller.reverse = (_h = conceptsConnections.reverse) === null || _h === void 0 ? void 0 : _h.slice();\n                    caller.isDataLoaded = true;\n                }\n                result = conceptsConnections;\n                conceptIds = result.compositionIds;\n                connections = result.internalConnections;\n                linkers = result.linkers;\n                reverse = result.reverse;\n            }\n            let out = yield DataIdBuildLayer(linkers, conceptIds, connections, reverse, mainCompositionId, format);\n            return out;\n        }\n        catch (e) {\n            console.log(\"this is the error in the search link multiple\", e);\n            throw e;\n        }\n    });\n}\n/**\n * ######### This layer builds the data. Format is dataid ##########\n * @param linkers list of ids that help us\n * @param conceptIds this is all the concept ids that need  to be composited\n * @param connections these are the internal connections of the compositions that help in creating individual compositions\n * @param reverse this is the list of connection ids that need to show reverse connections(to->from)\n * @param mainCompositionId this is the main centre point of this data.\n * @returns\n */\nexport function DataIdBuildLayer(linkers_1, conceptIds_1, connections_1, reverse_1, mainCompositionId_1) {\n    return __awaiter(this, arguments, void 0, function* (linkers, conceptIds, connections, reverse, mainCompositionId, format = DATAID) {\n        let startTime = new Date().getTime();\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts;\n        let out;\n        if (format == JUSTDATA) {\n            concepts = yield GetCompositionFromConnectionsInObject(conceptIds, connections);\n            out = yield FormatFromConnections(linkers, concepts, mainCompositionId, reverse);\n        }\n        else if (format == NORMAL) {\n            concepts = yield GetCompositionFromConnectionsInObjectNormal(conceptIds, connections);\n            out = yield FormatFromConnections(linkers, concepts, mainCompositionId, reverse);\n        }\n        else if (format == 100) {\n            concepts = yield GetCompositionFromConnectionsWithDataIdInObjectNew(conceptIds, connections);\n            out = yield FormatFromConnectionsAltered(prefetchConnections, concepts, mainCompositionId, reverse);\n        }\n        else {\n            concepts = yield GetCompositionFromConnectionsWithDataIdInObject(conceptIds, connections);\n            out = yield FormatFromConnectionsAltered(prefetchConnections, concepts, mainCompositionId, reverse);\n        }\n        return out;\n    });\n}\n/**\n * ## Format is DATAID ##\n * This  is altered format and is different from others because it passes all the connections prebuilt/prefetched\n * This will not let the connections to be again fetched from the memory.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is the id of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatFromConnectionsAltered(connections_1, compositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, mainComposition, reverse = []) {\n        let startTime = new Date().getTime();\n        let mainData = {};\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        mainData = compositionData[mainComposition];\n        return mainData;\n    });\n}\n/**\n * ######### Format is normal ######### used for listing.\n * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list\n * The list format is helpful because you do not have to go over each individual query.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is list of  ids of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatConceptsAndConnections(connections_1, compositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, mainComposition, reverse = []) {\n        let mainData = [];\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let newData = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let newData = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < mainComposition.length; i++) {\n            let mymainData = compositionData[mainComposition[i]];\n            console.log(mainData, mymainData);\n            mainData.push(mymainData);\n        }\n        return mainData;\n    });\n}\n/**\n * ############ Format is data-id and is used for list. ############\n * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list\n * The list format is helpful because you do not have to go over each individual query.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is list of  ids of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatFromConnectionsAlteredArray(connections_1, compositionData_1, conceptIds_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, conceptIds, mainComposition, reverse = []) {\n        let startTime = new Date().getTime();\n        let mainData = [];\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < mainComposition.length; i++) {\n            let mymainData = compositionData[mainComposition[i]];\n            console.log(mainData, mymainData);\n            mainData.push(mymainData);\n        }\n        return mainData;\n    });\n}\n/**\n * ########## Format works with JUSTDATA / NORMAL ########### used for single origin concept\n * @param linkers this is the list of linkers that\n * @param compositionData\n * @param mainComposition\n * @param reverse list of connection ids that need to show reverse conneciton.\n * @returns\n */\nexport function FormatFromConnections(linkers_1, compositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (linkers, compositionData, mainComposition, reverse = []) {\n        let mainData = {};\n        let connections = yield GetConnectionBulk(linkers);\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        yield GetConceptBulk(myConcepts);\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata;\n                    // console.log(\"this is the new data\", newData);\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        mainData = compositionData[mainComposition];\n        return mainData;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchWithTypeAndLinkerApi } from '../../app';\nimport { GetCompositionFromConnectionsInObject, GetCompositionFromConnectionsWithDataIdInObject, GetConnectionDataPrefetch } from '../GetCompositionBulk';\nimport { FormatConceptsAndConnections, FormatFromConnectionsAlteredArray } from './SearchLinkMultiple';\n/**\n * This function will help you search a concept by their type and also to query inside of it.\n * Put the number of compositions you want to get in the searchStructure which can be set by inpage and page\n * Then the type should be set in searchQuery for the compositionName.\n * Inside the searchQuery array this you can set the full linker / listLinker in the searchQuery.\n * This will give the id of the structures.\n */\nexport function SearchWithTypeAndLinkerDataId(searchStructure_1, searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchStructure, searchQuery, token = \"\") {\n        let result = yield SearchWithTypeAndLinkerApi(searchStructure, searchQuery, token);\n        let conceptIds = result.compositionIds;\n        let connections = result.internalConnections;\n        let linkers = result.linkers;\n        let reverse = result.reverse;\n        let mainCompositionIds = result.mainCompositionIds;\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts = yield GetCompositionFromConnectionsWithDataIdInObject(conceptIds, connections);\n        let output = yield FormatFromConnectionsAlteredArray(prefetchConnections, concepts, conceptIds, mainCompositionIds, reverse);\n        return output;\n    });\n}\n/**\n * This function will help you search a concept by their type and also to query inside of it.\n * Put the number of compositions you want to get in the searchStructure which can be set by inpage and page\n * Then the type should be set in searchQuery for the compositionName.\n * Inside the searchQuery array this you can set the full linker / listLinker in the searchQuery.\n * This will not give the id of the structures.\n */\nexport function SearchWithTypeAndLinker(searchStructure_1, searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchStructure, searchQuery, token = \"\") {\n        let result = yield SearchWithTypeAndLinkerApi(searchStructure, searchQuery, token);\n        let conceptIds = result.compositionIds;\n        let connections = result.internalConnections;\n        let linkers = result.linkers;\n        let reverse = result.reverse;\n        let mainCompositionIds = result.mainCompositionIds;\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts = yield GetCompositionFromConnectionsInObject(conceptIds, connections);\n        let output = yield FormatConceptsAndConnections(prefetchConnections, concepts, mainCompositionIds, reverse);\n        return output;\n    });\n}\n","import { TokenStorage } from \"../../DataStructures/Security/TokenStorage\";\nexport function GetRequestHeader(contentType = 'application/json', Accept = 'application/json') {\n    var headers = {\n        'Content-Type': contentType,\n        'Authorization': \"Bearer \" + TokenStorage.BearerAccessToken,\n        'Accept': Accept,\n    };\n    return headers;\n}\nexport function GetRequestHeaderWithAuthorization(contentType = 'application/json', token = \"\", Accept = 'application/json') {\n    if (token == \"\") {\n        token = TokenStorage.BearerAccessToken;\n    }\n    var headers = {\n        'Content-Type': contentType,\n        'Authorization': \"Bearer \" + token,\n        'Accept': Accept\n    };\n    return headers;\n}\nexport function GetOnlyTokenHeader() {\n    let token = TokenStorage.BearerAccessToken;\n    const myHeaders = new Headers();\n    myHeaders.append('Authorization', 'Bearer ' + token);\n    return myHeaders;\n}\n","export function SplitStrings(typeString) {\n    const pos = typeString.lastIndexOf(\"_\");\n    let SplittedStrings = [];\n    if (pos > 0) {\n        let rest = typeString.substring(0, pos);\n        let last = typeString.substring(pos + 1, typeString.length);\n        SplittedStrings = [rest, last];\n    }\n    else {\n        SplittedStrings = [typeString];\n    }\n    return SplittedStrings;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport InsertUniqueNumber from '../Helpers/UniqueInsert';\nimport { CheckAllConnectionsConnectedInConnectionArray, CheckIfTypeConceptsExistsInArray, } from '../Helpers/CheckIfExists';\nimport { RemoveConceptFromList, RemoveConnectionFromList, } from '../Helpers/RemoveFromArray';\nimport { CreateDefaultConcept } from './CreateDefaultConcept';\nimport { GetAllConnectionsOfComposition } from '../Api/GetAllConnectionsOfComposition';\nimport GetTheConcept from './GetTheConcept';\nimport MakeTheInstanceConcept from './MakeTheInstanceConcept';\nimport { createTheConnection } from './CreateTheConnection';\nimport { DeleteConnectionById } from './DeleteConnection';\nimport { SyncData } from '../DataStructures/SyncData';\nimport { CompositionBinaryTree } from '../DataStructures/Composition/CompositionBinaryTree';\nimport { Composition } from '../DataStructures/Composition/Composition';\nimport { CreateTheCompositionWithCache } from './Composition/CreateCompositionCache';\n// function to update the cache composition\nexport default function UpdateComposition(patcherStructure) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // get all the default userId, sessionId, accessId passed by the patcherStructure\n        const userId = patcherStructure.userId;\n        const sessionId = patcherStructure.sessionId;\n        const accessId = patcherStructure.accessId;\n        let connectionList = [];\n        const conceptList = [];\n        let composition = CreateDefaultConcept();\n        let parentConcept = CreateDefaultConcept();\n        const toDeleteConcepts = [];\n        // the main composition Id that has the data that needs to be patched\n        let compositionId = patcherStructure.compositionId;\n        // if you want to edit the subcompositions of the composition then you have to pass to this\n        const ofTheConceptId = patcherStructure.ofTheCompositionId;\n        let toDeleteConnections = [];\n        if (compositionId < 0) {\n            let localConcept = yield GetTheConcept(compositionId, userId);\n            if (localConcept.id > 0) {\n                compositionId = localConcept.id;\n            }\n            else {\n                return null;\n            }\n        }\n        // get all connections from the backend because it needs latest data\n        const connectionListString = yield GetAllConnectionsOfComposition(compositionId);\n        connectionList = connectionListString;\n        const conceptIdList = [];\n        const compositionCache = new Composition();\n        const compositionList = [];\n        compositionCache.id = compositionId;\n        // put this in the upper section before updating because this will tell all other distributed\n        //servers to destroy the copy of the composition that they have as new composition is coming up\n        compositionCache.isUpdating();\n        // get all the connections that are inside of the composition and store them in\n        let allConcepts = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            InsertUniqueNumber(compositionList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].toTheConceptId);\n            allConcepts.push(connectionList[i].ofTheConceptId);\n        }\n        compositionCache.subcompositions = compositionList;\n        compositionCache.connections = connectionList;\n        // get all the concepts that are inside of the composition and store them in a conceptList\n        for (let i = 0; i < conceptIdList.length; i++) {\n            const conceptString = yield GetTheConcept(conceptIdList[i]);\n            const concept = conceptString;\n            if (compositionId == conceptIdList[i]) {\n                composition = concept;\n            }\n            if (ofTheConceptId == conceptIdList[i]) {\n                parentConcept = concept;\n            }\n            conceptList.push(concept);\n        }\n        // now trying to patch the new object into the composition\n        const object = patcherStructure.patchObject;\n        for (const key in object) {\n            let insertingConcept = CreateDefaultConcept();\n            const value = object[key];\n            let localConcept = composition;\n            // if the immedidate parent exists in the composition (i.e. for multilevel composition)\n            if (parentConcept.id > 0) {\n                localConcept = parentConcept;\n            }\n            if (Array.isArray(value) || typeof value == 'object') {\n                insertingConcept = yield MakeTheInstanceConcept(key, \"\", true, composition.userId, 4, 999);\n                compositionCache.subcompositions.push(insertingConcept.id);\n                // check if the concept exists in the concept list because if it exists then we have to delete old connection\n                const ExistingConcepts = CheckIfTypeConceptsExistsInArray(conceptList, insertingConcept);\n                // if the existing concept then start the process for deleting the concept in the list\n                for (let i = 0; i < ExistingConcepts.length; i++) {\n                    if (ExistingConcepts[i].id > 0) {\n                        const deletingConnections = CheckAllConnectionsConnectedInConnectionArray(compositionCache.connections, ExistingConcepts[i].id);\n                        toDeleteConnections = toDeleteConnections.concat(deletingConnections);\n                        toDeleteConcepts.push(ExistingConcepts[i]);\n                    }\n                }\n                yield CreateTheCompositionWithCache(object[key], insertingConcept.id, insertingConcept.userId, composition.id, composition.userId, 4, 999, compositionCache);\n            }\n            else {\n                // make the new concept in the object\n                insertingConcept = yield MakeTheInstanceConcept(key, value, false, userId, accessId, sessionId);\n                // check if the concept exists in the concept list because if it exists then we have to delete old connection\n                const ExistingConcepts = CheckIfTypeConceptsExistsInArray(conceptList, insertingConcept);\n                // if the existing concept then start the process for deleting the concept in the list\n                for (let i = 0; i < ExistingConcepts.length; i++) {\n                    if (ExistingConcepts[i].id > 0) {\n                        const deletingConnections = CheckAllConnectionsConnectedInConnectionArray(compositionCache.connections, ExistingConcepts[i].id);\n                        toDeleteConnections = toDeleteConnections.concat(deletingConnections);\n                        toDeleteConcepts.push(ExistingConcepts[i]);\n                    }\n                }\n            }\n            // create the connection between the new concept and the old composition\n            const connectionString = createTheConnection(localConcept.id, localConcept.userId, insertingConcept.id, composition.id);\n            const connection = connectionString;\n            conceptList.push(insertingConcept);\n            compositionCache.connections.push(connection);\n        }\n        // now you have to delete the connection in bulk\n        for (let j = 0; j < toDeleteConnections.length; j++) {\n            // remove from the cache list\n            RemoveConnectionFromList(compositionCache.connections, toDeleteConnections[j]);\n            // delete the connection in the backend\n            DeleteConnectionById(toDeleteConnections[j].id);\n        }\n        // also delete the existing concept from the cache.\n        for (let k = 0; k < toDeleteConcepts.length; k++) {\n            // remove concept from the cache concept list\n            RemoveConceptFromList(conceptList, toDeleteConcepts[k]);\n        }\n        // now create a composition cache object to cache it into node server\n        compositionCache.concepts = compositionCache.concepts.concat(conceptList);\n        compositionCache.mainConcept = composition;\n        compositionCache.id = composition.id;\n        // // create a cache\n        yield compositionCache.updateCache();\n        // update it the binary tree\n        CompositionBinaryTree.addCompositionToTree(compositionCache);\n        SyncData.SyncDataOnline();\n        let x = compositionCache.GetDataCache();\n        return x;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateDefaultLConcept } from './../../Services/Local/CreateDefaultLConcept';\nimport { UserBinaryTree } from './../../DataStructures/User/UserBinaryTree';\nexport function GetUserGhostId(userId_1, ghostId_1) {\n    return __awaiter(this, arguments, void 0, function* (userId, ghostId, sessionId = 999) {\n        let userNode = yield UserBinaryTree.getNodeFromTree(userId, sessionId);\n        console.log(\"this is the ghost id\", userId, sessionId);\n        let realConcept = CreateDefaultLConcept();\n        if (userNode) {\n            for (let i = 0; i < userNode.value.length; i++) {\n                let testConcept = userNode.value[i];\n                if (testConcept.ghostId == ghostId) {\n                    realConcept = testConcept;\n                }\n            }\n        }\n        return realConcept;\n    });\n}\nexport function AddGhostConcept(concept_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, userId, sessionId = 999) {\n        UserBinaryTree.addConceptToTree(concept, userId, sessionId);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ViewInternalDataApi } from \"../../Api/View/ViewInternalDataApi\";\nimport { GetTheConcept, recursiveFetch } from \"../../app\";\nexport function ViewInternalData(ids) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n            let connections = yield ViewInternalDataApi(ids);\n            let output = [];\n            for (let i = 0; i < ids.length; i++) {\n                let id = ids[i];\n                let localConnections = connections[id];\n                if (id && localConnections) {\n                    let concepts = [];\n                    let formattedOutput = {};\n                    for (let j = 0; j < localConnections.length; j++) {\n                        if (!concepts.includes(localConnections[j].ofTheConceptId)) {\n                            concepts.push(localConnections[j].ofTheConceptId);\n                        }\n                    }\n                    let out = yield recursiveFetch(id, localConnections, concepts);\n                    formattedOutput.data = out;\n                    formattedOutput.id = id;\n                    output.push(formattedOutput);\n                }\n                else {\n                    let formattedOutput = {};\n                    formattedOutput.id = id;\n                    let concept = yield GetTheConcept(id);\n                    let noconn = {};\n                    if (concept.type) {\n                        noconn[(_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue] = concept.characterValue;\n                        formattedOutput.data = noconn;\n                        output.push(formattedOutput);\n                    }\n                }\n            }\n            return output;\n        }\n        catch (err) {\n            throw err;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"../app\";\nimport { NORMAL } from \"../Constants/FormatConstants\";\n/**\n * This is the class that helps us observe anything that the function is doing\n * This wrapper will allow all the concepts and connections to be tracked inside of the called function\n * This function helps us manage state using the concept connection system.\n */\nexport class DependencyObserver {\n    constructor() {\n        this.subscribers = []; // this is the list of subscribers that are added to this observer.\n        this.mainConcept = 0;\n        this.compositionIds = [];\n        this.conceptIds = [];\n        this.internalConnections = [];\n        this.reverse = [];\n        this.linkers = [];\n        this.dependency = [];\n        this.isDataLoaded = false; // checks to see if the data has been loaded to the widget/ function\n        this.isUpdating = false; // this flag helps us check if the state is being updated while the connection updates.\n        this.fetched = false;\n        this.format = NORMAL;\n    }\n    /**\n     * This function will be called when there is a need to listen to a certain type of concept that will update\n     *  the ui.\n     * @param id this is the type id which needs to be tracked\n     */\n    listenToEventType(id) {\n        window.addEventListener(`${id}`, (event) => {\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                let that = this;\n                setTimeout(function () {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        let myEvent = event;\n                        if (!that.compositionIds.includes(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail)) {\n                            that.compositionIds.unshift(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail);\n                            that.listenToEvent(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail);\n                        }\n                        that.isUpdating = false;\n                        yield that.bind();\n                        that.notify();\n                    });\n                }, 200);\n            }\n            else {\n                console.log(\"rejected this\");\n            }\n        });\n    }\n    /**\n     * This is the of the concept id that needs to be listened . If this is called. All the connections that are\n     * created with of the concepts id with this passed id then the event is fired.\n     *\n     * @param id Of the concept id that needs to be listened.\n     */\n    listenToEvent(id) {\n        window.addEventListener(`${id}`, (event) => {\n            console.log(\"this is listening after the event is fired\", id, event);\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                let that = this;\n                setTimeout(function () {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        let newConnection = yield ConnectionData.GetConnectionByOfTheConceptAndType(id, id);\n                        for (let i = 0; i < newConnection.length; i++) {\n                            yield ConnectionData.GetConnection(newConnection[i]).then((conn) => {\n                                if (conn.typeId == that.mainConcept) {\n                                    if (!that.internalConnections.includes(conn.id)) {\n                                        that.internalConnections.push(conn.id);\n                                    }\n                                }\n                                else {\n                                    if (!that.linkers.includes(conn.id)) {\n                                        that.linkers.push(conn.id);\n                                    }\n                                }\n                                if (!that.conceptIds.includes(conn.toTheConceptId)) {\n                                    that.conceptIds.push(conn.toTheConceptId);\n                                }\n                                if (!that.compositionIds.includes(conn.ofTheConceptId)) {\n                                    that.compositionIds.push(conn.ofTheConceptId);\n                                }\n                            });\n                        }\n                        that.isUpdating = false;\n                        yield that.bind();\n                        that.notify();\n                    });\n                }, 200);\n            }\n            else {\n                console.log(\"rejected this\");\n            }\n        });\n    }\n    /**\n     * This function will bind the actual data to the widget or the function.\n     */\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"this is the old execute data\");\n        });\n    }\n    /**\n     *\n     * @param callback the function that needs to be called with the data.\n     * @returns returns the callback with this data as the state.\n     */\n    subscribe(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.subscribers.push(callback);\n            console.log('again executing data');\n            yield this.bind();\n            return callback(this.data);\n        });\n    }\n    /**\n     *\n     * @param callback function that you need to remove from the subscribers list.\n     * @returns\n     */\n    unsubscribe(callback) {\n        this.subscribers.filter(fn => fn != callback);\n        return this.subscribers.length;\n    }\n    /**\n     * This function will call all the subscribers that are registered in this wrapper.\n     */\n    notify() {\n        console.log('notifiers', this.subscribers);\n        this.subscribers.map(subscriber => {\n            console.log('notify');\n            subscriber(this.data);\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConceptsByType } from \"../Api/GetAllConceptsByType\";\nimport { ConceptsData, DATAID, GetAllConnectionsOfCompositionBulk, GetConceptByCharacter, JUSTDATA, NORMAL } from \"../app\";\nimport { GetCompositionFromMemory, GetCompositionFromMemoryNormal, GetCompositionWithIdFromMemory } from \"../Services/GetComposition\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\n/**\n * This wrapper will wrap the listing function and then allow users to return the list.\n */\nexport class GetCompositionListObservable extends DependencyObserver {\n    constructor(compositionName, userId, inpage, page, format) {\n        super();\n        this.data = [];\n        this.startPage = 0;\n        this.compositionName = compositionName;\n        this.userId = userId;\n        this.inpage = inpage;\n        this.page = page;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                console.log(\"again data loading mechanism\");\n                var concept = yield GetConceptByCharacter(this.compositionName);\n                if (concept) {\n                    yield GetAllConceptsByType(this.compositionName, this.userId);\n                    console.log(\"getting the user data\", concept.id, this.userId);\n                    let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, this.userId);\n                    console.log(\"this is the concept list\", conceptList);\n                    var startPage = this.inpage * (this.page - 1);\n                    for (var i = startPage; i < startPage + this.inpage; i++) {\n                        if (conceptList[i]) {\n                            this.compositionIds.push(conceptList[i].id);\n                        }\n                    }\n                }\n                yield GetAllConnectionsOfCompositionBulk(this.compositionIds);\n                this.isDataLoaded = true;\n                this.listenToEventType(concept.id);\n                for (let i = 0; i < this.compositionIds.length; i++) {\n                    console.log(\"list listen\", this.compositionIds[i]);\n                    this.listenToEvent(this.compositionIds[i]);\n                }\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.data = [];\n            console.log(\"this is building the data list\");\n            if (this.format == JUSTDATA) {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionFromMemory(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            else if (this.format == DATAID) {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionWithIdFromMemory(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            else if (this.format == NORMAL) {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionFromMemoryNormal(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            else {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionFromMemory(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            return this.data;\n        });\n    }\n}\n/**\n * This function will give you the list of the concepts by composition name with a listener to any data change.\n */\nexport function GetCompositionListListener(compositionName, userId, inpage, page, format = JUSTDATA) {\n    return new GetCompositionListObservable(compositionName, userId, inpage, page, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData, DATAID, JUSTDATA, NORMAL } from \"../app\";\nimport { GetCompositionById, RecursiveFetchBuildLayer, RecursiveFetchBuildLayerDataId, RecursiveFetchBuildLayerNormal } from \"../Services/GetComposition\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\nexport class GetCompositionObservable extends DependencyObserver {\n    constructor(id, format = JUSTDATA) {\n        super();\n        this.id = id;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                let conceptConnections = yield GetCompositionById(this.id);\n                this.mainConcept = this.id;\n                this.compositionIds = conceptConnections.compositionList;\n                let internalConnections = conceptConnections.connectionList;\n                for (let i = 0; i < internalConnections.length; i++) {\n                    this.internalConnections.push(internalConnections[i].id);\n                }\n                this.isDataLoaded = true;\n                this.listenToEvent(this.mainConcept);\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let latestConnectionList = [];\n            let latestConnectionIds = this.internalConnections;\n            for (let i = 0; i < latestConnectionIds.length; i++) {\n                latestConnectionList.push(yield ConnectionData.GetConnection(latestConnectionIds[i]));\n            }\n            if (this.format == JUSTDATA) {\n                console.log(\"this is the data for the build layer\", latestConnectionList, this.mainConcept, this.internalConnections, this.compositionIds);\n                this.data = yield RecursiveFetchBuildLayer(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            else if (this.format == DATAID) {\n                this.data = yield RecursiveFetchBuildLayerDataId(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            else if (this.format == NORMAL) {\n                this.data = yield RecursiveFetchBuildLayerNormal(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            else {\n                this.data = yield RecursiveFetchBuildLayer(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            return this.data;\n        });\n    }\n}\n/**\n *\n * @param id Id of the composition\n * @returns composition of the id given in the json form.\n */\nexport function GetCompositionListener(id, format = JUSTDATA) {\n    return new GetCompositionObservable(id, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConnectionsOfCompositionBulk, GetCompositionWithIdAndDateFromMemory, GetConceptByCharacterAndType, GetConnectionOfTheConcept, GetTheConcept } from \"../app\";\nimport { DATAIDDATE, JUSTDATA, NORMAL } from \"../Constants/FormatConstants\";\nimport { GetCompositionFromMemory, GetCompositionWithIdFromMemory } from \"../Services/GetComposition\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\n/**\n * This is a class that will give you the observable for the links from a certain concept.\n */\nexport class GetLinkObservable extends DependencyObserver {\n    /**\n     *\n     * @param id this is the id whose links need to be found\n     * @param linker this is the type connection that is connected to the mainConcept(id)\n     * @param inpage number of outputs that has to be displayed\n     * @param page the page which needs to be displayed as per the inpage parameter\n     * @param format the format in which the output should be displayed (NORMAL, DATAID,JUSTDATA,DATAIDDATE)\n     */\n    constructor(id, linker, inpage, page, format) {\n        super();\n        this.connections = [];\n        this.data = [];\n        this.mainConcept = id;\n        this.linker = linker;\n        this.inpage = inpage;\n        this.page = page;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (!this.isDataLoaded) {\n                let concept = yield GetTheConcept(this.mainConcept);\n                let linkString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + this.linker;\n                let relatedConceptString = yield GetConceptByCharacterAndType(linkString, 16);\n                let relatedConcept = relatedConceptString;\n                if (relatedConcept.id > 0) {\n                    let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, this.inpage, this.page);\n                    this.connections = connectionsString;\n                    var prefetch = [];\n                    for (var i = 0; i < this.connections.length; i++) {\n                        prefetch.push(this.connections[i].toTheConceptId);\n                        this.listenToEvent(this.connections[i].toTheConceptId);\n                    }\n                    // await GetAllConnectionsOfCompositionBulk(prefetch);\n                    yield GetAllConnectionsOfCompositionBulk(prefetch);\n                }\n                this.isDataLoaded = true;\n                this.listenToEvent(this.mainConcept);\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (var i = 0; i < this.connections.length; i++) {\n                let toConceptId = this.connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                console.log(\"this is the format\", this.format);\n                if (this.format == NORMAL) {\n                    let newComposition = yield GetCompositionWithIdFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n                else if (this.format == JUSTDATA) {\n                    let newComposition = yield GetCompositionFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n                else if (this.format == DATAIDDATE) {\n                    let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n                else {\n                    let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n            }\n            return this.data;\n        });\n    }\n}\n/**\n *\n * @param id this is the id whose links need to be found\n * @param linker this is the type connection that is connected to the mainConcept(id)\n * @param inpage number of outputs that has to be displayed\n * @param page the page which needs to be displayed as per the inpage parameter\n * @param format the format in which the output should be displayed (NORMAL, DATAID,JUSTDATA,DATAIDDATE)\n */\nexport function GetLinkListener(id, linker, inpage, page, format = NORMAL) {\n    return new GetLinkObservable(id, linker, inpage, page, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DependencyObserver, GetAllConnectionsOfCompositionBulk, GetCompositionFromConnectionsWithDataId, GetConnectionBulk, RecursiveSearchApiRaw, } from \"../app\";\nimport { RAW } from \"../Constants/FormatConstants\";\nclass RecursiveSearchObservable extends DependencyObserver {\n    /**\n     *\n     * @param id this is the id whose links need to be found\n     * @param linker this is the type connection that is connected to the mainConcept(id)\n     * @param inpage number of outputs that has to be displayed\n     * @param page the page which needs to be displayed as per the inpage parameter\n     * @param format the format in which the output should be displayed (RAW, undefined)\n     */\n    constructor(id, linkers, textSearch = \"\", format) {\n        super();\n        this.searchText = \"\";\n        this.connections = [];\n        this.data = [];\n        this.mainConcept = id;\n        this.searchLinkers = linkers;\n        this.textSearch = textSearch;\n        if (format)\n            this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                const result = yield RecursiveSearchApiRaw(this.mainConcept, this.searchLinkers, this.textSearch);\n                this.compositionIds = result.compositionIds || [];\n                this.internalConnections = result.internalConnections || [];\n                const externalConnections = result.externalConnections || [];\n                const internalConnections = yield GetConnectionBulk(this.internalConnections);\n                this.connections = yield GetConnectionBulk(externalConnections);\n                var prefetch = [];\n                // listen external connection\n                for (var i = 0; i < this.connections.length; i++) {\n                    prefetch.push(this.connections[i].toTheConceptId);\n                    this.listenToEvent(this.connections[i].toTheConceptId);\n                }\n                // listen internal connection\n                for (var i = 0; i < internalConnections.length; i++) {\n                    prefetch.push(internalConnections[i].toTheConceptId);\n                    this.listenToEvent(internalConnections[i].toTheConceptId);\n                }\n                yield GetAllConnectionsOfCompositionBulk(prefetch);\n                this.isDataLoaded = true;\n                this.listenToEvent(this.mainConcept);\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.format && this.format == RAW) {\n                this.data = {\n                    compositionIds: this.compositionIds,\n                    internalConnections: this.internalConnections,\n                    externalConnections: this.connections,\n                };\n            }\n            else {\n                this.data = yield GetCompositionFromConnectionsWithDataId(this.compositionIds, this.internalConnections);\n            }\n            return this.data;\n        });\n    }\n}\n/**\n * Method to listen the changes in recursive search data\n * @param id this is the id whose links need to be found\n * @param linker this is the type connection that is connected to the mainConcept(id)\n * @param inpage number of outputs that has to be displayed\n * @param page the page which needs to be displayed as per the inpage parameter\n * @param format the format in which the output should be displayed (RAW, undefined)\n */\nexport function RecursiveSearchListener(id, linkers, searchText = \"\", format) {\n    return new RecursiveSearchObservable(id, linkers, searchText, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchLinkMultipleAll } from \"../app\";\nimport { DATAID } from \"../Constants/FormatConstants\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\nexport class SearchLinkMultipleAllObservable extends DependencyObserver {\n    constructor(searchQuery, token, format = DATAID) {\n        super();\n        this.searchQuery = [];\n        this.format = DATAID;\n        this.searchQuery = searchQuery;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.data = yield SearchLinkMultipleAll(this.searchQuery, \"\", this, this.format);\n            this.mainConcept = this.searchQuery[0].composition;\n            this.listenToEvent(this.mainConcept);\n            console.log(\"this is the data\", this.data);\n            return this.data;\n        });\n    }\n}\n/**\n *\n * @param searchQueries Queries that need to be executed.\n * @param token token of the user.\n * @returns  returns the json format of the output.\n */\nexport function searchLinkMultipleListener(searchQueries, token, format = DATAID) {\n    return new SearchLinkMultipleAllObservable(searchQueries, token !== null && token !== void 0 ? token : \"\", format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport { init, updateAccessToken };\nimport CreateConceptBinaryTreeFromIndexDb from './Services/CreateBinaryTreeFromData';\nimport { IdentifierFlags } from './DataStructures/IdentifierFlags';\nexport { SearchLinkMultipleApi } from './Api/Search/SearchLinkMultipleApi';\nexport { SplitStrings } from './Services/SplitStrings';\nexport { GetCompositionList, GetCompositionListWithId } from './Services/GetCompositionList';\nexport { GetCompositionListLocal, GetCompositionListLocalWithId } from './Services/Local/GetCompositionListLocal';\nexport { GetAllConnectionsOfComposition } from './Api/GetAllConnectionsOfComposition';\nexport { GetComposition, GetCompositionWithId, recursiveFetch, GetCompositionWithAllIds } from './Services/GetComposition';\nexport { GetCompositionLocal, GetCompositionLocalWithId } from './Services/Local/GetCompositionLocal';\nexport { default as CreateComposition } from './Services/CreateTheComposition';\nexport { CreateTheCompositionLocal } from './Services/Local/CreateTheCompositionLocal';\nexport { CreateConnectionBetweenTwoConcepts, CreateConnectionBetweenTwoConceptsGeneral } from './Services/CreateConnectionBetweenTwoConcepts';\nexport { default as GetTheConcept } from './Services/GetTheConcept';\nexport { default as MakeTheInstanceConcept } from './Services/MakeTheInstanceConcept';\nexport { MakeTheInstanceConceptLocal } from './Services/Local/MakeTheInstanceConceptLocal';\nexport { storeToDatabase, getFromDatabaseWithType, getObjectsFromIndexDb } from './Database/NoIndexDb';\nexport { createTheConnection as CreateTheConnection } from './Services/CreateTheConnection';\nexport { default as GetConceptByCharacter } from './Services/GetConceptByCharacter';\nexport { GetLink, GetLinkRaw } from './Services/GetLink';\nexport { CreateDefaultConcept } from './Services/CreateDefaultConcept';\nexport { MakeTheTypeConceptLocal } from './Services/Local/MakeTheTypeLocal';\nexport { MakeTheTypeConcept } from './Services/MakeTheTypeConcept';\nexport { MakeTheTypeConceptApi } from './Api/MakeTheTypeConceptApi';\nexport { GetLinkerConnectionFromConcepts, GetLinkerConnectionToConcepts } from './Services/GetLinkerConnectionFromConcept';\nexport { DeleteConceptById } from './Services/DeleteConcept';\nexport { DeleteConnectionById } from './Services/DeleteConnection';\nexport { TrashTheConcept } from './Api/Delete/DeleteConceptInBackend';\nexport { GetConnectionById } from './Services/GetConnections';\nexport { MakeTheTimestamp } from './Services/MakeTheTimestamp';\nexport { RecursiveSearchApi, RecursiveSearchApiRaw, RecursiveSearchApiRawFullLinker, RecursiveSearchApiNewRawFullLinker } from './Api/RecursiveSearch';\nexport { GetCompositionBulkWithDataId, GetCompositionBulk, GetCompositionFromConnectionsWithDataId } from './Services/GetCompositionBulk';\nexport { GetConceptBulk } from './Api/GetConceptBulk';\nexport { GetConnectionBulk } from './Api/GetConnectionBulk';\nexport { GetAllConnectionsOfCompositionBulk } from './Api/GetAllConnectionsOfCompositionBulk';\nexport { LoginToBackend } from './Api/Login';\nexport { GetConnectionOfTheConcept } from './Api/GetConnectionOfTheConcept';\nexport { default as Signup } from './Api/Signup';\nexport { default as Signin } from './Api/Signin';\nexport { default as UpdateComposition } from './Services/UpdateComposition';\nexport { SearchAllConcepts } from './Api/Search/Search';\nexport { SearchWithLinker } from './Api/Search/SearchWithLinker';\nexport { GetCompositionWithCache, GetCompositionWithDataIdWithCache, GetCompositionWithDataIdBulk } from './Services/Composition/CompositionCache';\nexport { CreateSession } from './Api/Session/CreateSession';\nexport { CreateSessionVisit } from './Api/Session/CreateSessionVisit';\nexport { GetRelation, GetRelationRaw } from './Services/GetRelation';\nexport { recursiveFetchNew } from './Services/Composition/BuildComposition';\nexport { CreateTheCompositionWithCache } from './Services/Composition/CreateCompositionCache';\nexport { CreateDefaultLConcept } from './Services/Local/CreateDefaultLConcept';\nexport { CreateTheConnectionGeneral } from './Services/CreateTheConnectionGeneral';\nexport { CreateTheConnectionLocal } from './Services/Local/CreateTheConnectionLocal';\nexport { GetCompositionListAll, GetCompositionListAllWithId, GetCompositionListWithIdUpdated } from './Services/GetCompositionList';\nexport { GetUserGhostId, AddGhostConcept } from './Services/User/UserTranslation';\nexport { SearchLinkMultipleAll, FormatFromConnections } from './Services/Search/SearchLinkMultiple';\nexport { GetTheConceptLocal } from './Services/Local/GetTheConceptLocal';\nexport { UpdateCompositionLocal } from './Services/Local/UpdateCompositionLocal';\nexport { GetCompositionFromConnectionsWithDataIdInObject, GetCompositionFromConnectionsWithIndex, GetCompositionFromConnectionsWithDataIdIndex } from './Services/GetCompositionBulk';\nexport { GetRelationLocal } from './Services/Local/GetRelationLocal';\nexport { GetConceptByCharacterAndCategoryLocal } from './Services/Local/GetConceptByCharacterLocal';\nexport { ViewInternalData } from './Services/View/ViewInternalData';\nexport { ViewInternalDataApi } from './Api/View/ViewInternalDataApi';\nexport { convertFromLConceptToConcept, convertFromConceptToLConcept } from './Services/Conversion/ConvertConcepts';\nexport { SearchLinkInternal } from './Services/Search/SearchLinkInternal';\nexport { CreateConnectionBetweenTwoConceptsLocal } from './Services/Local/CreateConnectionBetweenTwoConceptsLocal';\nexport { DeleteConceptLocal } from './Services/Local/DeleteConceptLocal';\nexport { GetConnectionBetweenTwoConceptsLinker } from './Services/GetConnectionBetweenTwoConceptsLinker';\nexport { DelayFunctionExecution } from './Services/Common/DelayFunction';\nexport { GetCompositionWithIdAndDateFromMemory } from './Services/GetComposition';\nexport { GetConceptByCharacterAndType } from './Api/GetConceptByCharacterAndType';\nexport { GetConnectionDataPrefetch } from './Services/GetCompositionBulk';\nexport { FormatFromConnectionsAltered } from './Services/Search/SearchLinkMultiple';\nexport { NORMAL, JUSTDATA, DATAID, DATAIDDATE, RAW } from './Constants/FormatConstants';\nexport { PRIVATE, PUBLIC, ADMIN } from './Constants/AccessConstants';\nexport { SearchWithTypeAndLinkerApi } from './Api/Search/SearchWithTypeAndLinker';\nexport { DependencyObserver } from './WrapperFunctions/DepenedencyObserver';\nexport { SearchLinkMultipleAllObservable, searchLinkMultipleListener } from './WrapperFunctions/SearchLinkMultipleAllObservable';\nexport { GetCompositionListener } from './WrapperFunctions/GetCompositionObservable';\nexport { GetCompositionListListener } from './WrapperFunctions/GetCompositionListObservable';\nexport { SearchWithTypeAndLinker } from './Services/Search/SearchWithTypeAndLinker';\nexport { GetLinkListener } from './WrapperFunctions/GetLinkObservable';\nexport { RecursiveSearchListener } from './WrapperFunctions/RecursiveSearchObservable';\nexport { SyncData } from './DataStructures/SyncData';\nexport { Concept } from './DataStructures/Concept';\nexport { LConcept } from './DataStructures/Local/LConcept';\nexport { LConnection } from './DataStructures/Local/LConnection';\nexport { Connection } from './DataStructures/Connection';\nexport { ConceptsData } from './DataStructures/ConceptData';\nexport { ConnectionData } from './DataStructures/ConnectionData';\nexport { BinaryTree } from './DataStructures/BinaryTree';\nexport { SearchQuery } from './DataStructures/SearchQuery';\nexport { PatcherStructure } from './DataStructures/PatcherStructure';\nexport { SessionData } from './DataStructures/Session/SessionData';\nexport { Composition } from './DataStructures/Composition/Composition';\nexport { CompositionBinaryTree } from './DataStructures/Composition/CompositionBinaryTree';\nexport { CompositionNode } from './DataStructures/Composition/CompositionNode';\nexport { LocalSyncData } from './DataStructures/Local/LocalSyncData';\nexport { UserBinaryTree } from './DataStructures/User/UserBinaryTree';\nexport { FilterSearch } from './DataStructures/FilterSearch';\nexport { SearchStructure } from './DataStructures/Search/SearchStructure';\nexport { LocalConceptsData } from './DataStructures/Local/LocalConceptData';\nimport { GetConnectionsFromIndexDb, GetConnectionsFromIndexDbLocal } from './Services/GetDataFromIndexDb';\nimport CreateLocalBinaryTreeFromIndexDb from './Services/Local/CreateLocalBinaryTreeFromData';\nimport InitializeSystem from './Services/InitializeSystem';\nimport { BaseUrl } from './DataStructures/BaseUrl';\nimport { TokenStorage } from './DataStructures/Security/TokenStorage';\nexport { BaseUrl } from './DataStructures/BaseUrl';\n/**\n * This function lets you update the access token that the package uses. If this is not passed you cannot create, update, view or delete\n * Your concepts using this package.\n * @param accessToken access token got from the sign in process\n */\nfunction updateAccessToken(accessToken = \"\") {\n    TokenStorage.BearerAccessToken = accessToken;\n}\n/**\n *\n * @param url This is the url for the backend c# system or our main data fabric server\n * @param aiurl This is the AI url that pulls in the data using our AI system . If you do not enter this then also disable the enableAi flag.\n * @param accessToken This is the JWT token that needs to be passed (But since you have just initilized the system). There is no way we can get access token\n * So this access token can be empty string. You can set it afterwards with another function UpdateAccessToken();\n * @param nodeUrl This is the url for the node server. This is another server in the data fabric that is used as server for business logic and security features.\n * @param enableAi This flag is used to enable or disable the AI feature that preloads data in the indexdb.\n * @param applicationName This is an unique name that is given to a program. Use this to discern one indexdb from another.\n */\nfunction init() {\n    return __awaiter(this, arguments, void 0, function* (url = \"\", aiurl = \"\", accessToken = \"\", nodeUrl = \"\", enableAi = true, applicationName = \"\", isTest = false) {\n        /**\n         * This process sets the initlizers in the static class BaseUrl that is used all over the system to access the urls\n         * Here we set the following variables.\n         * randomizer is created so that we can uniquely identify this initlization process but in the case that the BASE_RANDOMIZER has been alreay\n         * set in the indexdb this is replaced by the indexdb value.\n         */\n        try {\n            BaseUrl.BASE_URL = url;\n            BaseUrl.AI_URL = aiurl;\n            BaseUrl.NODE_URL = nodeUrl;\n            BaseUrl.BASE_APPLICATION = applicationName;\n            TokenStorage.BearerAccessToken = accessToken;\n            let randomizer = Math.floor(Math.random() * 100000000);\n            BaseUrl.BASE_RANDOMIZER = randomizer;\n            if (isTest) {\n                IdentifierFlags.isDataLoaded = true;\n                IdentifierFlags.isCharacterLoaded = true;\n                IdentifierFlags.isTypeLoaded = true;\n                IdentifierFlags.isLocalDataLoaded = true;\n                IdentifierFlags.isLocalTypeLoaded = true;\n                IdentifierFlags.isLocalCharacterLoaded = true;\n                IdentifierFlags.isConnectionLoaded = true;\n                IdentifierFlags.isConnectionTypeLoaded = true;\n                IdentifierFlags.isLocalConnectionLoaded = true;\n                return true;\n            }\n            console.log(\"This ist he base url\", BaseUrl.BASE_URL, randomizer);\n            /**\n                * We initialize the system so that we get all the concepts from the backend system that are most likely to be used\n                * We use some sort of AI algorithm to initilize these concepts with the most used concept.\n                * @param enableAi enableAi is a flag that the user can choose to set if they want to use this enable AI feature\n                * If the developer does not want to use this feature then they can just set enableAi to false.\n                */\n            yield InitializeSystem(enableAi);\n            const start = new Date().getTime();\n            /**\n             * This  will create a binary tree in the memory from the indexdb.\n             * This process will set Flags to denote that the binary tree is loaded, the character binary tree is  loaded\n             * and that the type binary tree has been loaded.\n             * These trees are helpful in caching concepts and connections for the data fabric.\n             */\n            yield CreateConceptBinaryTreeFromIndexDb().then(() => {\n                // IdentifierFlags.isDataLoaded= true;\n                // IdentifierFlags.isCharacterLoaded= true;\n                // IdentifierFlags.isTypeLoaded= true;\n                let elapsed = new Date().getTime() - start;\n                console.log(\"The time taken to prepare concept  data is  \", elapsed);\n            }).catch((event) => {\n                // console.log(\"This is the error in creating binary tree\", IdentifierFlags.isDataLoaded, IdentifierFlags.isCharacterLoaded, IdentifierFlags.isTypeLoaded);\n                throw event;\n            });\n            /**\n             * This will create a binary tree of local concepts that is saved from the indexdb.\n             * This process after finishing creating a binary tree of local concepts then set flag to denote that\n             * LocalBinaryTree has been created from the concepts in indexdb\n             * Local Binary Type tree has been loaded to the index db (flag is set to denote that)\n             * Character Binary Tree has been loaded from indexdb to memory (flag is set to denote that)\n             */\n            yield CreateLocalBinaryTreeFromIndexDb().then(() => {\n                // IdentifierFlags.isLocalDataLoaded = true;\n                // IdentifierFlags.isLocalTypeLoaded = true;\n                // IdentifierFlags.isLocalCharacterLoaded = true;\n                let elapsed = new Date().getTime() - start;\n                console.log(\"The time taken to prepare local concept  \", elapsed);\n            }).catch((event) => {\n                throw event;\n            });\n            /**\n             * This process gets the local connections from indexdb and loads it to the local connections array which is inside of\n             * a static class called LocalConnectionData.\n             * This function will also set and IdentifierFlag that tells the whole program that this process has finished.\n             */\n            yield GetConnectionsFromIndexDbLocal().then(() => {\n                IdentifierFlags.isLocalConnectionLoaded = true;\n            }).catch((event) => {\n                //console.log(\"This is the error in creating local connections binary tree\");\n                throw event;\n            });\n            /**\n             * We have designed our system to use local concepts and connections with its own local ids(negative ids) that\n             * is only valid for the browser that creates this. We have a translator in our node server.\n             * This function does this process in initlization.\n             */\n            // PopulateTheLocalSettingsToMemory().then(()=>{\n            // }).catch((event) => {\n            //    //console.log(\"This is the error in populating binary tree\");\n            //   throw event;\n            // });\n            /**\n             * This process gets the connections from indexdb and loads it to the connections array which is inside of\n             * a static class called ConnectionData.\n             * This function will also set and IdentifierFlag that tells the whole program that this process has finished.\n             */\n            yield GetConnectionsFromIndexDb().then(() => {\n                IdentifierFlags.isConnectionLoaded = true;\n                IdentifierFlags.isConnectionTypeLoaded = true;\n                let elapsed = new Date().getTime() - start;\n                console.log(\"The time taken to prepare connections  \", elapsed);\n            }).catch((event) => {\n                //console.log(\"This is the error in creating connections tree\");\n                throw event;\n            });\n            return true;\n        }\n        catch (error) {\n            console.log(\"cannot initialize the system\", error);\n        }\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/app.ts\");\n",""],"names":[],"sourceRoot":""}